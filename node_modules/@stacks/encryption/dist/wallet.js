"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptMnemonic = exports.encryptMnemonic = void 0;
const common_1 = require("@stacks/common");
const bip39_1 = require("@scure/bip39");
const english_1 = require("@scure/bip39/wordlists/english");
const cryptoRandom_1 = require("./cryptoRandom");
const sha2Hash_1 = require("./sha2Hash");
const hmacSha256_1 = require("./hmacSha256");
const aesCipher_1 = require("./aesCipher");
const pbkdf2_1 = require("./pbkdf2");
async function encryptMnemonic(phrase, password, opts) {
    let mnemonicEntropy;
    try {
        const entropyBytes = (0, bip39_1.mnemonicToEntropy)(phrase, english_1.wordlist);
        mnemonicEntropy = common_1.Buffer.from(entropyBytes).toString('hex');
    }
    catch (error) {
        console.error('Invalid mnemonic phrase provided');
        console.error(error);
        throw new Error('Not a valid bip39 mnemonic');
    }
    const plaintextNormalized = common_1.Buffer.from(mnemonicEntropy, 'hex');
    const pbkdf2 = await (0, pbkdf2_1.createPbkdf2)();
    let salt;
    if (opts && opts.getRandomBytes) {
        salt = opts.getRandomBytes(16);
    }
    else {
        salt = (0, cryptoRandom_1.randomBytes)(16);
    }
    const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');
    const encKey = keysAndIV.slice(0, 16);
    const macKey = keysAndIV.slice(16, 32);
    const iv = keysAndIV.slice(32, 48);
    const cipher = await (0, aesCipher_1.createCipher)();
    const cipherText = await cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);
    const hmacPayload = common_1.Buffer.concat([salt, cipherText]);
    const hmacSha256 = await (0, hmacSha256_1.createHmacSha256)();
    const hmacDigest = await hmacSha256.digest(macKey, hmacPayload);
    const payload = common_1.Buffer.concat([salt, hmacDigest, cipherText]);
    return payload;
}
exports.encryptMnemonic = encryptMnemonic;
class PasswordError extends Error {
}
async function decryptMnemonicBuffer(dataBuffer, password) {
    const salt = dataBuffer.slice(0, 16);
    const hmacSig = dataBuffer.slice(16, 48);
    const cipherText = dataBuffer.slice(48);
    const hmacPayload = common_1.Buffer.concat([salt, cipherText]);
    const pbkdf2 = await (0, pbkdf2_1.createPbkdf2)();
    const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');
    const encKey = keysAndIV.slice(0, 16);
    const macKey = keysAndIV.slice(16, 32);
    const iv = keysAndIV.slice(32, 48);
    const decipher = await (0, aesCipher_1.createCipher)();
    const decryptedResult = await decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);
    const hmacSha256 = await (0, hmacSha256_1.createHmacSha256)();
    const hmacDigest = await hmacSha256.digest(macKey, hmacPayload);
    const sha2Hash = await (0, sha2Hash_1.createSha2Hash)();
    const hmacSigHash = await sha2Hash.digest(hmacSig);
    const hmacDigestHash = await sha2Hash.digest(hmacDigest);
    if (!hmacSigHash.equals(hmacDigestHash)) {
        throw new PasswordError('Wrong password (HMAC mismatch)');
    }
    let mnemonic;
    try {
        mnemonic = (0, bip39_1.entropyToMnemonic)(decryptedResult, english_1.wordlist);
    }
    catch (error) {
        console.error('Error thrown by `entropyToMnemonic`');
        console.error(error);
        throw new PasswordError('Wrong password (invalid plaintext)');
    }
    if (!(0, bip39_1.validateMnemonic)(mnemonic, english_1.wordlist)) {
        throw new PasswordError('Wrong password (invalid plaintext)');
    }
    return mnemonic;
}
function decryptLegacy(dataBuffer, password, triplesecDecrypt) {
    return new Promise((resolve, reject) => {
        if (!triplesecDecrypt) {
            reject(new Error('The `triplesec.decrypt` function must be provided'));
        }
        triplesecDecrypt({
            key: common_1.Buffer.from(password),
            data: dataBuffer,
        }, (err, plaintextBuffer) => {
            if (!err) {
                resolve(plaintextBuffer);
            }
            else {
                reject(err);
            }
        });
    });
}
async function decryptMnemonic(data, password, triplesecDecrypt) {
    const dataBuffer = common_1.Buffer.isBuffer(data) ? data : common_1.Buffer.from(data, 'hex');
    try {
        return await decryptMnemonicBuffer(dataBuffer, password);
    }
    catch (err) {
        if (err instanceof PasswordError) {
            throw err;
        }
        const data = await decryptLegacy(dataBuffer, password, triplesecDecrypt);
        return data.toString();
    }
}
exports.decryptMnemonic = decryptMnemonic;
//# sourceMappingURL=wallet.js.map