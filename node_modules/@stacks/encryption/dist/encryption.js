"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptContent = exports.encryptContent = void 0;
const common_1 = require("@stacks/common");
const ec_1 = require("./ec");
const keys_1 = require("./keys");
async function encryptContent(content, options) {
    const opts = Object.assign({}, options);
    let privateKey;
    if (!opts.publicKey) {
        if (!opts.privateKey) {
            throw new Error('Either public key or private key must be supplied for encryption.');
        }
        opts.publicKey = (0, keys_1.getPublicKeyFromPrivate)(opts.privateKey);
    }
    let wasString;
    if (typeof opts.wasString === 'boolean') {
        wasString = opts.wasString;
    }
    else {
        wasString = typeof content === 'string';
    }
    const contentBuffer = typeof content === 'string' ? common_1.Buffer.from(content) : content;
    const cipherObject = await (0, ec_1.encryptECIES)(opts.publicKey, contentBuffer, wasString, opts.cipherTextEncoding);
    let cipherPayload = JSON.stringify(cipherObject);
    if (opts.sign) {
        if (typeof opts.sign === 'string') {
            privateKey = opts.sign;
        }
        else if (!privateKey) {
            privateKey = opts.privateKey;
        }
        const signatureObject = (0, ec_1.signECDSA)(privateKey, cipherPayload);
        const signedCipherObject = {
            signature: signatureObject.signature,
            publicKey: signatureObject.publicKey,
            cipherText: cipherPayload,
        };
        cipherPayload = JSON.stringify(signedCipherObject);
    }
    return cipherPayload;
}
exports.encryptContent = encryptContent;
function decryptContent(content, options) {
    const opts = Object.assign({}, options);
    if (!opts.privateKey) {
        throw new Error('Private key is required for decryption.');
    }
    try {
        const cipherObject = JSON.parse(content);
        return (0, ec_1.decryptECIES)(opts.privateKey, cipherObject);
    }
    catch (err) {
        if (err instanceof SyntaxError) {
            throw new Error('Failed to parse encrypted content JSON. The content may not ' +
                'be encrypted. If using getFile, try passing { decrypt: false }.');
        }
        else {
            throw err;
        }
    }
}
exports.decryptContent = decryptContent;
//# sourceMappingURL=encryption.js.map