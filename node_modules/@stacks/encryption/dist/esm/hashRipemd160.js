import { Buffer } from '@stacks/common';
import Ripemd160Polyfill from 'ripemd160-min';
export class Ripemd160PolyfillDigest {
    digest(data) {
        const instance = new Ripemd160Polyfill();
        instance.update(data);
        const hash = instance.digest();
        if (Array.isArray(hash)) {
            return Buffer.from(hash);
        }
        else {
            return Buffer.from(hash.buffer);
        }
    }
}
export class NodeCryptoRipemd160Digest {
    constructor(nodeCryptoCreateHash) {
        this.nodeCryptoCreateHash = nodeCryptoCreateHash;
    }
    digest(data) {
        try {
            return this.nodeCryptoCreateHash('rmd160').update(data).digest();
        }
        catch (error) {
            try {
                return this.nodeCryptoCreateHash('ripemd160').update(data).digest();
            }
            catch (_err) {
                console.log(error);
                console.log('Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation');
                const polyfill = new Ripemd160PolyfillDigest();
                return polyfill.digest(data);
            }
        }
    }
}
export function createHashRipemd160() {
    return new Ripemd160PolyfillDigest();
}
export function hashRipemd160(data) {
    const hash = createHashRipemd160();
    return hash.digest(data);
}
//# sourceMappingURL=hashRipemd160.js.map