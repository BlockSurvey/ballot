import { hmac } from '@noble/hashes/hmac';
import { sha256 } from '@noble/hashes/sha256';
import { getPublicKey as nobleGetPublicKey, signSync, utils } from '@noble/secp256k1';
import { Buffer, privateKeyToBuffer, PRIVATE_KEY_COMPRESSED_LENGTH } from '@stacks/common';
import base58 from 'bs58';
import { hashRipemd160 } from './hashRipemd160';
import { hashSha256Sync } from './sha2Hash';
const BITCOIN_PUBKEYHASH = 0x00;
utils.hmacSha256Sync = (key, ...msgs) => {
    const h = hmac.create(sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
export function makeECPrivateKey() {
    return Buffer.from(utils.randomPrivateKey()).toString('hex');
}
export function base58CheckDecode(btcAddress) {
    const buffer = Buffer.from(base58.decode(btcAddress));
    const payload = buffer.slice(0, -4);
    const checksum = buffer.slice(-4);
    const newChecksum = sha256(sha256(payload));
    if ((checksum[0] ^ newChecksum[0]) |
        (checksum[1] ^ newChecksum[1]) |
        (checksum[2] ^ newChecksum[2]) |
        (checksum[3] ^ newChecksum[3])) {
        throw new Error('Invalid checksum');
    }
    if (payload.length !== 21)
        throw new TypeError('Invalid address length');
    const version = payload.readUInt8(0);
    const hash = payload.slice(1);
    return { version, hash };
}
export function base58Encode(hash) {
    const checksum = Buffer.from(sha256(sha256(hash)));
    return base58.encode(Buffer.concat([hash, checksum], hash.length + 4));
}
export function base58CheckEncode(version, hash) {
    return base58Encode(Buffer.from([version, ...hash].slice(0, 21)));
}
export function publicKeyToAddress(publicKey) {
    const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');
    const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBuffer));
    return base58CheckEncode(BITCOIN_PUBKEYHASH, publicKeyHash160);
}
export function publicKeyToBtcAddress(publicKey, version = BITCOIN_PUBKEYHASH) {
    const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');
    const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBuffer));
    return base58CheckEncode(version, publicKeyHash160);
}
export function getPublicKeyFromPrivate(privateKey) {
    const privateKeyBuffer = privateKeyToBuffer(privateKey);
    return Buffer.from(nobleGetPublicKey(privateKeyBuffer.slice(0, 32), true)).toString('hex');
}
export function ecSign(messageHash, hexPrivateKey) {
    return Buffer.from(signSync(messageHash, privateKeyToBuffer(hexPrivateKey).slice(0, 32), {
        der: false,
    }));
}
export function ecPrivateKeyToHexString(privateKey) {
    return privateKey.toString('hex');
}
export function isValidPrivateKey(privateKey) {
    return utils.isValidPrivateKey(privateKeyToBuffer(privateKey));
}
export function compressPrivateKey(privateKey) {
    const privateKeyBuffer = privateKeyToBuffer(privateKey);
    return privateKeyBuffer.length == PRIVATE_KEY_COMPRESSED_LENGTH
        ? privateKeyBuffer
        : Buffer.concat([privateKeyBuffer, Buffer.from([1])]);
}
//# sourceMappingURL=keys.js.map