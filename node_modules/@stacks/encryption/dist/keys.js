"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compressPrivateKey = exports.isValidPrivateKey = exports.ecPrivateKeyToHexString = exports.ecSign = exports.getPublicKeyFromPrivate = exports.publicKeyToBtcAddress = exports.publicKeyToAddress = exports.base58CheckEncode = exports.base58Encode = exports.base58CheckDecode = exports.makeECPrivateKey = void 0;
const hmac_1 = require("@noble/hashes/hmac");
const sha256_1 = require("@noble/hashes/sha256");
const secp256k1_1 = require("@noble/secp256k1");
const common_1 = require("@stacks/common");
const bs58_1 = __importDefault(require("bs58"));
const hashRipemd160_1 = require("./hashRipemd160");
const sha2Hash_1 = require("./sha2Hash");
const BITCOIN_PUBKEYHASH = 0x00;
secp256k1_1.utils.hmacSha256Sync = (key, ...msgs) => {
    const h = hmac_1.hmac.create(sha256_1.sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
function makeECPrivateKey() {
    return common_1.Buffer.from(secp256k1_1.utils.randomPrivateKey()).toString('hex');
}
exports.makeECPrivateKey = makeECPrivateKey;
function base58CheckDecode(btcAddress) {
    const buffer = common_1.Buffer.from(bs58_1.default.decode(btcAddress));
    const payload = buffer.slice(0, -4);
    const checksum = buffer.slice(-4);
    const newChecksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(payload));
    if ((checksum[0] ^ newChecksum[0]) |
        (checksum[1] ^ newChecksum[1]) |
        (checksum[2] ^ newChecksum[2]) |
        (checksum[3] ^ newChecksum[3])) {
        throw new Error('Invalid checksum');
    }
    if (payload.length !== 21)
        throw new TypeError('Invalid address length');
    const version = payload.readUInt8(0);
    const hash = payload.slice(1);
    return { version, hash };
}
exports.base58CheckDecode = base58CheckDecode;
function base58Encode(hash) {
    const checksum = common_1.Buffer.from((0, sha256_1.sha256)((0, sha256_1.sha256)(hash)));
    return bs58_1.default.encode(common_1.Buffer.concat([hash, checksum], hash.length + 4));
}
exports.base58Encode = base58Encode;
function base58CheckEncode(version, hash) {
    return base58Encode(common_1.Buffer.from([version, ...hash].slice(0, 21)));
}
exports.base58CheckEncode = base58CheckEncode;
function publicKeyToAddress(publicKey) {
    const publicKeyBuffer = common_1.Buffer.isBuffer(publicKey) ? publicKey : common_1.Buffer.from(publicKey, 'hex');
    const publicKeyHash160 = (0, hashRipemd160_1.hashRipemd160)((0, sha2Hash_1.hashSha256Sync)(publicKeyBuffer));
    return base58CheckEncode(BITCOIN_PUBKEYHASH, publicKeyHash160);
}
exports.publicKeyToAddress = publicKeyToAddress;
function publicKeyToBtcAddress(publicKey, version = BITCOIN_PUBKEYHASH) {
    const publicKeyBuffer = common_1.Buffer.isBuffer(publicKey) ? publicKey : common_1.Buffer.from(publicKey, 'hex');
    const publicKeyHash160 = (0, hashRipemd160_1.hashRipemd160)((0, sha2Hash_1.hashSha256Sync)(publicKeyBuffer));
    return base58CheckEncode(version, publicKeyHash160);
}
exports.publicKeyToBtcAddress = publicKeyToBtcAddress;
function getPublicKeyFromPrivate(privateKey) {
    const privateKeyBuffer = (0, common_1.privateKeyToBuffer)(privateKey);
    return common_1.Buffer.from((0, secp256k1_1.getPublicKey)(privateKeyBuffer.slice(0, 32), true)).toString('hex');
}
exports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;
function ecSign(messageHash, hexPrivateKey) {
    return common_1.Buffer.from((0, secp256k1_1.signSync)(messageHash, (0, common_1.privateKeyToBuffer)(hexPrivateKey).slice(0, 32), {
        der: false,
    }));
}
exports.ecSign = ecSign;
function ecPrivateKeyToHexString(privateKey) {
    return privateKey.toString('hex');
}
exports.ecPrivateKeyToHexString = ecPrivateKeyToHexString;
function isValidPrivateKey(privateKey) {
    return secp256k1_1.utils.isValidPrivateKey((0, common_1.privateKeyToBuffer)(privateKey));
}
exports.isValidPrivateKey = isValidPrivateKey;
function compressPrivateKey(privateKey) {
    const privateKeyBuffer = (0, common_1.privateKeyToBuffer)(privateKey);
    return privateKeyBuffer.length == common_1.PRIVATE_KEY_COMPRESSED_LENGTH
        ? privateKeyBuffer
        : common_1.Buffer.concat([privateKeyBuffer, common_1.Buffer.from([1])]);
}
exports.compressPrivateKey = compressPrivateKey;
//# sourceMappingURL=keys.js.map