"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashRipemd160 = exports.createHashRipemd160 = exports.NodeCryptoRipemd160Digest = exports.Ripemd160PolyfillDigest = void 0;
const common_1 = require("@stacks/common");
const ripemd160_min_1 = __importDefault(require("ripemd160-min"));
class Ripemd160PolyfillDigest {
    digest(data) {
        const instance = new ripemd160_min_1.default();
        instance.update(data);
        const hash = instance.digest();
        if (Array.isArray(hash)) {
            return common_1.Buffer.from(hash);
        }
        else {
            return common_1.Buffer.from(hash.buffer);
        }
    }
}
exports.Ripemd160PolyfillDigest = Ripemd160PolyfillDigest;
class NodeCryptoRipemd160Digest {
    constructor(nodeCryptoCreateHash) {
        this.nodeCryptoCreateHash = nodeCryptoCreateHash;
    }
    digest(data) {
        try {
            return this.nodeCryptoCreateHash('rmd160').update(data).digest();
        }
        catch (error) {
            try {
                return this.nodeCryptoCreateHash('ripemd160').update(data).digest();
            }
            catch (_err) {
                console.log(error);
                console.log('Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation');
                const polyfill = new Ripemd160PolyfillDigest();
                return polyfill.digest(data);
            }
        }
    }
}
exports.NodeCryptoRipemd160Digest = NodeCryptoRipemd160Digest;
function createHashRipemd160() {
    return new Ripemd160PolyfillDigest();
}
exports.createHashRipemd160 = createHashRipemd160;
function hashRipemd160(data) {
    const hash = createHashRipemd160();
    return hash.digest(data);
}
exports.hashRipemd160 = hashRipemd160;
//# sourceMappingURL=hashRipemd160.js.map