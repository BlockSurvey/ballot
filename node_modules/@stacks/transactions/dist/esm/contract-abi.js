import { Buffer } from '@stacks/common';
import { cloneDeep } from './utils';
import { uintCV, intCV, contractPrincipalCV, standardPrincipalCV, noneCV, bufferCV, falseCV, trueCV, ClarityType, getCVTypeString, bufferCVFromString, } from './clarity';
import { NotImplementedError } from './errors';
import { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';
export var ClarityAbiTypeId;
(function (ClarityAbiTypeId) {
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeUInt128"] = 1] = "ClarityAbiTypeUInt128";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeInt128"] = 2] = "ClarityAbiTypeInt128";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeBool"] = 3] = "ClarityAbiTypeBool";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypePrincipal"] = 4] = "ClarityAbiTypePrincipal";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeNone"] = 5] = "ClarityAbiTypeNone";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeBuffer"] = 6] = "ClarityAbiTypeBuffer";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeResponse"] = 7] = "ClarityAbiTypeResponse";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeOptional"] = 8] = "ClarityAbiTypeOptional";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeTuple"] = 9] = "ClarityAbiTypeTuple";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeList"] = 10] = "ClarityAbiTypeList";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeStringAscii"] = 11] = "ClarityAbiTypeStringAscii";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeStringUtf8"] = 12] = "ClarityAbiTypeStringUtf8";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeTraitReference"] = 13] = "ClarityAbiTypeTraitReference";
})(ClarityAbiTypeId || (ClarityAbiTypeId = {}));
export const isClarityAbiPrimitive = (val) => typeof val === 'string';
export const isClarityAbiBuffer = (val) => val.buffer !== undefined;
export const isClarityAbiStringAscii = (val) => val['string-ascii'] !== undefined;
export const isClarityAbiStringUtf8 = (val) => val['string-utf8'] !== undefined;
export const isClarityAbiResponse = (val) => val.response !== undefined;
export const isClarityAbiOptional = (val) => val.optional !== undefined;
export const isClarityAbiTuple = (val) => val.tuple !== undefined;
export const isClarityAbiList = (val) => val.list !== undefined;
export function getTypeUnion(val) {
    if (isClarityAbiPrimitive(val)) {
        if (val === 'uint128') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };
        }
        else if (val === 'int128') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };
        }
        else if (val === 'bool') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };
        }
        else if (val === 'principal') {
            return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };
        }
        else if (val === 'trait_reference') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };
        }
        else if (val === 'none') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };
        }
        else {
            throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);
        }
    }
    else if (isClarityAbiBuffer(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };
    }
    else if (isClarityAbiResponse(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };
    }
    else if (isClarityAbiOptional(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };
    }
    else if (isClarityAbiTuple(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };
    }
    else if (isClarityAbiList(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };
    }
    else if (isClarityAbiStringAscii(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };
    }
    else if (isClarityAbiStringUtf8(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };
    }
    else {
        throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);
    }
}
function encodeClarityValue(input, val) {
    let union;
    if (input.id !== undefined) {
        union = input;
    }
    else {
        union = getTypeUnion(input);
    }
    switch (union.id) {
        case ClarityAbiTypeId.ClarityAbiTypeUInt128:
            return uintCV(val);
        case ClarityAbiTypeId.ClarityAbiTypeInt128:
            return intCV(val);
        case ClarityAbiTypeId.ClarityAbiTypeBool:
            if (val === 'false' || val === '0')
                return falseCV();
            else if (val === 'true' || val === '1')
                return trueCV();
            else
                throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);
        case ClarityAbiTypeId.ClarityAbiTypePrincipal:
            if (val.includes('.')) {
                const [addr, name] = val.split('.');
                return contractPrincipalCV(addr, name);
            }
            else {
                return standardPrincipalCV(val);
            }
        case ClarityAbiTypeId.ClarityAbiTypeTraitReference:
            const [addr, name] = val.split('.');
            return contractPrincipalCV(addr, name);
        case ClarityAbiTypeId.ClarityAbiTypeNone:
            return noneCV();
        case ClarityAbiTypeId.ClarityAbiTypeBuffer:
            return bufferCV(Buffer.from(val, 'utf8'));
        case ClarityAbiTypeId.ClarityAbiTypeStringAscii:
            return stringAsciiCV(val);
        case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:
            return stringUtf8CV(val);
        case ClarityAbiTypeId.ClarityAbiTypeResponse:
            throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        case ClarityAbiTypeId.ClarityAbiTypeOptional:
            throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        case ClarityAbiTypeId.ClarityAbiTypeTuple:
            throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        case ClarityAbiTypeId.ClarityAbiTypeList:
            throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        default:
            throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);
    }
}
export { encodeClarityValue };
export function getTypeString(val) {
    if (isClarityAbiPrimitive(val)) {
        if (val === 'int128') {
            return 'int';
        }
        else if (val === 'uint128') {
            return 'uint';
        }
        return val;
    }
    else if (isClarityAbiBuffer(val)) {
        return `(buff ${val.buffer.length})`;
    }
    else if (isClarityAbiStringAscii(val)) {
        return `(string-ascii ${val['string-ascii'].length})`;
    }
    else if (isClarityAbiStringUtf8(val)) {
        return `(string-utf8 ${val['string-utf8'].length})`;
    }
    else if (isClarityAbiResponse(val)) {
        return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;
    }
    else if (isClarityAbiOptional(val)) {
        return `(optional ${getTypeString(val.optional)})`;
    }
    else if (isClarityAbiTuple(val)) {
        return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;
    }
    else if (isClarityAbiList(val)) {
        return `(list ${val.list.length} ${getTypeString(val.list.type)})`;
    }
    else {
        throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);
    }
}
export function abiFunctionToString(func) {
    const access = func.access === 'read_only' ? 'read-only' : func.access;
    return `(define-${access} (${func.name} ${func.args
        .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)
        .join(' ')}))`;
}
function matchType(cv, abiType) {
    const union = getTypeUnion(abiType);
    switch (cv.type) {
        case ClarityType.BoolTrue:
        case ClarityType.BoolFalse:
            return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;
        case ClarityType.Int:
            return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;
        case ClarityType.UInt:
            return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;
        case ClarityType.Buffer:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&
                union.type.buffer.length >= cv.buffer.length);
        case ClarityType.StringASCII:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&
                union.type['string-ascii'].length >= cv.data.length);
        case ClarityType.StringUTF8:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&
                union.type['string-utf8'].length >= cv.data.length);
        case ClarityType.OptionalNone:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||
                union.id === ClarityAbiTypeId.ClarityAbiTypeOptional);
        case ClarityType.OptionalSome:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&
                matchType(cv.value, union.type.optional));
        case ClarityType.ResponseErr:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&
                matchType(cv.value, union.type.response.error));
        case ClarityType.ResponseOk:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&
                matchType(cv.value, union.type.response.ok));
        case ClarityType.PrincipalContract:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||
                union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference);
        case ClarityType.PrincipalStandard:
            return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;
        case ClarityType.List:
            return (union.id == ClarityAbiTypeId.ClarityAbiTypeList &&
                union.type.list.length >= cv.list.length &&
                cv.list.every(val => matchType(val, union.type.list.type)));
        case ClarityType.Tuple:
            if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {
                const tuple = cloneDeep(cv.data);
                for (let i = 0; i < union.type.tuple.length; i++) {
                    const abiTupleEntry = union.type.tuple[i];
                    const key = abiTupleEntry.name;
                    const val = tuple[key];
                    if (val) {
                        if (!matchType(val, abiTupleEntry.type)) {
                            return false;
                        }
                        delete tuple[key];
                    }
                    else {
                        return false;
                    }
                }
                return true;
            }
            else {
                return false;
            }
        default:
            return false;
    }
}
export function validateContractCall(payload, abi) {
    const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);
    if (filtered.length === 1) {
        const abiFunc = filtered[0];
        const abiArgs = abiFunc.args;
        if (payload.functionArgs.length !== abiArgs.length) {
            throw new Error(`Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`);
        }
        for (let i = 0; i < payload.functionArgs.length; i++) {
            const payloadArg = payload.functionArgs[i];
            const abiArg = abiArgs[i];
            if (!matchType(payloadArg, abiArg.type)) {
                const argNum = i + 1;
                throw new Error(`Clarity function \`${payload.functionName.content}\` expects argument ${argNum} to be of type ${getTypeString(abiArg.type)}, not ${getCVTypeString(payloadArg)}`);
            }
        }
        return true;
    }
    else if (filtered.length === 0) {
        throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);
    }
    else {
        throw new Error(`Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`);
    }
}
export function parseToCV(input, type) {
    const typeString = getTypeString(type);
    if (isClarityAbiPrimitive(type)) {
        if (type === 'uint128') {
            return uintCV(input);
        }
        else if (type === 'int128') {
            return intCV(input);
        }
        else if (type === 'bool') {
            if (input.toLowerCase() === 'true') {
                return trueCV();
            }
            else if (input.toLowerCase() === 'false') {
                return falseCV();
            }
            else {
                throw new Error(`Invalid bool value: ${input}`);
            }
        }
        else if (type === 'principal') {
            if (input.includes('.')) {
                const [address, contractName] = input.split('.');
                return contractPrincipalCV(address, contractName);
            }
            else {
                return standardPrincipalCV(input);
            }
        }
        else {
            throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
        }
    }
    else if (isClarityAbiBuffer(type)) {
        const inputLength = Buffer.from(input).byteLength;
        if (inputLength > type.buffer.length) {
            throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);
        }
        return bufferCVFromString(input);
    }
    else if (isClarityAbiResponse(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else if (isClarityAbiOptional(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else if (isClarityAbiTuple(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else if (isClarityAbiList(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
}
//# sourceMappingURL=contract-abi.js.map