"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeTransactionAuthField = exports.serializeMessageSignature = exports.deserializeTransactionAuthField = exports.createTransactionAuthField = exports.deserializeMessageSignature = exports.AuthFieldType = void 0;
const errors_1 = require("./errors");
const constants_1 = require("./constants");
const keys_1 = require("./keys");
const common_1 = require("./common");
const utils_1 = require("./utils");
var AuthFieldType;
(function (AuthFieldType) {
    AuthFieldType[AuthFieldType["PublicKeyCompressed"] = 0] = "PublicKeyCompressed";
    AuthFieldType[AuthFieldType["PublicKeyUncompressed"] = 1] = "PublicKeyUncompressed";
    AuthFieldType[AuthFieldType["SignatureCompressed"] = 2] = "SignatureCompressed";
    AuthFieldType[AuthFieldType["SignatureUncompressed"] = 3] = "SignatureUncompressed";
})(AuthFieldType = exports.AuthFieldType || (exports.AuthFieldType = {}));
function deserializeMessageSignature(bufferReader) {
    return (0, common_1.createMessageSignature)(bufferReader.readBuffer(constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));
}
exports.deserializeMessageSignature = deserializeMessageSignature;
function createTransactionAuthField(pubKeyEncoding, contents) {
    return {
        pubKeyEncoding,
        type: constants_1.StacksMessageType.TransactionAuthField,
        contents,
    };
}
exports.createTransactionAuthField = createTransactionAuthField;
function deserializeTransactionAuthField(bufferReader) {
    const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {
        throw new errors_1.DeserializationError(`Could not read ${n} as AuthFieldType`);
    });
    switch (authFieldType) {
        case AuthFieldType.PublicKeyCompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Compressed, (0, keys_1.deserializePublicKey)(bufferReader));
        case AuthFieldType.PublicKeyUncompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Uncompressed, (0, keys_1.deserializePublicKey)(bufferReader));
        case AuthFieldType.SignatureCompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));
        case AuthFieldType.SignatureUncompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));
        default:
            throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);
    }
}
exports.deserializeTransactionAuthField = deserializeTransactionAuthField;
function serializeMessageSignature(messageSignature) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendHexString(messageSignature.data);
    return bufferArray.concatBuffer();
}
exports.serializeMessageSignature = serializeMessageSignature;
function serializeTransactionAuthField(field) {
    const bufferArray = new utils_1.BufferArray();
    switch (field.contents.type) {
        case constants_1.StacksMessageType.PublicKey:
            if (field.pubKeyEncoding == constants_1.PubKeyEncoding.Compressed) {
                bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);
                bufferArray.push((0, keys_1.serializePublicKey)(field.contents));
            }
            else {
                bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);
                bufferArray.push((0, keys_1.serializePublicKey)((0, keys_1.compressPublicKey)(field.contents.data)));
            }
            break;
        case constants_1.StacksMessageType.MessageSignature:
            if (field.pubKeyEncoding == constants_1.PubKeyEncoding.Compressed) {
                bufferArray.appendByte(AuthFieldType.SignatureCompressed);
            }
            else {
                bufferArray.appendByte(AuthFieldType.SignatureUncompressed);
            }
            bufferArray.push(serializeMessageSignature(field.contents));
            break;
    }
    return bufferArray.concatBuffer();
}
exports.serializeTransactionAuthField = serializeTransactionAuthField;
//# sourceMappingURL=signature.js.map