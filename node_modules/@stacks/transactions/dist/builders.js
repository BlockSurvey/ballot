"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.estimateTransactionByteLength = exports.sponsorTransaction = exports.callReadOnlyFunction = exports.makeContractNonFungiblePostCondition = exports.makeStandardNonFungiblePostCondition = exports.makeContractFungiblePostCondition = exports.makeStandardFungiblePostCondition = exports.makeContractSTXPostCondition = exports.makeStandardSTXPostCondition = exports.makeContractCall = exports.makeUnsignedContractCall = exports.estimateContractFunctionCall = exports.makeUnsignedContractDeploy = exports.makeContractDeploy = exports.estimateContractDeploy = exports.makeSTXTokenTransfer = exports.makeUnsignedSTXTokenTransfer = exports.getAbi = exports.broadcastRawTransaction = exports.broadcastTransaction = exports.estimateTransaction = exports.estimateTransfer = exports.getNonce = void 0;
const common_1 = require("@stacks/common");
const network_1 = require("@stacks/network");
const c32check_1 = require("c32check");
const authorization_1 = require("./authorization");
const constants_1 = require("./constants");
const contract_abi_1 = require("./contract-abi");
const keys_1 = require("./keys");
const payload_1 = require("./payload");
const postcondition_1 = require("./postcondition");
const postcondition_types_1 = require("./postcondition-types");
const signer_1 = require("./signer");
const transaction_1 = require("./transaction");
const types_1 = require("./types");
const utils_1 = require("./utils");
async function getNonce(address, network) {
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : new network_1.StacksMainnet());
    const url = derivedNetwork.getAccountApiUrl(address);
    const response = await derivedNetwork.fetchFn(url);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const responseText = await response.text();
    const result = JSON.parse(responseText);
    return BigInt(result.nonce);
}
exports.getNonce = getNonce;
async function estimateTransfer(transaction, network) {
    if (transaction.payload.payloadType !== constants_1.PayloadType.TokenTransfer) {
        throw new Error(`Transaction fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.TokenTransfer]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
    }
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));
    const url = derivedNetwork.getTransferFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = BigInt(transaction.serialize().byteLength);
    const feeRate = BigInt(feeRateResult);
    return feeRate * txBytes;
}
exports.estimateTransfer = estimateTransfer;
async function estimateTransaction(transactionPayload, estimatedLen, network) {
    const options = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(Object.assign({ transaction_payload: (0, payload_1.serializePayload)(transactionPayload).toString('hex') }, (estimatedLen ? { estimated_len: estimatedLen } : {}))),
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : new network_1.StacksMainnet());
    const url = derivedNetwork.getTransactionFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, options);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const data = await response.json();
    return data.estimations;
}
exports.estimateTransaction = estimateTransaction;
async function broadcastTransaction(transaction, network, attachment) {
    const rawTx = transaction.serialize();
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));
    const url = derivedNetwork.getBroadcastApiUrl();
    return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);
}
exports.broadcastTransaction = broadcastTransaction;
async function broadcastRawTransaction(rawTx, url, attachment, fetchFn = (0, network_1.createFetchFn)()) {
    const options = {
        method: 'POST',
        headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },
        body: attachment
            ? JSON.stringify({
                tx: rawTx.toString('hex'),
                attachment: attachment.toString('hex'),
            })
            : rawTx,
    };
    const response = await fetchFn(url, options);
    if (!response.ok) {
        try {
            return (await response.json());
        }
        catch (e) {
            throw Error(`Failed to broadcast transaction: ${e.message}`);
        }
    }
    const text = await response.text();
    const txid = text.replace(/["]+/g, '');
    const isValidTxId = (0, utils_1.validateTxId)(txid);
    if (!isValidTxId) {
        throw new Error(text);
    }
    return {
        txid,
    };
}
exports.broadcastRawTransaction = broadcastRawTransaction;
async function getAbi(address, contractName, network) {
    const options = {
        method: 'GET',
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network);
    const url = derivedNetwork.getAbiApiUrl(address, contractName);
    const response = await derivedNetwork.fetchFn(url, options);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error fetching contract ABI for contract "${contractName}" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    return JSON.parse(await response.text());
}
exports.getAbi = getAbi;
function deriveNetwork(transaction) {
    switch (transaction.version) {
        case constants_1.TransactionVersion.Mainnet:
            return new network_1.StacksMainnet();
        case constants_1.TransactionVersion.Testnet:
            return new network_1.StacksTestnet();
    }
}
async function makeUnsignedSTXTokenTransfer(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        memo: '',
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = (0, payload_1.createTokenTransferPayload)(options.recipient, options.amount, options.memo);
    let authorization = null;
    let spendingCondition = null;
    if ('publicKey' in options) {
        spendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
    }
    else {
        spendingCondition = (0, authorization_1.createMultiSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
    }
    if (options.sponsored) {
        authorization = (0, authorization_1.createSponsoredAuth)(spendingCondition);
    }
    else {
        authorization = (0, authorization_1.createStandardAuth)(spendingCondition);
    }
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = (0, types_1.createLPList)(postConditions);
    const transaction = new transaction_1.StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const estimatedLen = estimateTransactionByteLength(transaction);
        const txFee = await estimateTransaction(payload, estimatedLen, options.network);
        transaction.setFee(txFee[1].fee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = options.network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = (0, c32check_1.c32address)(addressVersion, transaction.auth.spendingCondition.signer);
        const txNonce = await getNonce(senderAddress, options.network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
exports.makeUnsignedSTXTokenTransfer = makeUnsignedSTXTokenTransfer;
async function makeSTXTokenTransfer(txOptions) {
    if ('senderKey' in txOptions) {
        const publicKey = (0, keys_1.publicKeyToString)((0, keys_1.getPublicKey)((0, keys_1.createStacksPrivateKey)(txOptions.senderKey)));
        const options = (0, utils_1.omit)(txOptions, 'senderKey');
        const transaction = await makeUnsignedSTXTokenTransfer(Object.assign({ publicKey }, options));
        const privKey = (0, keys_1.createStacksPrivateKey)(txOptions.senderKey);
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
        return transaction;
    }
    else {
        const options = (0, utils_1.omit)(txOptions, 'signerKeys');
        const transaction = await makeUnsignedSTXTokenTransfer(options);
        const signer = new signer_1.TransactionSigner(transaction);
        let pubKeys = txOptions.publicKeys;
        for (const key of txOptions.signerKeys) {
            const pubKey = (0, keys_1.pubKeyfromPrivKey)(key);
            pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));
            signer.signOrigin((0, keys_1.createStacksPrivateKey)(key));
        }
        for (const key of pubKeys) {
            signer.appendOrigin((0, keys_1.publicKeyFromBuffer)(common_1.Buffer.from(key, 'hex')));
        }
        return transaction;
    }
}
exports.makeSTXTokenTransfer = makeSTXTokenTransfer;
async function estimateContractDeploy(transaction, network) {
    if (transaction.payload.payloadType !== constants_1.PayloadType.SmartContract) {
        throw new Error(`Contract deploy fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.SmartContract]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
    }
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));
    const url = derivedNetwork.getTransferFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = (0, common_1.intToBigInt)(transaction.serialize().byteLength, false);
    const feeRate = (0, common_1.intToBigInt)(feeRateResult, false);
    return feeRate * txBytes;
}
exports.estimateContractDeploy = estimateContractDeploy;
async function makeContractDeploy(txOptions) {
    const privKey = (0, keys_1.createStacksPrivateKey)(txOptions.senderKey);
    const stacksPublicKey = (0, keys_1.getPublicKey)(privKey);
    const publicKey = (0, keys_1.publicKeyToString)(stacksPublicKey);
    const unsignedTxOptions = Object.assign(Object.assign({}, txOptions), { publicKey });
    const transaction = await makeUnsignedContractDeploy(unsignedTxOptions);
    if (txOptions.senderKey) {
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
    }
    return transaction;
}
exports.makeContractDeploy = makeContractDeploy;
async function makeUnsignedContractDeploy(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = (0, payload_1.createSmartContractPayload)(options.contractName, options.codeBody);
    const addressHashMode = constants_1.AddressHashMode.SerializeP2PKH;
    const pubKey = (0, keys_1.createStacksPublicKey)(options.publicKey);
    let authorization = null;
    const spendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(addressHashMode, (0, keys_1.publicKeyToString)(pubKey), options.nonce, options.fee);
    if (options.sponsored) {
        authorization = (0, authorization_1.createSponsoredAuth)(spendingCondition);
    }
    else {
        authorization = (0, authorization_1.createStandardAuth)(spendingCondition);
    }
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = (0, types_1.createLPList)(postConditions);
    const transaction = new transaction_1.StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const estimatedLen = estimateTransactionByteLength(transaction);
        const txFee = await estimateTransaction(payload, estimatedLen, options.network);
        transaction.setFee(txFee[1].fee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = options.network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = (0, keys_1.publicKeyToAddress)(addressVersion, pubKey);
        const txNonce = await getNonce(senderAddress, options.network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
exports.makeUnsignedContractDeploy = makeUnsignedContractDeploy;
async function estimateContractFunctionCall(transaction, network) {
    if (transaction.payload.payloadType !== constants_1.PayloadType.ContractCall) {
        throw new Error(`Contract call fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.ContractCall]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
    }
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));
    const url = derivedNetwork.getTransferFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = (0, common_1.intToBigInt)(transaction.serialize().byteLength, false);
    const feeRate = (0, common_1.intToBigInt)(feeRateResult, false);
    return feeRate * txBytes;
}
exports.estimateContractFunctionCall = estimateContractFunctionCall;
async function makeUnsignedContractCall(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = (0, payload_1.createContractCallPayload)(options.contractAddress, options.contractName, options.functionName, options.functionArgs);
    if (options === null || options === void 0 ? void 0 : options.validateWithAbi) {
        let abi;
        if (typeof options.validateWithAbi === 'boolean') {
            if (options === null || options === void 0 ? void 0 : options.network) {
                abi = await getAbi(options.contractAddress, options.contractName, options.network);
            }
            else {
                throw new Error('Network option must be provided in order to validate with ABI');
            }
        }
        else {
            abi = options.validateWithAbi;
        }
        (0, contract_abi_1.validateContractCall)(payload, abi);
    }
    let spendingCondition = null;
    let authorization = null;
    if ('publicKey' in options) {
        spendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
    }
    else {
        spendingCondition = (0, authorization_1.createMultiSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
    }
    if (options.sponsored) {
        authorization = (0, authorization_1.createSponsoredAuth)(spendingCondition);
    }
    else {
        authorization = (0, authorization_1.createStandardAuth)(spendingCondition);
    }
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = (0, types_1.createLPList)(postConditions);
    const transaction = new transaction_1.StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const estimatedLen = estimateTransactionByteLength(transaction);
        const txFee = await estimateTransaction(payload, estimatedLen, network);
        transaction.setFee(txFee[1].fee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = (0, c32check_1.c32address)(addressVersion, transaction.auth.spendingCondition.signer);
        const txNonce = await getNonce(senderAddress, network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
exports.makeUnsignedContractCall = makeUnsignedContractCall;
async function makeContractCall(txOptions) {
    if ('senderKey' in txOptions) {
        const publicKey = (0, keys_1.publicKeyToString)((0, keys_1.getPublicKey)((0, keys_1.createStacksPrivateKey)(txOptions.senderKey)));
        const options = (0, utils_1.omit)(txOptions, 'senderKey');
        const transaction = await makeUnsignedContractCall(Object.assign({ publicKey }, options));
        const privKey = (0, keys_1.createStacksPrivateKey)(txOptions.senderKey);
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
        return transaction;
    }
    else {
        const options = (0, utils_1.omit)(txOptions, 'signerKeys');
        const transaction = await makeUnsignedContractCall(options);
        const signer = new signer_1.TransactionSigner(transaction);
        let pubKeys = txOptions.publicKeys;
        for (const key of txOptions.signerKeys) {
            const pubKey = (0, keys_1.pubKeyfromPrivKey)(key);
            pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));
            signer.signOrigin((0, keys_1.createStacksPrivateKey)(key));
        }
        for (const key of pubKeys) {
            signer.appendOrigin((0, keys_1.publicKeyFromBuffer)(common_1.Buffer.from(key, 'hex')));
        }
        return transaction;
    }
}
exports.makeContractCall = makeContractCall;
function makeStandardSTXPostCondition(address, conditionCode, amount) {
    return (0, postcondition_1.createSTXPostCondition)((0, postcondition_types_1.createStandardPrincipal)(address), conditionCode, amount);
}
exports.makeStandardSTXPostCondition = makeStandardSTXPostCondition;
function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {
    return (0, postcondition_1.createSTXPostCondition)((0, postcondition_types_1.createContractPrincipal)(address, contractName), conditionCode, amount);
}
exports.makeContractSTXPostCondition = makeContractSTXPostCondition;
function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {
    return (0, postcondition_1.createFungiblePostCondition)((0, postcondition_types_1.createStandardPrincipal)(address), conditionCode, amount, assetInfo);
}
exports.makeStandardFungiblePostCondition = makeStandardFungiblePostCondition;
function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {
    return (0, postcondition_1.createFungiblePostCondition)((0, postcondition_types_1.createContractPrincipal)(address, contractName), conditionCode, amount, assetInfo);
}
exports.makeContractFungiblePostCondition = makeContractFungiblePostCondition;
function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {
    return (0, postcondition_1.createNonFungiblePostCondition)((0, postcondition_types_1.createStandardPrincipal)(address), conditionCode, assetInfo, assetName);
}
exports.makeStandardNonFungiblePostCondition = makeStandardNonFungiblePostCondition;
function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {
    return (0, postcondition_1.createNonFungiblePostCondition)((0, postcondition_types_1.createContractPrincipal)(address, contractName), conditionCode, assetInfo, assetName);
}
exports.makeContractNonFungiblePostCondition = makeContractNonFungiblePostCondition;
async function callReadOnlyFunction(readOnlyFunctionOptions) {
    const defaultOptions = {
        network: new network_1.StacksMainnet(),
    };
    const options = Object.assign(defaultOptions, readOnlyFunctionOptions);
    const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);
    const args = functionArgs.map(arg => (0, utils_1.cvToHex)(arg));
    const body = JSON.stringify({
        sender: senderAddress,
        arguments: args,
    });
    const response = await network.fetchFn(url, {
        method: 'POST',
        body,
        headers: {
            'Content-Type': 'application/json',
        },
    });
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    return response.json().then(responseJson => (0, utils_1.parseReadOnlyResponse)(responseJson));
}
exports.callReadOnlyFunction = callReadOnlyFunction;
async function sponsorTransaction(sponsorOptions) {
    const defaultOptions = {
        fee: 0,
        sponsorNonce: 0,
        sponsorAddressHashmode: constants_1.AddressHashMode.SerializeP2PKH,
        network: sponsorOptions.transaction.version === constants_1.TransactionVersion.Mainnet
            ? new network_1.StacksMainnet()
            : new network_1.StacksTestnet(),
    };
    const options = Object.assign(defaultOptions, sponsorOptions);
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const sponsorPubKey = (0, keys_1.pubKeyfromPrivKey)(options.sponsorPrivateKey);
    if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {
        let txFee = 0;
        switch (options.transaction.payload.payloadType) {
            case constants_1.PayloadType.TokenTransfer:
            case constants_1.PayloadType.SmartContract:
            case constants_1.PayloadType.ContractCall:
                const estimatedLen = estimateTransactionByteLength(options.transaction);
                try {
                    txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]
                        .fee;
                }
                catch (e) {
                    throw e;
                }
                break;
            default:
                throw new Error(`Sponsored transactions not supported for transaction type ${constants_1.PayloadType[options.transaction.payload.payloadType]}`);
        }
        options.transaction.setFee(txFee);
        options.fee = txFee;
    }
    if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {
        const addressVersion = network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = (0, keys_1.publicKeyToAddress)(addressVersion, sponsorPubKey);
        const sponsorNonce = await getNonce(senderAddress, network);
        options.sponsorNonce = sponsorNonce;
    }
    const sponsorSpendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(options.sponsorAddressHashmode, (0, keys_1.publicKeyToString)(sponsorPubKey), options.sponsorNonce, options.fee);
    options.transaction.setSponsor(sponsorSpendingCondition);
    const privKey = (0, keys_1.createStacksPrivateKey)(options.sponsorPrivateKey);
    const signer = signer_1.TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);
    signer.signSponsor(privKey);
    return signer.transaction;
}
exports.sponsorTransaction = sponsorTransaction;
function estimateTransactionByteLength(transaction) {
    const hashMode = transaction.auth.spendingCondition.hashMode;
    const multiSigHashModes = [constants_1.AddressHashMode.SerializeP2SH, constants_1.AddressHashMode.SerializeP2WSH];
    if (multiSigHashModes.includes(hashMode)) {
        const multiSigSpendingCondition = transaction.auth
            .spendingCondition;
        const existingSignatures = multiSigSpendingCondition.fields.filter(field => field.contents.type === constants_1.StacksMessageType.MessageSignature).length;
        const totalSignatureLength = (multiSigSpendingCondition.signaturesRequired - existingSignatures) *
            (constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);
        return transaction.serialize().byteLength + totalSignatureLength;
    }
    else {
        return transaction.serialize().byteLength;
    }
}
exports.estimateTransactionByteLength = estimateTransactionByteLength;
//# sourceMappingURL=builders.js.map