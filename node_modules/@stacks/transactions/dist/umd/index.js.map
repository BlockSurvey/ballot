{"version":3,"file":"index.js","mappings":"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","sources":["webpack://StacksTransactions/webpack/universalModuleDefinition","webpack://StacksTransactions/webpack/runtime/create fake namespace object","webpack://StacksTransactions/../../node_modules/base64-js/index.js","webpack://StacksTransactions/../../node_modules/buffer/index.js","webpack://StacksTransactions/../../node_modules/c32check/lib/address.js","webpack://StacksTransactions/../../node_modules/c32check/lib/base58check.js","webpack://StacksTransactions/../../node_modules/c32check/lib/checksum.js","webpack://StacksTransactions/../../node_modules/c32check/lib/encoding.js","webpack://StacksTransactions/../../node_modules/c32check/lib/index.js","webpack://StacksTransactions/../../node_modules/c32check/node_modules/base-x/src/index.js","webpack://StacksTransactions/../../node_modules/c32check/node_modules/buffer/index.js","webpack://StacksTransactions/../../node_modules/cross-fetch/dist/browser-polyfill.js","webpack://StacksTransactions/../../node_modules/cross-sha256/index.js","webpack://StacksTransactions/../../node_modules/cross-sha256/node_modules/buffer/index.js","webpack://StacksTransactions/../../node_modules/ieee754/index.js","webpack://StacksTransactions/../../node_modules/lodash.clonedeep/index.js","webpack://StacksTransactions/../../node_modules/safe-buffer/index.js","webpack://StacksTransactions/../../node_modules/smart-buffer/build/smartbuffer.js","webpack://StacksTransactions/../../node_modules/smart-buffer/build/utils.js","webpack://StacksTransactions/webpack/bootstrap","webpack://StacksTransactions/webpack/runtime/compat get default export","webpack://StacksTransactions/webpack/runtime/define property getters","webpack://StacksTransactions/webpack/runtime/global","webpack://StacksTransactions/webpack/runtime/hasOwnProperty shorthand","webpack://StacksTransactions/webpack/runtime/make namespace object","webpack://StacksTransactions/webpack/runtime/node module decorator","webpack://StacksTransactions/../common/dist/esm/utils.js","webpack://StacksTransactions/./src/constants.ts","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/_assert.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/utils.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/cryptoBrowser.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/_sha2.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/ripemd160.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/sha256.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/_u64.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/sha512.js","webpack://StacksTransactions/../../node_modules/@noble/secp256k1/lib/esm/index.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/hmac.js","webpack://StacksTransactions/../common/dist/esm/signatures.js","webpack://StacksTransactions/../common/dist/esm/constants.js","webpack://StacksTransactions/./src/common.ts","webpack://StacksTransactions/./src/keys.ts","webpack://StacksTransactions/../common/dist/esm/keys.js","webpack://StacksTransactions/./src/postcondition-types.ts","webpack://StacksTransactions/./src/clarity/constants.ts","webpack://StacksTransactions/./src/clarity/types/intCV.ts","webpack://StacksTransactions/./src/clarity/types/bufferCV.ts","webpack://StacksTransactions/./src/clarity/types/booleanCV.ts","webpack://StacksTransactions/./src/clarity/types/principalCV.ts","webpack://StacksTransactions/./src/clarity/types/responseCV.ts","webpack://StacksTransactions/./src/clarity/types/optionalCV.ts","webpack://StacksTransactions/./src/clarity/types/listCV.ts","webpack://StacksTransactions/./src/clarity/types/tupleCV.ts","webpack://StacksTransactions/./src/bufferReader.ts","webpack://StacksTransactions/./src/errors.ts","webpack://StacksTransactions/./src/clarity/types/stringCV.ts","webpack://StacksTransactions/./src/clarity/deserialize.ts","webpack://StacksTransactions/./src/payload.ts","webpack://StacksTransactions/./src/signature.ts","webpack://StacksTransactions/./src/types.ts","webpack://StacksTransactions/./src/clarity/serialize.ts","webpack://StacksTransactions/./src/utils.ts","webpack://StacksTransactions/./src/authorization.ts","webpack://StacksTransactions/./src/transaction.ts","webpack://StacksTransactions/./src/postcondition.ts","webpack://StacksTransactions/./src/clarity/clarityValue.ts","webpack://StacksTransactions/../network/dist/esm/fetch.js","webpack://StacksTransactions/../network/dist/esm/network.js","webpack://StacksTransactions/./src/contract-abi.ts","webpack://StacksTransactions/./src/signer.ts","webpack://StacksTransactions/./src/builders.ts","webpack://StacksTransactions/./src/structuredDataSignature.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StacksTransactions\"] = factory();\n\telse\n\t\troot[\"StacksTransactions\"] = factory();\n})(this, () => {\nreturn ","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;\nvar checksum_1 = require(\"./checksum\");\nvar base58check = require(\"./base58check\");\nexports.versions = {\n    mainnet: {\n        p2pkh: 22,\n        p2sh: 20 // 'M'\n    },\n    testnet: {\n        p2pkh: 26,\n        p2sh: 21 // 'N'\n    }\n};\n// address conversion : bitcoin to stacks\nvar ADDR_BITCOIN_TO_STACKS = {};\nADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;\nADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh;\n// address conversion : stacks to bitcoin \nvar ADDR_STACKS_TO_BITCOIN = {};\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;\n/**\n * Make a c32check address with the given version and hash160\n * The only difference between a c32check string and c32 address\n * is that the letter 'S' is pre-pended.\n * @param {number} version - the address version number\n * @param {string} hash160hex - the hash160 to encode (must be a hash160)\n * @returns {string} the address\n */\nfunction c32address(version, hash160hex) {\n    if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {\n        throw new Error('Invalid argument: not a hash160 hex string');\n    }\n    var c32string = checksum_1.c32checkEncode(version, hash160hex);\n    return \"S\" + c32string;\n}\nexports.c32address = c32address;\n/**\n * Decode a c32 address into its version and hash160\n * @param {string} c32addr - the c32check-encoded address\n * @returns {[number, string]} a tuple with the version and hash160\n */\nfunction c32addressDecode(c32addr) {\n    if (c32addr.length <= 5) {\n        throw new Error('Invalid c32 address: invalid length');\n    }\n    if (c32addr[0] != 'S') {\n        throw new Error('Invalid c32 address: must start with \"S\"');\n    }\n    return checksum_1.c32checkDecode(c32addr.slice(1));\n}\nexports.c32addressDecode = c32addressDecode;\n/*\n * Convert a base58check address to a c32check address.\n * Try to convert the version number if one is not given.\n * @param {string} b58check - the base58check encoded address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the c32 address with the given version number (or the\n *   semantically-equivalent c32 version number, if not given)\n */\nfunction b58ToC32(b58check, version) {\n    if (version === void 0) { version = -1; }\n    var addrInfo = base58check.decode(b58check);\n    var hash160String = addrInfo.data.toString('hex');\n    var addrVersion = parseInt(addrInfo.prefix.toString('hex'), 16);\n    var stacksVersion;\n    if (version < 0) {\n        stacksVersion = addrVersion;\n        if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== undefined) {\n            stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];\n        }\n    }\n    else {\n        stacksVersion = version;\n    }\n    return c32address(stacksVersion, hash160String);\n}\nexports.b58ToC32 = b58ToC32;\n/*\n * Convert a c32check address to a base58check address.\n * @param {string} c32string - the c32check address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the base58 address with the given version number (or the\n *    semantically-equivalent bitcoin version number, if not given)\n */\nfunction c32ToB58(c32string, version) {\n    if (version === void 0) { version = -1; }\n    var addrInfo = c32addressDecode(c32string);\n    var stacksVersion = addrInfo[0];\n    var hash160String = addrInfo[1];\n    var bitcoinVersion;\n    if (version < 0) {\n        bitcoinVersion = stacksVersion;\n        if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== undefined) {\n            bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];\n        }\n    }\n    else {\n        bitcoinVersion = version;\n    }\n    var prefix = bitcoinVersion.toString(16);\n    if (prefix.length === 1) {\n        prefix = \"0\" + prefix;\n    }\n    return base58check.encode(hash160String, prefix);\n}\nexports.c32ToB58 = c32ToB58;\n","/*\n * From https://github.com/wzbg/base58check\n * @Author: zyc\n * @Date:   2016-09-11 23:36:05\n */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decode = exports.encode = void 0;\nvar buffer_1 = require(\"buffer/\");\nvar cross_sha256_1 = require(\"cross-sha256\");\nvar basex = require(\"base-x\");\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nfunction encode(data, prefix, encoding) {\n    if (prefix === void 0) { prefix = '00'; }\n    if (encoding === void 0) { encoding = 'hex'; }\n    if (typeof data === 'string') {\n        data = new buffer_1.Buffer(data, encoding);\n    }\n    if (!(data instanceof buffer_1.Buffer)) {\n        throw new TypeError('\"data\" argument must be an Array of Buffers');\n    }\n    if (!(prefix instanceof buffer_1.Buffer)) {\n        prefix = new buffer_1.Buffer(prefix, encoding);\n    }\n    var hash = buffer_1.Buffer.concat([prefix, data]);\n    hash = cross_sha256_1.hashSha256(hash);\n    hash = cross_sha256_1.hashSha256(hash);\n    hash = buffer_1.Buffer.concat([prefix, data, hash.slice(0, 4)]);\n    return basex(ALPHABET).encode(hash);\n}\nexports.encode = encode;\nfunction decode(string, encoding) {\n    var buffer = new buffer_1.Buffer(basex(ALPHABET).decode(string));\n    var prefix = buffer.slice(0, 1);\n    var data = buffer.slice(1, -4);\n    var hash = buffer_1.Buffer.concat([prefix, data]);\n    hash = cross_sha256_1.hashSha256(hash);\n    hash = cross_sha256_1.hashSha256(hash);\n    buffer.slice(-4).forEach(function (check, index) {\n        if (check !== hash[index]) {\n            throw new Error('Invalid checksum');\n        }\n    });\n    if (encoding) {\n        prefix = prefix.toString(encoding);\n        data = data.toString(encoding);\n    }\n    return { prefix: prefix, data: data };\n}\nexports.decode = decode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32checkDecode = exports.c32checkEncode = void 0;\nvar buffer_1 = require(\"buffer/\");\nvar encoding_1 = require(\"./encoding\");\nvar cross_sha256_1 = require(\"cross-sha256\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */\nfunction c32checksum(dataHex) {\n    var dataHash = cross_sha256_1.hashSha256(cross_sha256_1.hashSha256(buffer_1.Buffer.from(dataHex, 'hex')));\n    var checksum = dataHash.slice(0, 4).toString('hex');\n    return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */\nfunction c32checkEncode(version, data) {\n    if (version < 0 || version >= 32) {\n        throw new Error('Invalid version (must be between 0 and 31)');\n    }\n    if (!data.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Invalid data (not a hex string)');\n    }\n    data = data.toLowerCase();\n    if (data.length % 2 !== 0) {\n        data = \"0\" + data;\n    }\n    var versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = \"0\" + versionHex;\n    }\n    var checksumHex = c32checksum(\"\" + versionHex + data);\n    var c32str = encoding_1.c32encode(\"\" + data + checksumHex);\n    return \"\" + encoding_1.c32[version] + c32str;\n}\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */\nfunction c32checkDecode(c32data) {\n    c32data = encoding_1.c32normalize(c32data);\n    var dataHex = encoding_1.c32decode(c32data.slice(1));\n    var versionChar = c32data[0];\n    var version = encoding_1.c32.indexOf(versionChar);\n    var checksum = dataHex.slice(-8);\n    var versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = \"0\" + versionHex;\n    }\n    if (c32checksum(\"\" + versionHex + dataHex.substring(0, dataHex.length - 8)) !== checksum) {\n        throw new Error('Invalid c32check string: checksum mismatch');\n    }\n    return [version, dataHex.substring(0, dataHex.length - 8)];\n}\nexports.c32checkDecode = c32checkDecode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\nvar buffer_1 = require(\"buffer/\");\nexports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\nvar hex = '0123456789abcdef';\n/**\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\n * to be big-endian (and the resulting c32 string will be as well).\n * @param {string} inputHex - the input to encode\n * @param {number} minLength - the minimum length of the c32 string\n * @returns {string} the c32check-encoded representation of the data, as a string\n */\nfunction c32encode(inputHex, minLength) {\n    // must be hex\n    if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Not a hex-encoded string');\n    }\n    if ((inputHex.length) % 2 !== 0) {\n        inputHex = \"0\" + inputHex;\n    }\n    inputHex = inputHex.toLowerCase();\n    var res = [];\n    var carry = 0;\n    for (var i = inputHex.length - 1; i >= 0; i--) {\n        if (carry < 4) {\n            var currentCode = hex.indexOf(inputHex[i]) >> carry;\n            var nextCode = 0;\n            if (i !== 0) {\n                nextCode = hex.indexOf(inputHex[i - 1]);\n            }\n            // carry = 0, nextBits is 1, carry = 1, nextBits is 2\n            var nextBits = 1 + carry;\n            var nextLowBits = (nextCode % (1 << nextBits)) << (5 - nextBits);\n            var curC32Digit = exports.c32[currentCode + nextLowBits];\n            carry = nextBits;\n            res.unshift(curC32Digit);\n        }\n        else {\n            carry = 0;\n        }\n    }\n    var C32leadingZeros = 0;\n    for (var i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            C32leadingZeros++;\n        }\n    }\n    res = res.slice(C32leadingZeros);\n    var zeroPrefix = buffer_1.Buffer.from(inputHex, 'hex').toString().match(/^\\u0000*/);\n    var numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\n    for (var i = 0; i < numLeadingZeroBytesInHex; i++) {\n        res.unshift(exports.c32[0]);\n    }\n    if (minLength) {\n        var count = minLength - res.length;\n        for (var i = 0; i < count; i++) {\n            res.unshift(exports.c32[0]);\n        }\n    }\n    return res.join('');\n}\nexports.c32encode = c32encode;\n/*\n * Normalize a c32 string\n * @param {string} c32input - the c32-encoded input string\n * @returns {string} the canonical representation of the c32 input string\n */\nfunction c32normalize(c32input) {\n    // must be upper-case\n    // replace all O's with 0's\n    // replace all I's and L's with 1's\n    return c32input.toUpperCase()\n        .replace(/O/g, '0')\n        .replace(/L|I/g, '1');\n}\nexports.c32normalize = c32normalize;\n/*\n * Decode a c32 string back into a hex string.  Note that the c32 input\n * string is assumed to be big-endian (and the resulting hex string will\n * be as well).\n * @param {string} c32input - the c32-encoded input to decode\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\n * @returns {string} the hex-encoded representation of the data, as a string\n */\nfunction c32decode(c32input, minLength) {\n    c32input = c32normalize(c32input);\n    // must result in a c32 string\n    if (!c32input.match(\"^[\" + exports.c32 + \"]*$\")) {\n        throw new Error('Not a c32-encoded string');\n    }\n    var zeroPrefix = c32input.match(\"^\" + exports.c32[0] + \"*\");\n    var numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\n    var res = [];\n    var carry = 0;\n    var carryBits = 0;\n    for (var i = c32input.length - 1; i >= 0; i--) {\n        if (carryBits === 4) {\n            res.unshift(hex[carry]);\n            carryBits = 0;\n            carry = 0;\n        }\n        var currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\n        var currentValue = currentCode + carry;\n        var currentHexDigit = hex[currentValue % 16];\n        carryBits += 1;\n        carry = currentValue >> 4;\n        if (carry > 1 << carryBits) {\n            throw new Error('Panic error in decoding.');\n        }\n        res.unshift(currentHexDigit);\n    }\n    // one last carry\n    res.unshift(hex[carry]);\n    if (res.length % 2 === 1) {\n        res.unshift('0');\n    }\n    var hexLeadingZeros = 0;\n    for (var i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            hexLeadingZeros++;\n        }\n    }\n    res = res.slice(hexLeadingZeros - (hexLeadingZeros % 2));\n    var hexStr = res.join('');\n    for (var i = 0; i < numLeadingZeroBytes; i++) {\n        hexStr = \"00\" + hexStr;\n    }\n    if (minLength) {\n        var count = minLength * 2 - hexStr.length;\n        for (var i = 0; i < count; i += 2) {\n            hexStr = \"00\" + hexStr;\n        }\n    }\n    return hexStr;\n}\nexports.c32decode = c32decode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.b58ToC32 = exports.c32ToB58 = exports.versions = exports.c32normalize = exports.c32addressDecode = exports.c32address = exports.c32checkDecode = exports.c32checkEncode = exports.c32decode = exports.c32encode = void 0;\nvar encoding_1 = require(\"./encoding\");\nObject.defineProperty(exports, \"c32encode\", { enumerable: true, get: function () { return encoding_1.c32encode; } });\nObject.defineProperty(exports, \"c32decode\", { enumerable: true, get: function () { return encoding_1.c32decode; } });\nObject.defineProperty(exports, \"c32normalize\", { enumerable: true, get: function () { return encoding_1.c32normalize; } });\nvar checksum_1 = require(\"./checksum\");\nObject.defineProperty(exports, \"c32checkEncode\", { enumerable: true, get: function () { return checksum_1.c32checkEncode; } });\nObject.defineProperty(exports, \"c32checkDecode\", { enumerable: true, get: function () { return checksum_1.c32checkDecode; } });\nvar address_1 = require(\"./address\");\nObject.defineProperty(exports, \"c32address\", { enumerable: true, get: function () { return address_1.c32address; } });\nObject.defineProperty(exports, \"c32addressDecode\", { enumerable: true, get: function () { return address_1.c32addressDecode; } });\nObject.defineProperty(exports, \"c32ToB58\", { enumerable: true, get: function () { return address_1.c32ToB58; } });\nObject.defineProperty(exports, \"b58ToC32\", { enumerable: true, get: function () { return address_1.b58ToC32; } });\nObject.defineProperty(exports, \"versions\", { enumerable: true, get: function () { return address_1.versions; } });\n","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n","(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(typeof self !== 'undefined' ? self : this);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashSha256 = exports.sha256 = exports.sha256nodeCrypto = exports.sha256js = void 0;\nvar buffer_1 = require(\"buffer/\");\n/**\n * From https://github.com/crypto-browserify/sha.js/blob/master/sha256.js\n *\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\nvar sha256js = /** @class */ (function () {\n    function sha256js() {\n        this._blockSize = 64;\n        this._finalSize = 56;\n        this._len = 0;\n        this._w = new Array(64);\n        this._a = 0x6a09e667;\n        this._b = 0xbb67ae85;\n        this._c = 0x3c6ef372;\n        this._d = 0xa54ff53a;\n        this._e = 0x510e527f;\n        this._f = 0x9b05688c;\n        this._g = 0x1f83d9ab;\n        this._h = 0x5be0cd19;\n        this._block = buffer_1.Buffer.alloc(this._blockSize);\n    }\n    sha256js.prototype.update = function (data, encoding) {\n        if (typeof data === 'string') {\n            encoding = encoding || 'utf8';\n            data = buffer_1.Buffer.from(data, encoding);\n        }\n        var block = this._block;\n        var blockSize = this._blockSize;\n        var length = data.length;\n        var accum = this._len;\n        for (var offset = 0; offset < length;) {\n            var assigned = accum % blockSize;\n            var remainder = Math.min(length - offset, blockSize - assigned);\n            for (var i = 0; i < remainder; i++) {\n                block[assigned + i] = data[offset + i];\n            }\n            accum += remainder;\n            offset += remainder;\n            if ((accum % blockSize) === 0) {\n                this._update(block);\n            }\n        }\n        this._len += length;\n        return this;\n    };\n    sha256js.prototype.digest = function (encoding) {\n        var rem = this._len % this._blockSize;\n        this._block[rem] = 0x80;\n        // zero (rem + 1) trailing bits, where (rem + 1) is the smallest\n        // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize\n        this._block.fill(0, rem + 1);\n        if (rem >= this._finalSize) {\n            this._update(this._block);\n            this._block.fill(0);\n        }\n        var bits = this._len * 8;\n        // uint32\n        if (bits <= 0xffffffff) {\n            this._block.writeUInt32BE(bits, this._blockSize - 4);\n            // uint64\n        }\n        else {\n            var lowBits = (bits & 0xffffffff) >>> 0;\n            var highBits = (bits - lowBits) / 0x100000000;\n            this._block.writeUInt32BE(highBits, this._blockSize - 8);\n            this._block.writeUInt32BE(lowBits, this._blockSize - 4);\n        }\n        this._update(this._block);\n        var hash = buffer_1.Buffer.alloc(32);\n        hash.writeInt32BE(this._a, 0);\n        hash.writeInt32BE(this._b, 4);\n        hash.writeInt32BE(this._c, 8);\n        hash.writeInt32BE(this._d, 12);\n        hash.writeInt32BE(this._e, 16);\n        hash.writeInt32BE(this._f, 20);\n        hash.writeInt32BE(this._g, 24);\n        hash.writeInt32BE(this._h, 28);\n        return encoding ? hash.toString(encoding) : hash;\n    };\n    sha256js.prototype.ch = function (x, y, z) {\n        return z ^ (x & (y ^ z));\n    };\n    sha256js.prototype.maj = function (x, y, z) {\n        return (x & y) | (z & (x | y));\n    };\n    sha256js.prototype.sigma0 = function (x) {\n        return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);\n    };\n    sha256js.prototype.sigma1 = function (x) {\n        return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);\n    };\n    sha256js.prototype.gamma0 = function (x) {\n        return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3);\n    };\n    sha256js.prototype.gamma1 = function (x) {\n        return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10);\n    };\n    sha256js.prototype._update = function (M) {\n        var W = this._w;\n        var a = this._a | 0;\n        var b = this._b | 0;\n        var c = this._c | 0;\n        var d = this._d | 0;\n        var e = this._e | 0;\n        var f = this._f | 0;\n        var g = this._g | 0;\n        var h = this._h | 0;\n        var i = 0;\n        for (; i < 16; ++i)\n            W[i] = M.readInt32BE(i * 4);\n        for (; i < 64; ++i)\n            W[i] = (this.gamma1(W[i - 2]) + W[i - 7] + this.gamma0(W[i - 15]) + W[i - 16]) | 0;\n        for (var j = 0; j < 64; ++j) {\n            var T1 = (h + this.sigma1(e) + this.ch(e, f, g) + sha256js.K[j] + W[j]) | 0;\n            var T2 = (this.sigma0(a) + this.maj(a, b, c)) | 0;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) | 0;\n        }\n        this._a = (a + this._a) | 0;\n        this._b = (b + this._b) | 0;\n        this._c = (c + this._c) | 0;\n        this._d = (d + this._d) | 0;\n        this._e = (e + this._e) | 0;\n        this._f = (f + this._f) | 0;\n        this._g = (g + this._g) | 0;\n        this._h = (h + this._h) | 0;\n    };\n    sha256js.K = [\n        0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n        0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n        0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n        0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n        0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n        0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n        0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n        0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n        0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n        0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n        0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n        0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n        0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n        0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n        0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n        0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n    ];\n    return sha256js;\n}());\nexports.sha256js = sha256js;\nvar sha256nodeCrypto = /** @class */ (function () {\n    function sha256nodeCrypto() {\n        if (!sha256nodeCrypto.useCryptoModuleCache || sha256nodeCrypto.nodeCryptoCreateHash === undefined) {\n            sha256nodeCrypto.nodeCryptoCreateHash = require('crypto').createHash;\n        }\n        this.hash = sha256nodeCrypto.nodeCryptoCreateHash('sha256');\n    }\n    sha256nodeCrypto.prototype.update = function (data, encoding) {\n        this.hash.update(data, encoding);\n        return this;\n    };\n    sha256nodeCrypto.prototype.digest = function (encoding) {\n        if (encoding) {\n            return this.hash.digest(encoding);\n        }\n        else {\n            return this.hash.digest();\n        }\n    };\n    sha256nodeCrypto.useCryptoModuleCache = true;\n    return sha256nodeCrypto;\n}());\nexports.sha256nodeCrypto = sha256nodeCrypto;\nvar _nodeCryptoAvailable = undefined;\nfunction isNodeCryptoAvailable() {\n    if (sha256nodeCrypto.useCryptoModuleCache && _nodeCryptoAvailable !== undefined) {\n        return _nodeCryptoAvailable;\n    }\n    var isAvailable = false;\n    try {\n        if (typeof require === 'function') {\n            var cryptoModule = require('crypto');\n            isAvailable = cryptoModule && typeof cryptoModule.createHash === 'function';\n        }\n    }\n    catch (error) {\n        // ignore\n    }\n    _nodeCryptoAvailable = isAvailable;\n    return isAvailable;\n}\nvar sha256 = /** @class */ (function () {\n    function sha256() {\n        if (isNodeCryptoAvailable()) {\n            this.instance = new sha256nodeCrypto();\n        }\n        else {\n            this.instance = new sha256js();\n        }\n    }\n    sha256.prototype.update = function (data, encoding) {\n        this.instance.update(data, encoding);\n        return this;\n    };\n    sha256.prototype.digest = function (encoding) {\n        if (encoding) {\n            return this.instance.digest(encoding);\n        }\n        else {\n            return this.instance.digest();\n        }\n    };\n    return sha256;\n}());\nexports.sha256 = sha256;\n/**\n * Use Nodejs `crypto` module if available, otherwise uses js implementation.\n * @param data Input data to hash.\n */\nfunction hashSha256(data) {\n    return new sha256().update(data).digest();\n}\nexports.hashSha256 = hashSha256;\nexports.default = hashSha256;\n//# sourceMappingURL=index.js.map","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n// The default Buffer size if one is not provided.\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\n// The default string encoding to use for reading/writing strings.\nconst DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\nclass SmartBuffer {\n    /**\n     * Creates a new SmartBuffer instance.\n     *\n     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n     */\n    constructor(options) {\n        this.length = 0;\n        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        if (SmartBuffer.isSmartBufferOptions(options)) {\n            // Checks for encoding\n            if (options.encoding) {\n                utils_1.checkEncoding(options.encoding);\n                this._encoding = options.encoding;\n            }\n            // Checks for initial size length\n            if (options.size) {\n                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n                    this._buff = Buffer.allocUnsafe(options.size);\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n                }\n                // Check for initial Buffer\n            }\n            else if (options.buff) {\n                if (Buffer.isBuffer(options.buff)) {\n                    this._buff = options.buff;\n                    this.length = options.buff.length;\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n                }\n            }\n            else {\n                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n            }\n        }\n        else {\n            // If something was passed but it's not a SmartBufferOptions object\n            if (typeof options !== 'undefined') {\n                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n            }\n            // Otherwise default to sane options\n            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n        }\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n     *\n     * @param size { Number } The size of the internal Buffer.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromSize(size, encoding) {\n        return new this({\n            size: size,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n     *\n     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromBuffer(buff, encoding) {\n        return new this({\n            buff: buff,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n     *\n     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n     */\n    static fromOptions(options) {\n        return new this(options);\n    }\n    /**\n     * Type checking function that determines if an object is a SmartBufferOptions object.\n     */\n    static isSmartBufferOptions(options) {\n        const castOptions = options;\n        return (castOptions &&\n            (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined));\n    }\n    // Signed integers\n    /**\n     * Reads an Int8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n    }\n    /**\n     * Reads an Int16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n    }\n    /**\n     * Reads an Int16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n    }\n    /**\n     * Reads an Int32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n    }\n    /**\n     * Reads an Int32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigInt64BE');\n        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigInt64LE');\n        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\n    }\n    /**\n     * Writes an Int8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt8(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n        return this;\n    }\n    /**\n     * Inserts an Int8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n    }\n    /**\n     * Writes an Int16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an Int16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an Int32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an Int32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigInt64BE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a Int64LE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    // Unsigned Integers\n    /**\n     * Reads an UInt8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n    }\n    /**\n     * Reads an UInt16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n    }\n    /**\n     * Reads an UInt16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n    }\n    /**\n     * Reads an UInt32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n    }\n    /**\n     * Reads an UInt32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigUInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64BE');\n        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigUInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64LE');\n        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\n    }\n    /**\n     * Writes an UInt8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt8(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Inserts an UInt8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Writes an UInt16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an UInt32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigUInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigUInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    // Floating Point\n    /**\n     * Reads an FloatBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readFloatBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n    }\n    /**\n     * Reads an FloatLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readFloatLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n    }\n    /**\n     * Writes a FloatBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertFloatBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Writes a FloatLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertFloatLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    // Double Floating Point\n    /**\n     * Reads an DoublEBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readDoubleBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n    }\n    /**\n     * Reads an DoubleLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readDoubleLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n    }\n    /**\n     * Writes a DoubleBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertDoubleBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Writes a DoubleLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertDoubleLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    // Strings\n    /**\n     * Reads a String from the current read position.\n     *\n     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n     *             the string (Defaults to instance level encoding).\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readString(arg1, encoding) {\n        let lengthVal;\n        // Length provided\n        if (typeof arg1 === 'number') {\n            utils_1.checkLengthValue(arg1);\n            lengthVal = Math.min(arg1, this.length - this._readOffset);\n        }\n        else {\n            encoding = arg1;\n            lengthVal = this.length - this._readOffset;\n        }\n        // Check encoding\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n        this._readOffset += lengthVal;\n        return value;\n    }\n    /**\n     * Inserts a String\n     *\n     * @param value { String } The String value to insert.\n     * @param offset { Number } The offset to insert the string at.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    insertString(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleString(value, true, offset, encoding);\n    }\n    /**\n     * Writes a String\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    writeString(value, arg2, encoding) {\n        return this._handleString(value, false, arg2, encoding);\n    }\n    /**\n     * Reads a null-terminated String from the current read position.\n     *\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readStringNT(encoding) {\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read string value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value.toString(encoding || this._encoding);\n    }\n    /**\n     * Inserts a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    insertStringNT(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertString(value, offset, encoding);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    writeStringNT(value, arg2, encoding) {\n        // Write Values\n        this.writeString(value, arg2, encoding);\n        this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);\n        return this;\n    }\n    // Buffers\n    /**\n     * Reads a Buffer from the internal read position.\n     *\n     * @param length { Number } The length of data to read as a Buffer.\n     *\n     * @return { Buffer }\n     */\n    readBuffer(length) {\n        if (typeof length !== 'undefined') {\n            utils_1.checkLengthValue(length);\n        }\n        const lengthVal = typeof length === 'number' ? length : this.length;\n        const endPoint = Math.min(this.length, this._readOffset + lengthVal);\n        // Read buffer value\n        const value = this._buff.slice(this._readOffset, endPoint);\n        // Increment internal Buffer read offset\n        this._readOffset = endPoint;\n        return value;\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    insertBuffer(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleBuffer(value, true, offset);\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    writeBuffer(value, offset) {\n        return this._handleBuffer(value, false, offset);\n    }\n    /**\n     * Reads a null-terminated Buffer from the current read poisiton.\n     *\n     * @return { Buffer }\n     */\n    readBufferNT() {\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value;\n    }\n    /**\n     * Inserts a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    insertBufferNT(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertBuffer(value, offset);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    writeBufferNT(value, offset) {\n        // Checks for valid numberic value;\n        if (typeof offset !== 'undefined') {\n            utils_1.checkOffsetValue(offset);\n        }\n        // Write Values\n        this.writeBuffer(value, offset);\n        this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n        return this;\n    }\n    /**\n     * Clears the SmartBuffer instance to its original empty state.\n     */\n    clear() {\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        this.length = 0;\n        return this;\n    }\n    /**\n     * Gets the remaining data left to be read from the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    remaining() {\n        return this.length - this._readOffset;\n    }\n    /**\n     * Gets the current read offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    get readOffset() {\n        return this._readOffset;\n    }\n    /**\n     * Sets the read offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */\n    set readOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._readOffset = offset;\n    }\n    /**\n     * Gets the current write offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    get writeOffset() {\n        return this._writeOffset;\n    }\n    /**\n     * Sets the write offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */\n    set writeOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._writeOffset = offset;\n    }\n    /**\n     * Gets the currently set string encoding of the SmartBuffer instance.\n     *\n     * @return { BufferEncoding } The string Buffer encoding currently set.\n     */\n    get encoding() {\n        return this._encoding;\n    }\n    /**\n     * Sets the string encoding of the SmartBuffer instance.\n     *\n     * @param encoding { BufferEncoding } The string Buffer encoding to set.\n     */\n    set encoding(encoding) {\n        utils_1.checkEncoding(encoding);\n        this._encoding = encoding;\n    }\n    /**\n     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n     *\n     * @return { Buffer } The Buffer value.\n     */\n    get internalBuffer() {\n        return this._buff;\n    }\n    /**\n     * Gets the value of the internal managed Buffer (Includes managed data only)\n     *\n     * @param { Buffer }\n     */\n    toBuffer() {\n        return this._buff.slice(0, this.length);\n    }\n    /**\n     * Gets the String value of the internal managed Buffer\n     *\n     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n     */\n    toString(encoding) {\n        const encodingVal = typeof encoding === 'string' ? encoding : this._encoding;\n        // Check for invalid encoding.\n        utils_1.checkEncoding(encodingVal);\n        return this._buff.toString(encodingVal, 0, this.length);\n    }\n    /**\n     * Destroys the SmartBuffer instance.\n     */\n    destroy() {\n        this.clear();\n        return this;\n    }\n    /**\n     * Handles inserting and writing strings.\n     *\n     * @param value { String } The String value to insert.\n     * @param isInsert { Boolean } True if inserting a string, false if writing.\n     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     */\n    _handleString(value, isInsert, arg3, encoding) {\n        let offsetVal = this._writeOffset;\n        let encodingVal = this._encoding;\n        // Check for offset\n        if (typeof arg3 === 'number') {\n            offsetVal = arg3;\n            // Check for encoding\n        }\n        else if (typeof arg3 === 'string') {\n            utils_1.checkEncoding(arg3);\n            encodingVal = arg3;\n        }\n        // Check for encoding (third param)\n        if (typeof encoding === 'string') {\n            utils_1.checkEncoding(encoding);\n            encodingVal = encoding;\n        }\n        // Calculate bytelength of string.\n        const byteLength = Buffer.byteLength(value, encodingVal);\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(byteLength, offsetVal);\n        }\n        else {\n            this._ensureWriteable(byteLength, offsetVal);\n        }\n        // Write value\n        this._buff.write(value, offsetVal, byteLength, encodingVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += byteLength;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof arg3 === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += byteLength;\n            }\n        }\n        return this;\n    }\n    /**\n     * Handles writing or insert of a Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     */\n    _handleBuffer(value, isInsert, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(value.length, offsetVal);\n        }\n        else {\n            this._ensureWriteable(value.length, offsetVal);\n        }\n        // Write buffer value\n        value.copy(this._buff, offsetVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += value.length;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof offset === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += value.length;\n            }\n        }\n        return this;\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to read data.\n     *\n     * @param length { Number } The length of the data that needs to be read.\n     * @param offset { Number } The offset of the data that needs to be read.\n     */\n    ensureReadable(length, offset) {\n        // Offset value defaults to managed read offset.\n        let offsetVal = this._readOffset;\n        // If an offset was provided, use it.\n        if (typeof offset !== 'undefined') {\n            // Checks for valid numberic value;\n            utils_1.checkOffsetValue(offset);\n            // Overide with custom offset.\n            offsetVal = offset;\n        }\n        // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n        if (offsetVal < 0 || offsetVal + length > this.length) {\n            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to insert data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written.\n     */\n    ensureInsertable(dataLength, offset) {\n        // Checks for valid numberic value;\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity.\n        this._ensureCapacity(this.length + dataLength);\n        // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n        if (offset < this.length) {\n            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n        }\n        // Adjust tracked smart buffer length\n        if (offset + dataLength > this.length) {\n            this.length = offset + dataLength;\n        }\n        else {\n            this.length += dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n     */\n    _ensureWriteable(dataLength, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure enough capacity to write data.\n        this._ensureCapacity(offsetVal + dataLength);\n        // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n        if (offsetVal + dataLength > this.length) {\n            this.length = offsetVal + dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n     *\n     * @param minLength { Number } The minimum length of the data needs to be written.\n     */\n    _ensureCapacity(minLength) {\n        const oldLength = this._buff.length;\n        if (minLength > oldLength) {\n            let data = this._buff;\n            let newLength = (oldLength * 3) / 2 + 1;\n            if (newLength < minLength) {\n                newLength = minLength;\n            }\n            this._buff = Buffer.allocUnsafe(newLength);\n            data.copy(this._buff, 0, 0, oldLength);\n        }\n    }\n    /**\n     * Reads a numeric number value using the provided function.\n     *\n     * @typeparam T { number | bigint } The type of the value to be read\n     *\n     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes read.\n     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n     *\n     * @returns { T } the number value\n     */\n    _readNumberValue(func, byteSize, offset) {\n        this.ensureReadable(byteSize, offset);\n        // Call Buffer.readXXXX();\n        const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset);\n        // Adjust internal read offset if an optional read offset was not provided.\n        if (typeof offset === 'undefined') {\n            this._readOffset += byteSize;\n        }\n        return value;\n    }\n    /**\n     * Inserts a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */\n    _insertNumberValue(func, byteSize, value, offset) {\n        // Check for invalid offset values.\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this.ensureInsertable(byteSize, offset);\n        // Call buffer.writeXXXX();\n        func.call(this._buff, value, offset);\n        // Adjusts internally managed write offset.\n        this._writeOffset += byteSize;\n        return this;\n    }\n    /**\n     * Writes a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */\n    _writeNumberValue(func, byteSize, value, offset) {\n        // If an offset was provided, validate it.\n        if (typeof offset === 'number') {\n            // Check if we're writing beyond the bounds of the managed data.\n            if (offset < 0) {\n                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n            }\n            utils_1.checkOffsetValue(offset);\n        }\n        // Default to writeOffset if no offset value was given.\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this._ensureWriteable(byteSize, offsetVal);\n        func.call(this._buff, value, offsetVal);\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\n        if (typeof offset === 'number') {\n            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n        }\n        else {\n            // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n            this._writeOffset += byteSize;\n        }\n        return this;\n    }\n}\nexports.SmartBuffer = SmartBuffer;\n//# sourceMappingURL=smartbuffer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst buffer_1 = require(\"buffer\");\n/**\n * Error strings\n */\nconst ERRORS = {\n    INVALID_ENCODING: 'Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.',\n    INVALID_SMARTBUFFER_SIZE: 'Invalid size provided. Size must be a valid integer greater than zero.',\n    INVALID_SMARTBUFFER_BUFFER: 'Invalid Buffer provided in SmartBufferOptions.',\n    INVALID_SMARTBUFFER_OBJECT: 'Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.',\n    INVALID_OFFSET: 'An invalid offset value was provided.',\n    INVALID_OFFSET_NON_NUMBER: 'An invalid offset value was provided. A numeric value is required.',\n    INVALID_LENGTH: 'An invalid length value was provided.',\n    INVALID_LENGTH_NON_NUMBER: 'An invalid length value was provived. A numeric value is required.',\n    INVALID_TARGET_OFFSET: 'Target offset is beyond the bounds of the internal SmartBuffer data.',\n    INVALID_TARGET_LENGTH: 'Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.',\n    INVALID_READ_BEYOND_BOUNDS: 'Attempted to read beyond the bounds of the managed data.',\n    INVALID_WRITE_BEYOND_BOUNDS: 'Attempted to write beyond the bounds of the managed data.'\n};\nexports.ERRORS = ERRORS;\n/**\n * Checks if a given encoding is a valid Buffer encoding. (Throws an exception if check fails)\n *\n * @param { String } encoding The encoding string to check.\n */\nfunction checkEncoding(encoding) {\n    if (!buffer_1.Buffer.isEncoding(encoding)) {\n        throw new Error(ERRORS.INVALID_ENCODING);\n    }\n}\nexports.checkEncoding = checkEncoding;\n/**\n * Checks if a given number is a finite integer. (Throws an exception if check fails)\n *\n * @param { Number } value The number value to check.\n */\nfunction isFiniteInteger(value) {\n    return typeof value === 'number' && isFinite(value) && isInteger(value);\n}\nexports.isFiniteInteger = isFiniteInteger;\n/**\n * Checks if an offset/length value is valid. (Throws an exception if check fails)\n *\n * @param value The value to check.\n * @param offset True if checking an offset, false if checking a length.\n */\nfunction checkOffsetOrLengthValue(value, offset) {\n    if (typeof value === 'number') {\n        // Check for non finite/non integers\n        if (!isFiniteInteger(value) || value < 0) {\n            throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);\n        }\n    }\n    else {\n        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);\n    }\n}\n/**\n * Checks if a length value is valid. (Throws an exception if check fails)\n *\n * @param { Number } length The value to check.\n */\nfunction checkLengthValue(length) {\n    checkOffsetOrLengthValue(length, false);\n}\nexports.checkLengthValue = checkLengthValue;\n/**\n * Checks if a offset value is valid. (Throws an exception if check fails)\n *\n * @param { Number } offset The value to check.\n */\nfunction checkOffsetValue(offset) {\n    checkOffsetOrLengthValue(offset, true);\n}\nexports.checkOffsetValue = checkOffsetValue;\n/**\n * Checks if a target offset value is out of bounds. (Throws an exception if check fails)\n *\n * @param { Number } offset The offset value to check.\n * @param { SmartBuffer } buff The SmartBuffer instance to check against.\n */\nfunction checkTargetOffset(offset, buff) {\n    if (offset < 0 || offset > buff.length) {\n        throw new Error(ERRORS.INVALID_TARGET_OFFSET);\n    }\n}\nexports.checkTargetOffset = checkTargetOffset;\n/**\n * Determines whether a given number is a integer.\n * @param value The number to check.\n */\nfunction isInteger(value) {\n    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\n/**\n * Throws if Node.js version is too low to support bigint\n */\nfunction bigIntAndBufferInt64Check(bufferMethod) {\n    if (typeof BigInt === 'undefined') {\n        throw new Error('Platform does not support JS BigInt type.');\n    }\n    if (typeof buffer_1.Buffer.prototype[bufferMethod] === 'undefined') {\n        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);\n    }\n}\nexports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;\n//# sourceMappingURL=utils.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","import { Logger } from './logger';\nimport { Buffer as BufferPolyfill } from 'buffer/';\nconst AvailableBufferModule = typeof Buffer !== 'undefined' ? Buffer : BufferPolyfill;\nexport { AvailableBufferModule as Buffer };\nexport const BLOCKSTACK_HANDLER = 'blockstack';\nexport function nextYear() {\n    return new Date(new Date().setFullYear(new Date().getFullYear() + 1));\n}\nexport function nextMonth() {\n    return new Date(new Date().setMonth(new Date().getMonth() + 1));\n}\nexport function nextHour() {\n    return new Date(new Date().setHours(new Date().getHours() + 1));\n}\nexport function megabytesToBytes(megabytes) {\n    if (!Number.isFinite(megabytes)) {\n        return 0;\n    }\n    return Math.floor(megabytes * 1024 * 1024);\n}\nexport function getAesCbcOutputLength(inputByteLength) {\n    const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;\n    return cipherTextLength;\n}\nexport function getBase64OutputLength(inputByteLength) {\n    const encodedLength = Math.ceil(inputByteLength / 3) * 4;\n    return encodedLength;\n}\nexport function updateQueryStringParameter(uri, key, value) {\n    const re = new RegExp(`([?&])${key}=.*?(&|$)`, 'i');\n    const separator = uri.indexOf('?') !== -1 ? '&' : '?';\n    if (uri.match(re)) {\n        return uri.replace(re, `$1${key}=${value}$2`);\n    }\n    else {\n        return `${uri}${separator}${key}=${value}`;\n    }\n}\nexport function isLaterVersion(v1, v2) {\n    if (v1 === undefined || v1 === '') {\n        v1 = '0.0.0';\n    }\n    if (v2 === undefined || v1 === '') {\n        v2 = '0.0.0';\n    }\n    const v1tuple = v1.split('.').map(x => parseInt(x, 10));\n    const v2tuple = v2.split('.').map(x => parseInt(x, 10));\n    for (let index = 0; index < v2.length; index++) {\n        if (index >= v1.length) {\n            v2tuple.push(0);\n        }\n        if (v1tuple[index] < v2tuple[index]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function makeUUID4() {\n    let d = new Date().getTime();\n    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n        d += performance.now();\n    }\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);\n    });\n}\nexport function isSameOriginAbsoluteUrl(uri1, uri2) {\n    try {\n        const parsedUri1 = new URL(uri1);\n        const parsedUri2 = new URL(uri2);\n        const port1 = parseInt(parsedUri1.port || '0', 10) | 0 || (parsedUri1.protocol === 'https:' ? 443 : 80);\n        const port2 = parseInt(parsedUri2.port || '0', 10) | 0 || (parsedUri2.protocol === 'https:' ? 443 : 80);\n        const match = {\n            scheme: parsedUri1.protocol === parsedUri2.protocol,\n            hostname: parsedUri1.hostname === parsedUri2.hostname,\n            port: port1 === port2,\n            absolute: (uri1.includes('http://') || uri1.includes('https://')) &&\n                (uri2.includes('http://') || uri2.includes('https://')),\n        };\n        return match.scheme && match.hostname && match.port && match.absolute;\n    }\n    catch (error) {\n        console.log(error);\n        console.log('Parsing error in same URL origin check');\n        return false;\n    }\n}\nexport function getGlobalScope() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available');\n}\nfunction getAPIUsageErrorMessage(scopeObject, apiName, usageDesc) {\n    if (usageDesc) {\n        return `Use of '${usageDesc}' requires \\`${apiName}\\` which is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n    }\n    else {\n        return `\\`${apiName}\\` is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n    }\n}\nexport function getGlobalObject(name, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {\n    let globalScope = undefined;\n    try {\n        globalScope = getGlobalScope();\n        if (globalScope) {\n            const obj = globalScope[name];\n            if (obj) {\n                return obj;\n            }\n        }\n    }\n    catch (error) {\n        Logger.error(`Error getting object '${name}' from global scope '${globalScope}': ${error}`);\n    }\n    if (throwIfUnavailable) {\n        const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n        Logger.error(errMsg);\n        throw new Error(errMsg);\n    }\n    if (returnEmptyObject) {\n        return {};\n    }\n    return undefined;\n}\nexport function getGlobalObjects(names, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {\n    let globalScope;\n    try {\n        globalScope = getGlobalScope();\n    }\n    catch (error) {\n        Logger.error(`Error getting global scope: ${error}`);\n        if (throwIfUnavailable) {\n            const errMsg = getAPIUsageErrorMessage(globalScope, names[0].toString(), usageDesc);\n            Logger.error(errMsg);\n            throw errMsg;\n        }\n        else if (returnEmptyObject) {\n            globalScope = {};\n        }\n    }\n    const result = {};\n    for (let i = 0; i < names.length; i++) {\n        const name = names[i];\n        try {\n            if (globalScope) {\n                const obj = globalScope[name];\n                if (obj) {\n                    result[name] = obj;\n                }\n                else if (throwIfUnavailable) {\n                    const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n                    Logger.error(errMsg);\n                    throw new Error(errMsg);\n                }\n                else if (returnEmptyObject) {\n                    result[name] = {};\n                }\n            }\n        }\n        catch (error) {\n            if (throwIfUnavailable) {\n                const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n                Logger.error(errMsg);\n                throw new Error(errMsg);\n            }\n        }\n    }\n    return result;\n}\nexport function intToBytes(value, signed, byteLength) {\n    return toBuffer(intToBigInt(value, signed), byteLength);\n}\nexport function intToBigInt(value, signed) {\n    let parsedValue = value;\n    if (typeof parsedValue === 'number') {\n        if (!Number.isInteger(parsedValue)) {\n            throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);\n        }\n        return BigInt(parsedValue);\n    }\n    if (typeof parsedValue === 'string') {\n        if (parsedValue.toLowerCase().startsWith('0x')) {\n            let hex = parsedValue.slice(2);\n            hex = hex.padStart(hex.length + (hex.length % 2), '0');\n            parsedValue = AvailableBufferModule.from(hex, 'hex');\n        }\n        else {\n            try {\n                return BigInt(parsedValue);\n            }\n            catch (error) {\n                if (error instanceof SyntaxError) {\n                    throw new RangeError(`Invalid value. String integer '${parsedValue}' is not finite.`);\n                }\n            }\n        }\n    }\n    if (typeof parsedValue === 'bigint') {\n        return parsedValue;\n    }\n    if (parsedValue instanceof Uint8Array || AvailableBufferModule.isBuffer(parsedValue)) {\n        if (signed) {\n            const bn = fromTwos(BigInt(`0x${bytesToHex(parsedValue)}`), BigInt(parsedValue.byteLength * 8));\n            return BigInt(bn.toString());\n        }\n        else {\n            return BigInt(`0x${bytesToHex(parsedValue)}`);\n        }\n    }\n    if (parsedValue != null &&\n        typeof parsedValue === 'object' &&\n        parsedValue.constructor.name === 'BN') {\n        return BigInt(parsedValue.toString());\n    }\n    throw new TypeError(`Invalid value type. Must be a number, bigint, integer-string, hex-string, or Buffer.`);\n}\nexport function with0x(value) {\n    return !value.startsWith('0x') ? `0x${value}` : value;\n}\nexport function hexToBigInt(hex) {\n    if (typeof hex !== 'string')\n        throw new TypeError(`hexToBigInt: expected string, got ${typeof hex}`);\n    return BigInt(`0x${hex}`);\n}\nexport function intToHex(integer, lengthBytes = 8) {\n    const value = typeof integer === 'bigint' ? integer : intToBigInt(integer, false);\n    return value.toString(16).padStart(lengthBytes * 2, '0');\n}\nexport function hexToInt(hex) {\n    return parseInt(hex, 16);\n}\nexport function toBuffer(value, length = 16) {\n    const hex = intToHex(value, length);\n    return AvailableBufferModule.from(hexToBytes(hex));\n}\nexport function toTwos(value, width) {\n    if (value < -(BigInt(1) << (width - BigInt(1))) ||\n        (BigInt(1) << (width - BigInt(1))) - BigInt(1) < value) {\n        throw `Unable to represent integer in width: ${width}`;\n    }\n    if (value >= BigInt(0)) {\n        return BigInt(value);\n    }\n    return value + (BigInt(1) << width);\n}\nfunction nthBit(value, n) {\n    return value & (BigInt(1) << n);\n}\nexport function fromTwos(value, width) {\n    if (nthBit(value, width - BigInt(1))) {\n        return value - (BigInt(1) << width);\n    }\n    return value;\n}\nconst hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\nexport function bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (const u of uint8a) {\n        hex += hexes[u];\n    }\n    return hex;\n}\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\nexport function concatBytes(...arrays) {\n    if (!arrays.every(a => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\n//# sourceMappingURL=utils.js.map","/**\n * Unsigned 32-bit integer\n */\nenum ChainID {\n  Testnet = 0x80000000,\n  Mainnet = 0x00000001,\n}\n\nconst DEFAULT_CHAIN_ID = ChainID.Mainnet;\nconst MAX_STRING_LENGTH_BYTES = 128;\nconst CLARITY_INT_SIZE = 128;\nconst CLARITY_INT_BYTE_SIZE = 16;\nconst COINBASE_BUFFER_LENGTH_BYTES = 32;\nconst RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;\nconst COMPRESSED_PUBKEY_LENGTH_BYTES = 32;\nconst UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;\nconst MEMO_MAX_LENGTH_BYTES = 34;\nconst DEFAULT_CORE_NODE_API_URL = 'https://stacks-node-api.mainnet.stacks.co';\n\nenum StacksMessageType {\n  Address,\n  Principal,\n  LengthPrefixedString,\n  MemoString,\n  AssetInfo,\n  PostCondition,\n  PublicKey,\n  LengthPrefixedList,\n  Payload,\n  MessageSignature,\n  StructuredDataSignature,\n  TransactionAuthField,\n}\n\nenum PayloadType {\n  TokenTransfer = 0x00,\n  SmartContract = 0x01,\n  ContractCall = 0x02,\n  PoisonMicroblock = 0x03,\n  Coinbase = 0x04,\n}\n\n/**\n * How a transaction should get appended to the Stacks blockchain.\n *\n * In the Stacks blockchain, there are two kinds of blocks: anchored\n * blocks and streaming microblocks. A transactions AnchorMode specifies\n * which kind of block it should be included in.\n *\n * For more information about the kinds of Stacks blocks and the various\n * AnchorModes, check out {@link https://github.com/stacksgov/sips/blob/main/sips/sip-001/sip-001-burn-election.md SIP 001} and\n * {@link https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md SIP 005}\n */\nenum AnchorMode {\n  /** The transaction MUST be included in an anchored block */\n  OnChainOnly = 0x01,\n  /** The transaction MUST be included in a microblock */\n  OffChainOnly = 0x02,\n  /** The leader can choose where to include the transaction (anchored block or microblock)*/\n  Any = 0x03,\n}\n\nenum TransactionVersion {\n  Mainnet = 0x00,\n  Testnet = 0x80,\n}\n\nconst DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;\n\nenum PostConditionMode {\n  Allow = 0x01,\n  Deny = 0x02,\n}\n\nenum PostConditionType {\n  STX = 0x00,\n  Fungible = 0x01,\n  NonFungible = 0x02,\n}\n\nenum AuthType {\n  Standard = 0x04,\n  Sponsored = 0x05,\n}\n\nenum AddressHashMode {\n  // serialization modes for public keys to addresses.\n  // We support four different modes due to legacy compatibility with Stacks v1 addresses:\n  /** SingleSigHashMode - hash160(public-key), same as bitcoin's p2pkh */\n  SerializeP2PKH = 0x00,\n  /** MultiSigHashMode - hash160(multisig-redeem-script), same as bitcoin's multisig p2sh */\n  SerializeP2SH = 0x01,\n  /** SingleSigHashMode - hash160(segwit-program-00(p2pkh)), same as bitcoin's p2sh-p2wpkh */\n  SerializeP2WPKH = 0x02,\n  /** MultiSigHashMode - hash160(segwit-program-00(public-keys)), same as bitcoin's p2sh-p2wsh */\n  SerializeP2WSH = 0x03,\n}\n\ntype SingleSigHashMode = AddressHashMode.SerializeP2PKH | AddressHashMode.SerializeP2WPKH;\ntype MultiSigHashMode = AddressHashMode.SerializeP2SH | AddressHashMode.SerializeP2WSH;\n\nenum AddressVersion {\n  MainnetSingleSig = 22,\n  MainnetMultiSig = 20,\n  TestnetSingleSig = 26,\n  TestnetMultiSig = 21,\n}\n\nenum PubKeyEncoding {\n  Compressed = 0x00,\n  Uncompressed = 0x01,\n}\n\nenum FungibleConditionCode {\n  Equal = 0x01,\n  Greater = 0x02,\n  GreaterEqual = 0x03,\n  Less = 0x04,\n  LessEqual = 0x05,\n}\n\nenum NonFungibleConditionCode {\n  DoesNotOwn = 0x10,\n  Owns = 0x11,\n}\n\nenum PostConditionPrincipalID {\n  Origin = 0x01,\n  Standard = 0x02,\n  Contract = 0x03,\n}\n\nenum AssetType {\n  STX = 0x00,\n  Fungible = 0x01,\n  NonFungible = 0x02,\n}\n\nenum TxRejectedReason {\n  Serialization = 'Serialization',\n  Deserialization = 'Deserialization',\n  SignatureValidation = 'SignatureValidation',\n  FeeTooLow = 'FeeTooLow',\n  BadNonce = 'BadNonce',\n  NotEnoughFunds = 'NotEnoughFunds',\n  NoSuchContract = 'NoSuchContract',\n  NoSuchPublicFunction = 'NoSuchPublicFunction',\n  BadFunctionArgument = 'BadFunctionArgument',\n  ContractAlreadyExists = 'ContractAlreadyExists',\n  PoisonMicroblocksDoNotConflict = 'PoisonMicroblocksDoNotConflict',\n  PoisonMicroblockHasUnknownPubKeyHash = 'PoisonMicroblockHasUnknownPubKeyHash',\n  PoisonMicroblockIsInvalid = 'PoisonMicroblockIsInvalid',\n  BadAddressVersionByte = 'BadAddressVersionByte',\n  NoCoinbaseViaMempool = 'NoCoinbaseViaMempool',\n  ServerFailureNoSuchChainTip = 'ServerFailureNoSuchChainTip',\n  ServerFailureDatabase = 'ServerFailureDatabase',\n  ServerFailureOther = 'ServerFailureOther',\n}\n\nexport {\n  MAX_STRING_LENGTH_BYTES,\n  CLARITY_INT_SIZE,\n  CLARITY_INT_BYTE_SIZE,\n  COINBASE_BUFFER_LENGTH_BYTES,\n  DEFAULT_CHAIN_ID,\n  DEFAULT_TRANSACTION_VERSION,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n  MEMO_MAX_LENGTH_BYTES,\n  DEFAULT_CORE_NODE_API_URL,\n  ChainID,\n  StacksMessageType,\n  PayloadType,\n  AnchorMode,\n  TransactionVersion,\n  PostConditionMode,\n  PostConditionType,\n  PostConditionPrincipalID,\n  AuthType,\n  AddressHashMode,\n  SingleSigHashMode,\n  MultiSigHashMode,\n  AddressVersion,\n  PubKeyEncoding,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  AssetType,\n  TxRejectedReason,\n};\n","export function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexport function bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nexport function bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new TypeError('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexport function hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexport function exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexport function output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\nexport default assert;\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nimport { crypto } from '@noble/hashes/crypto';\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nexport function bytesToHex(uint8a) {\n    // pre-caching improves the speed 6x\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('deadbeef')\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nexport function concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new TypeError('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto.web) {\n        return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    }\n    else if (crypto.node) {\n        return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);\n    }\n    else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\n","export const crypto = {\n    node: undefined,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\n","import assert from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        assert.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        assert.exists(this);\n        assert.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n","import { SHA2 } from './_sha2.js';\nimport { wrapConstructor } from './utils.js';\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);\nconst Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = new Uint32Array(16);\nexport class RIPEMD160 extends SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = wrapConstructor(() => new RIPEMD160());\n","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = wrapConstructor(() => new SHA256());\n","const U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nexport function fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nexport function split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nexport const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l) => l;\nconst rotr32L = (h, l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nexport function add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n)));\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = new Uint32Array(80);\nconst SHA512_W_L = new Uint32Array(80);\nexport class SHA512 extends SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = wrapConstructor(() => new SHA512());\nexport const sha512_256 = wrapConstructor(() => new SHA512_256());\nexport const sha384 = wrapConstructor(() => new SHA384());\n","/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst POW_2_256 = _2n ** BigInt(256);\nconst CURVE = {\n    a: _0n,\n    b: BigInt(7),\n    P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),\n    n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n};\nexport { CURVE };\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 ** _2n);\n        const Z2Z2 = mod(Z2 ** _2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 ** _2n);\n        const B = mod(Y1 ** _2n);\n        const C = mod(B ** _2n);\n        const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E ** _2n);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 ** _2n);\n        const Z2Z2 = mod(Z2 ** _2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H ** _2n);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r ** _2n - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weistrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, 33));\n        const y = bytesToNumber(bytes.subarray(33, 65));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === 65 && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        msgHash = ensureBytes(msgHash);\n        const h = truncateHash(msgHash);\n        const { r, s } = normalizeSignature(signature);\n        if (recovery !== 0 && recovery !== 1) {\n            throw new Error('Cannot recover signature: invalid recovery bit');\n        }\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(r));\n        const { n } = CURVE;\n        const rinv = invert(r, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.y & _1n ? '03' : '02';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weistrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = isUint8a(hex);\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = isUint8a(hex);\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\n    }\n    toDERRawBytes(isCompressed = false) {\n        return hexToBytes(this.toDERHex(isCompressed));\n    }\n    toDERHex(isCompressed = false) {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const rLen = numberToHexUnpadded(rHex.length / 2);\n        const sLen = numberToHexUnpadded(sHex.length / 2);\n        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every(isUint8a))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction isUint8a(bytes) {\n    return bytes instanceof Uint8Array;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction numTo32bStr(num) {\n    if (num > POW_2_256)\n        throw new Error('Expected number < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    return hexToBytes(numTo32bStr(num));\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    return pow2(t2, _2n);\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst POW_2_128 = _2n ** BigInt(128);\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n    const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n    const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n    const b2 = a1;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg)\n        k1 = n - k1;\n    if (k2neg)\n        k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction truncateHash(hash) {\n    const { n } = CURVE;\n    const byteLength = hash.length;\n    const delta = byteLength * 8 - 256;\n    let h = bytesToNumber(hash);\n    if (delta > 0)\n        h = h >> BigInt(delta);\n    if (h >= n)\n        h -= n;\n    return h;\n}\nclass HmacDrbg {\n    constructor() {\n        this.v = new Uint8Array(32).fill(1);\n        this.k = new Uint8Array(32).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        if (typeof utils.hmacSha256Sync !== 'function')\n            throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n        const res = utils.hmacSha256Sync(this.k, ...values);\n        if (res instanceof Promise)\n            throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n        return res;\n    }\n    incr() {\n        if (this.counter >= 1000) {\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        }\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        this.v = await this.hmac(this.v);\n        return this.v;\n    }\n    generateSync() {\n        this.incr();\n        this.v = this.hmacSync(this.v);\n        return this.v;\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n    const k = bytesToNumber(kBytes);\n    if (!isWithinCurveOrder(k))\n        return;\n    const { n } = CURVE;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(invert(k, n) * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    const sig = new Signature(r, s);\n    const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 64)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (isUint8a(key)) {\n        if (key.length !== 32)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isPub(item) {\n    const arr = isUint8a(item);\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    const hex = numTo32bStr(num);\n    return hexToBytes(hex);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(32);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== 32)\n            throw new Error('sign: Expected 32 bytes of extra data');\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    let { sig, recovery } = recSig;\n    const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    if (canonical && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    await drbg.reseed(seed);\n    while (!(sig = kmdToSig(await drbg.generate(), m, d)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    drbg.reseedSync(seed);\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction finalizeSchnorrChallenge(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nfunction hasEvenY(point) {\n    return (point.y & _1n) === _0n;\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nfunction initSchnorrSigArgs(message, privateKey, auxRand) {\n    if (message == null)\n        throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n    const m = ensureBytes(message);\n    const d0 = normalizePrivateKey(privateKey);\n    const rand = ensureBytes(auxRand);\n    if (rand.length !== 32)\n        throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    const P = Point.fromPrivateKey(d0);\n    const px = P.toRawX();\n    const d = hasEvenY(P) ? d0 : CURVE.n - d0;\n    return { m, P, px, d, rand };\n}\nfunction initSchnorrNonce(d, t0h) {\n    return numTo32b(d ^ bytesToNumber(t0h));\n}\nfunction finalizeSchnorrNonce(k0h) {\n    const k0 = mod(bytesToNumber(k0h), CURVE.n);\n    if (k0 === _0n)\n        throw new Error('sign: Creation of signature failed. k is zero');\n    const R = Point.fromPrivateKey(k0);\n    const rx = R.toRawX();\n    const k = hasEvenY(R) ? k0 : CURVE.n - k0;\n    return { R, rx, k };\n}\nfunction finalizeSchnorrSig(R, k, e, d) {\n    return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n}\nasync function schnorrSign(message, privateKey, auxRand = utils.randomBytes()) {\n    const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);\n    const t = initSchnorrNonce(d, await utils.taggedHash(TAGS.aux, rand));\n    const { R, rx, k } = finalizeSchnorrNonce(await utils.taggedHash(TAGS.nonce, t, px, m));\n    const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, rx, px, m));\n    const sig = finalizeSchnorrSig(R, k, e, d);\n    const isValid = await schnorrVerify(sig, m, px);\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\nfunction schnorrSignSync(message, privateKey, auxRand = utils.randomBytes()) {\n    const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);\n    const t = initSchnorrNonce(d, utils.taggedHashSync(TAGS.aux, rand));\n    const { R, rx, k } = finalizeSchnorrNonce(utils.taggedHashSync(TAGS.nonce, t, px, m));\n    const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, rx, px, m));\n    const sig = finalizeSchnorrSig(R, k, e, d);\n    const isValid = schnorrVerifySync(sig, m, px);\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !hasEvenY(R) || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = finalizeSchnorrChallenge(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = finalizeSchnorrChallenge(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    privateAdd: (privateKey, tweak) => {\n        const p = normalizePrivateKey(privateKey);\n        const t = normalizePrivateKey(tweak);\n        return numTo32b(mod(p + t, CURVE.n));\n    },\n    privateNegate: (privateKey) => {\n        const p = normalizePrivateKey(privateKey);\n        return numTo32b(CURVE.n - p);\n    },\n    pointAddScalar: (p, tweak, isCompressed) => {\n        const P = Point.fromHex(p);\n        const t = normalizePrivateKey(tweak);\n        const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);\n        if (!Q)\n            throw new Error('Tweaked point at infinity');\n        return Q.toRawBytes(isCompressed);\n    },\n    pointMultiply: (p, tweak, isCompressed) => {\n        const P = Point.fromHex(p);\n        const t = bytesToNumber(ensureBytes(tweak));\n        return P.multiply(t).toRawBytes(isCompressed);\n    },\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.hashToPrivateKey(utils.randomBytes(40));\n    },\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof utils.sha256Sync !== 'function')\n            throw new Error('utils.sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = utils.sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256Sync(tagP, ...messages);\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n};\n","import assert from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nclass HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assert.hash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (!(this.iHash instanceof Hash))\n            throw new TypeError('Expected instance of class which extends utils.Hash');\n        const blockLen = (this.blockLen = this.iHash.blockLen);\n        this.outputLen = this.iHash.outputLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        assert.exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        assert.exists(this);\n        assert.bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n","import { hexToInt } from './utils';\nconst COORDINATE_BYTES = 32;\nexport function parseRecoverableSignatureVrs(signature) {\n    if (signature.length < COORDINATE_BYTES * 2 * 2 + 1) {\n        throw new Error('Invalid signature');\n    }\n    const recoveryIdHex = signature.slice(0, 2);\n    const r = signature.slice(2, 2 + COORDINATE_BYTES * 2);\n    const s = signature.slice(2 + COORDINATE_BYTES * 2);\n    return {\n        recoveryId: hexToInt(recoveryIdHex),\n        r,\n        s,\n    };\n}\nexport function signatureVrsToRsv(signature) {\n    return signature.slice(2) + signature.slice(0, 2);\n}\nexport function signatureRsvToVrs(signature) {\n    return signature.slice(-2) + signature.slice(0, -2);\n}\n//# sourceMappingURL=signatures.js.map","export var ChainID;\n(function (ChainID) {\n    ChainID[ChainID[\"Testnet\"] = 2147483648] = \"Testnet\";\n    ChainID[ChainID[\"Mainnet\"] = 1] = \"Mainnet\";\n})(ChainID || (ChainID = {}));\nexport var TransactionVersion;\n(function (TransactionVersion) {\n    TransactionVersion[TransactionVersion[\"Mainnet\"] = 0] = \"Mainnet\";\n    TransactionVersion[TransactionVersion[\"Testnet\"] = 128] = \"Testnet\";\n})(TransactionVersion || (TransactionVersion = {}));\nexport const PRIVATE_KEY_COMPRESSED_LENGTH = 33;\nexport const PRIVATE_KEY_UNCOMPRESSED_LENGTH = 32;\nexport const BLOCKSTACK_DEFAULT_GAIA_HUB_URL = 'https://hub.blockstack.org';\n//# sourceMappingURL=constants.js.map","import {\n  AddressHashMode,\n  AddressVersion,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  StacksMessageType,\n  TransactionVersion,\n} from './constants';\nimport { Buffer } from '@stacks/common';\nimport { c32address } from 'c32check';\n\nexport interface Address {\n  readonly type: StacksMessageType.Address;\n  readonly version: AddressVersion;\n  readonly hash160: string;\n}\n\nexport interface MessageSignature {\n  readonly type: StacksMessageType.MessageSignature;\n  data: string;\n}\n\nexport function createMessageSignature(signature: string): MessageSignature {\n  const length = Buffer.from(signature, 'hex').byteLength;\n  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n    throw Error('Invalid signature');\n  }\n\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: signature,\n  };\n}\n\n/**\n * Translates the tx auth hash mode to the corresponding address version.\n * @see https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#transaction-authorization\n */\nexport function addressHashModeToVersion(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion\n): AddressVersion {\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetSingleSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetSingleSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    case AddressHashMode.SerializeP2SH:\n    case AddressHashMode.SerializeP2WPKH:\n    case AddressHashMode.SerializeP2WSH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetMultiSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetMultiSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    default:\n      throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n  }\n}\n\nexport function addressFromVersionHash(version: AddressVersion, hash: string): Address {\n  return { type: StacksMessageType.Address, version, hash160: hash };\n}\n\nexport function addressToString(address: Address): string {\n  return c32address(address.version, address.hash160).toString();\n}\n","import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n  getPublicKey as nobleGetPublicKey,\n  Point,\n  Signature,\n  signSync,\n  utils,\n} from '@noble/secp256k1';\nimport {\n  Buffer,\n  bytesToHex,\n  hexToBigInt,\n  intToHex,\n  parseRecoverableSignatureVrs,\n  privateKeyToBuffer,\n  PRIVATE_KEY_COMPRESSED_LENGTH,\n  signatureRsvToVrs,\n  signatureVrsToRsv,\n} from '@stacks/common';\nimport { c32address } from 'c32check';\nimport { BufferReader } from './bufferReader';\nimport {\n  addressFromVersionHash,\n  addressHashModeToVersion,\n  addressToString,\n  createMessageSignature,\n  MessageSignature,\n} from './common';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n} from './constants';\nimport { BufferArray, hash160, hashP2PKH } from './utils';\n\n/**\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\n * secp256k1.signSync is used within signWithKey in this file\n * secp256k1.signSync is used to maintain the semantics of signWithKey while migrating from elliptic lib\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\n */\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\nexport interface StacksPublicKey {\n  readonly type: StacksMessageType.PublicKey;\n  readonly data: Buffer;\n}\n\n/** Creates a P2PKH address string from the given private key and tx version. */\nexport function getAddressFromPrivateKey(\n  /** Private key buffer or hex string */\n  privateKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\n\n/** Creates a P2PKH address string from the given public key and tx version. */\nexport function getAddressFromPublicKey(\n  /** Public key buffer or hex string */\n  publicKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));\n  const addrString = addressToString(addr);\n  return addrString;\n}\n\nexport function createStacksPublicKey(key: string): StacksPublicKey {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: Buffer.from(key, 'hex'),\n  };\n}\n\nexport function publicKeyFromSignatureVrs(\n  message: string,\n  messageSignature: MessageSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n): string {\n  const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);\n  const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));\n  const point = Point.fromSignature(message, signature, parsedSignature.recoveryId);\n  const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;\n  return point.toHex(compressed);\n}\n\nexport function publicKeyFromSignatureRsv(\n  message: string,\n  messageSignature: MessageSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n): string {\n  return publicKeyFromSignatureVrs(\n    message,\n    { ...messageSignature, data: signatureRsvToVrs(messageSignature.data) },\n    pubKeyEncoding\n  );\n}\n\n/**\n * @deprecated use {@link publicKeyFromSignatureRsv} (recommended) or {@link publicKeyFromSignatureVrs} instead\n */\nexport const publicKeyFromSignature = publicKeyFromSignatureVrs;\n\nexport function publicKeyFromBuffer(data: Buffer): StacksPublicKey {\n  return { type: StacksMessageType.PublicKey, data };\n}\n\nexport function isCompressed(key: StacksPublicKey): boolean {\n  return !key.data.toString('hex').startsWith('04');\n}\n\nexport function publicKeyToString(key: StacksPublicKey): string {\n  return key.data.toString('hex');\n}\n\nexport function serializePublicKey(key: StacksPublicKey): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(key.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function pubKeyfromPrivKey(privateKey: string | Buffer): StacksPublicKey {\n  const privKey = createStacksPrivateKey(privateKey);\n  const publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);\n  return createStacksPublicKey(bytesToHex(publicKey));\n}\n\nexport function compressPublicKey(publicKey: string | Buffer): StacksPublicKey {\n  const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const compressed = Point.fromHex(hex).toHex(true);\n  return createStacksPublicKey(compressed);\n}\n\nexport function deserializePublicKey(bufferReader: BufferReader): StacksPublicKey {\n  const fieldId = bufferReader.readUInt8();\n  const keyLength =\n    fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBuffer(\n    Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)])\n  );\n}\n\nexport interface StacksPrivateKey {\n  // \"compressed\" private key is a misnomer: https://web.archive.org/web/20220131144208/https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch04.html#comp_priv\n  // it actually means: should public keys be generated as \"compressed\" or \"uncompressed\" from this private key\n  compressed: boolean;\n  data: Buffer;\n}\n\nexport function createStacksPrivateKey(key: string | Buffer): StacksPrivateKey {\n  const data = privateKeyToBuffer(key);\n  const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;\n  return { data, compressed };\n}\n\nexport function makeRandomPrivKey(): StacksPrivateKey {\n  return createStacksPrivateKey(bytesToHex(utils.randomPrivateKey()));\n}\n\n/**\n * @deprecated The Clarity compatible {@link signMessageHashRsv} is preferred, but differs in signature format\n * @returns A recoverable signature (in VRS order)\n */\nexport function signWithKey(privateKey: StacksPrivateKey, messageHash: string): MessageSignature {\n  const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {\n    canonical: true,\n    recovered: true,\n  });\n  if (recoveryId == null) {\n    throw new Error('No signature recoveryId received');\n  }\n  const recoveryIdHex = intToHex(recoveryId, 1);\n  const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex(); // V + RS\n  return createMessageSignature(recoverableSignatureString);\n}\n\n/**\n * Signs a message using a private key. The resulting signature along with the\n * original message can be verified using {@link verifyMessageSignature}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signMessageHashRsv({\n  messageHash,\n  privateKey,\n}: {\n  messageHash: string;\n  privateKey: StacksPrivateKey;\n}): MessageSignature {\n  const messageSignature = signWithKey(privateKey, messageHash);\n  return { ...messageSignature, data: signatureVrsToRsv(messageSignature.data) };\n}\n\n/**\n * @deprecated\n * This method is now exported from `@stacks/common` {@link parseRecoverableSignatureVrs}\n */\nexport const parseRecoverableSignature = parseRecoverableSignatureVrs;\n\nexport function getPublicKey(privateKey: StacksPrivateKey): StacksPublicKey {\n  return pubKeyfromPrivKey(privateKey.data);\n}\n\nexport function privateKeyToString(privateKey: StacksPrivateKey): string {\n  return privateKey.data.toString('hex');\n}\n\nexport function publicKeyToAddress(version: AddressVersion, publicKey: StacksPublicKey): string {\n  return c32address(version, hash160(publicKey.data).toString('hex'));\n}\n","import { Buffer } from './utils';\nexport function privateKeyToBuffer(privateKey) {\n    const privateKeyBuffer = Buffer.isBuffer(privateKey)\n        ? privateKey\n        : Buffer.from(privateKey, 'hex');\n    if (privateKeyBuffer.length != 32 && privateKeyBuffer.length != 33) {\n        throw new Error(`Improperly formatted private-key. Private-key byte length should be 32 or 33. Length provided: ${privateKeyBuffer.length}`);\n    }\n    if (privateKeyBuffer.length == 33 && privateKeyBuffer[32] !== 1) {\n        throw new Error('Improperly formatted private-key. 33 bytes indicate compressed key, but the last byte must be == 01');\n    }\n    return privateKeyBuffer;\n}\n//# sourceMappingURL=keys.js.map","import {\n  FungibleConditionCode,\n  MAX_STRING_LENGTH_BYTES,\n  NonFungibleConditionCode,\n  PostConditionPrincipalID,\n  PostConditionType,\n  StacksMessageType,\n} from './constants';\nimport { c32addressDecode } from 'c32check';\nimport { Address } from './common';\nimport { ClarityValue } from './clarity';\nimport { exceedsMaxLengthBytes } from './utils';\n\nexport interface StandardPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Standard;\n  readonly address: Address;\n}\n\nexport interface ContractPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Contract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\nexport interface LengthPrefixedString {\n  readonly type: StacksMessageType.LengthPrefixedString;\n  readonly content: string;\n  readonly lengthPrefixBytes: number;\n  readonly maxLengthBytes: number;\n}\n\nexport interface AssetInfo {\n  readonly type: StacksMessageType.AssetInfo;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly assetName: LengthPrefixedString;\n}\n\nexport interface STXPostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.STX;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: bigint;\n}\n\nexport interface FungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.Fungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: bigint;\n  readonly assetInfo: AssetInfo;\n}\n\nexport interface NonFungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.NonFungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: NonFungibleConditionCode;\n  /** Structure that identifies the token type. */\n  readonly assetInfo: AssetInfo;\n  /** The Clarity value that names the token instance. */\n  readonly assetName: ClarityValue;\n}\n\nexport function parseAssetInfoString(id: string): AssetInfo {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\n\nexport function createLPString(content: string): LengthPrefixedString;\nexport function createLPString(content: string, lengthPrefixBytes: number): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes: number,\n  maxLengthBytes: number\n): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes?: number,\n  maxLengthBytes?: number\n): LengthPrefixedString {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);\n  }\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength,\n  };\n}\n\nexport function createAssetInfo(\n  addressString: string,\n  contractName: string,\n  assetName: string\n): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName),\n  };\n}\n\nexport function createAddress(c32AddressString: string): Address {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1],\n  };\n}\n\n/**\n * Parses a principal string for either a standard principal or contract principal.\n * @param principalString - String in the format `{address}.{contractName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract\"\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G\"\n */\nexport function parsePrincipalString(\n  principalString: string\n): StandardPrincipal | ContractPrincipal {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\n\nexport function createContractPrincipal(\n  addressString: string,\n  contractName: string\n): ContractPrincipal {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name,\n  };\n}\n\nexport function createStandardPrincipal(addressString: string): StandardPrincipal {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr,\n  };\n}\n\nexport type PostCondition = STXPostCondition | FungiblePostCondition | NonFungiblePostCondition;\n\nexport type PostConditionPrincipal = StandardPrincipal | ContractPrincipal;\n","/**\n * Type IDs corresponding to each of the Clarity value types as described here:\n * {@link https://github.com/blockstack/blockstack-core/blob/sip/sip-005/sip/sip-005-blocks-and-transactions.md#clarity-value-representation}\n */\nexport enum ClarityType {\n  Int = 0x00,\n  UInt = 0x01,\n  Buffer = 0x02,\n  BoolTrue = 0x03,\n  BoolFalse = 0x04,\n  PrincipalStandard = 0x05,\n  PrincipalContract = 0x06,\n  ResponseOk = 0x07,\n  ResponseErr = 0x08,\n  OptionalNone = 0x09,\n  OptionalSome = 0x0a,\n  List = 0x0b,\n  Tuple = 0x0c,\n  StringASCII = 0x0d,\n  StringUTF8 = 0x0e,\n}\n","import { IntegerType, intToBigInt } from '@stacks/common';\nimport { ClarityType } from '../constants';\n\nconst MAX_U128 = BigInt('0xffffffffffffffffffffffffffffffff'); // (2 ** 128 - 1)\nconst MIN_U128 = BigInt(0);\nconst MAX_I128 = BigInt('0x7fffffffffffffffffffffffffffffff'); // (2 ** 127 - 1)\n// no signed (negative) hex support in bigint constructor\nconst MIN_I128 = BigInt('-170141183460469231731687303715884105728'); // (-2 ** 127)\n\ninterface IntCV {\n  readonly type: ClarityType.Int;\n  readonly value: bigint;\n}\n\n/**\n * Converts IntegerType in to IntCV clarity type\n *\n * @param {value} integer value to be converted to IntCV clarity type\n *\n * @returns {IntCV} returns instance of type IntCV\n *\n * @example\n * ```\n *  import { intCV } from '@stacks/transactions';\n *\n *  const value = intCV('100'); // parameter any of type: number | string | bigint | Uint8Array | BN\n *  // { type: 0, value: 100n }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst intCV = (value: IntegerType): IntCV => {\n  const bigInt = intToBigInt(value, true);\n  if (bigInt > MAX_I128) {\n    throw new RangeError(\n      `Cannot construct clarity integer from value greater than ${MAX_I128.toString()}`\n    );\n  } else if (bigInt < MIN_I128) {\n    throw new RangeError(\n      `Cannot construct clarity integer form value less than ${MIN_I128.toString()}`\n    );\n  }\n  return { type: ClarityType.Int, value: bigInt };\n};\n\ninterface UIntCV {\n  readonly type: ClarityType.UInt;\n  readonly value: bigint;\n}\n\n/**\n * Converts IntegerType in to IntCV clarity type\n *\n * @param {value} integer value to be converted to UIntCV clarity type (Only unsigned integer is allowed otherwise throws exception)\n *\n * @returns {UIntCV} returns instance of type UIntCV\n *\n * @example\n * ```\n *  import { uintCV } from '@stacks/transactions';\n *\n *  const value = uintCV('100'); // parameter any of type: number | string | bigint | Uint8Array | BN\n *  // { type: 1, value: 100n }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst uintCV = (value: IntegerType): UIntCV => {\n  const bigInt = intToBigInt(value, false);\n  if (bigInt < MIN_U128) {\n    throw new RangeError('Cannot construct unsigned clarity integer from negative value');\n  } else if (bigInt > MAX_U128) {\n    throw new RangeError(\n      `Cannot construct unsigned clarity integer greater than ${MAX_U128.toString()}`\n    );\n  }\n  return { type: ClarityType.UInt, value: bigInt };\n};\n\nexport { IntCV, UIntCV, intCV, uintCV };\n","import { Buffer } from '@stacks/common';\nimport { ClarityType } from '../constants';\n\ninterface BufferCV {\n  readonly type: ClarityType.Buffer;\n  readonly buffer: Buffer;\n}\n\n/**\n * Converts a buffer to BufferCV clarity type\n *\n * @param {buffer} buffer value to be converted to clarity type\n *\n * @returns {BufferCV} returns instance of type BufferCV\n *\n * @example\n * ```\n *  import { bufferCV } from '@stacks/transactions';\n *\n *  const buffer = Buffer.from('this is a test');\n *  const buf = bufferCV(buffer);\n *  // { type: 2, buffer: <Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74> }\n *  const value = buf.buffer.toString();\n *  // this is a test\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst bufferCV = (buffer: Buffer): BufferCV => {\n  if (buffer.length > 1000000) {\n    throw new Error('Cannot construct clarity buffer that is greater than 1MB');\n  }\n\n  return { type: ClarityType.Buffer, buffer };\n};\n\n/**\n * Converts a string to BufferCV clarity type\n *\n * @param {str} string input to be converted to bufferCV clarity type\n *\n * @returns {BufferCV} returns instance of type BufferCV\n *\n * @example\n * ```\n *  import { bufferCVFromString } from '@stacks/transactions';\n *\n *  const str = 'this is a test';\n *  const buf = bufferCVFromString(str);\n *  // { type: 2, buffer: <Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74> }\n *  const value = buf.buffer.toString();\n *  // this is a test\n *```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst bufferCVFromString = (str: string): BufferCV => bufferCV(Buffer.from(str));\n\nexport { BufferCV, bufferCV, bufferCVFromString };\n","import { ClarityType } from '../constants';\n\ntype BooleanCV = TrueCV | FalseCV;\n\ninterface TrueCV {\n  type: ClarityType.BoolTrue;\n}\n\ninterface FalseCV {\n  type: ClarityType.BoolFalse;\n}\n\n/**\n * Converts true to BooleanCV clarity type\n *\n * @returns {BooleanCV} returns instance of type BooleanCV\n *\n * @example\n * ```\n *  import { trueCV } from '@stacks/transactions';\n *\n *  const trueCV = trueCV();\n *  // { type: 3 }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst trueCV = (): BooleanCV => ({ type: ClarityType.BoolTrue });\n\n/**\n * Converts false to BooleanCV clarity type\n *\n * @returns {BooleanCV} returns instance of type BooleanCV\n *\n * @example\n * ```\n *  import { falseCV } from '@stacks/transactions';\n *\n *  const falseCV = falseCV();\n *  // { type: 4 }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst falseCV = (): BooleanCV => ({ type: ClarityType.BoolFalse });\n\nexport { BooleanCV, TrueCV, FalseCV, trueCV, falseCV };\n","import { Buffer } from '@stacks/common';\nimport { LengthPrefixedString, createAddress, createLPString } from '../../postcondition-types';\nimport { Address, addressToString } from '../../common';\nimport { ClarityType } from '../constants';\n\ntype PrincipalCV = StandardPrincipalCV | ContractPrincipalCV;\n\ninterface StandardPrincipalCV {\n  readonly type: ClarityType.PrincipalStandard;\n  readonly address: Address;\n}\n\ninterface ContractPrincipalCV {\n  readonly type: ClarityType.PrincipalContract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\nfunction principalToString(principal: PrincipalCV): string {\n  if (principal.type === ClarityType.PrincipalStandard) {\n    return addressToString(principal.address);\n  } else if (principal.type === ClarityType.PrincipalContract) {\n    const address = addressToString(principal.address);\n    return `${address}.${principal.contractName.content}`;\n  } else {\n    throw new Error(`Unexpected principal data: ${JSON.stringify(principal)}`);\n  }\n}\n\nfunction principalCV(principal: string): PrincipalCV {\n  if (principal.includes('.')) {\n    const [address, contractName] = principal.split('.');\n    return contractPrincipalCV(address, contractName);\n  } else {\n    return standardPrincipalCV(principal);\n  }\n}\n\n/**\n * Converts stx address in to StandardPrincipalCV clarity type\n *\n * @param {addressString} string value to be converted to StandardPrincipalCV clarity type\n *\n * @returns {StandardPrincipalCV} returns instance of type StandardPrincipalCV\n *\n * @example\n * ```\n *  import { standardPrincipalCV } from '@stacks/transactions';\n *\n *  const addr = standardPrincipalCV('SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B');\n *  // { type: 5, address: { type: 0, version: 22, hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6' } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction standardPrincipalCV(addressString: string): StandardPrincipalCV {\n  const addr = createAddress(addressString);\n  return { type: ClarityType.PrincipalStandard, address: addr };\n}\n\n/**\n * Converts stx address in to StandardPrincipalCV clarity type\n *\n * @param {addressString} string value to be converted to StandardPrincipalCV clarity type\n *\n * @returns {StandardPrincipalCV} returns instance of type StandardPrincipalCV\n *\n * @example\n * ```\n *  import { standardPrincipalCVFromAddress, Address  } from '@stacks/transactions';\n *\n *  const address: Address = {\n *    type: 0,\n *    version: 22,\n *    hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6'\n *  };\n *\n *  const principalCV = standardPrincipalCVFromAddress(address);\n *  // { type: 5, address: { type: 0, version: 22, hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6' } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction standardPrincipalCVFromAddress(address: Address): StandardPrincipalCV {\n  return { type: ClarityType.PrincipalStandard, address };\n}\n\n/**\n * Converts stx address in to ContractPrincipalCV clarity type\n *\n * @param {addressString} string value to be converted to ContractPrincipalCV clarity type\n\n * @param {contractName} string containing contract name\n *\n * @returns {ContractPrincipalCV} returns instance of type ContractPrincipalCV\n *\n * @example\n * ```\n *  import { contractPrincipalCV } from '@stacks/transactions';\n *\n *  const contractAddress = contractPrincipalCV('SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B', 'test');\n *  // { type: 6, address: { type: 0, version: 22, hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6' }, contractName: { type: 2, content: 'test', lengthPrefixBytes: 1, maxLengthBytes: 128 } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction contractPrincipalCV(addressString: string, contractName: string): ContractPrincipalCV {\n  const addr = createAddress(addressString);\n  const lengthPrefixedContractName = createLPString(contractName);\n  return contractPrincipalCVFromAddress(addr, lengthPrefixedContractName);\n}\n\n/**\n * Create ContractPrincipalCV from Address type\n *\n * @param {address} address value to be converted to ContractPrincipalCV clarity type\n *\n * @param {contractName} contract name of type LengthPrefixedString\n *\n * @returns {ContractPrincipalCV} returns instance of type ContractPrincipalCV\n *\n * @example\n * ```\n *  import { contractPrincipalCVFromAddress, createLPString, createAddress } from '@stacks/transactions';\n *\n *  const contractAddressCV = contractPrincipalCVFromAddress(createAddress('SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B'), createLPString('test'));\n *\n *  // { type: 6, address: { type: 0, version: 22, hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6' }, contractName: { type: 2, content: 'test', lengthPrefixBytes: 1, maxLengthBytes: 128 } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction contractPrincipalCVFromAddress(\n  address: Address,\n  contractName: LengthPrefixedString\n): ContractPrincipalCV {\n  if (Buffer.byteLength(contractName.content) >= 128) {\n    throw new Error('Contract name must be less than 128 bytes');\n  }\n  return { type: ClarityType.PrincipalContract, address, contractName };\n}\n\nfunction contractPrincipalCVFromStandard(\n  sp: StandardPrincipalCV,\n  contractName: string\n): ContractPrincipalCV {\n  const lengthPrefixedContractName = createLPString(contractName);\n  return {\n    type: ClarityType.PrincipalContract,\n    address: sp.address,\n    contractName: lengthPrefixedContractName,\n  };\n}\n\nexport {\n  PrincipalCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  principalCV,\n  principalToString,\n  standardPrincipalCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCV,\n  contractPrincipalCVFromAddress,\n  contractPrincipalCVFromStandard,\n};\n","import { ClarityValue } from '../clarityValue';\nimport { ClarityType } from '../constants';\n\ntype ResponseCV = ResponseErrorCV | ResponseOkCV;\n\ninterface ResponseErrorCV<T extends ClarityValue = ClarityValue> {\n  readonly type: ClarityType.ResponseErr;\n  readonly value: T;\n}\n\ninterface ResponseOkCV<T extends ClarityValue = ClarityValue> {\n  readonly type: ClarityType.ResponseOk;\n  readonly value: T;\n}\n\n/**\n * Converts ClarityValue to responseErrorCV\n *\n * @param {value} ClarityValue value to be converted to responseErrorCV clarity type\n *\n * @returns {responseErrorCV} returns instance of type responseErrorCV\n *\n * @example\n * ```\n *  import { responseErrorCV, intCV } from '@stacks/transactions';\n *\n *  const respErrorCV = responseErrorCV(intCV(1));\n *\n *  // { type: 8, value: { type: 0, value: 1n } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction responseErrorCV<T extends ClarityValue = ClarityValue>(value: T): ResponseErrorCV<T> {\n  return { type: ClarityType.ResponseErr, value };\n}\n\n/**\n * Converts ClarityValue to ResponseOkCV\n *\n * @param {value} ClarityValue value to be converted to ResponseOkCV clarity type\n *\n * @returns {ResponseOkCV} returns instance of type ResponseOkCV\n *\n * @example\n * ```\n *  import { responseOkCV, intCV } from '@stacks/transactions';\n *\n *  const respOKCV = responseOkCV(intCV(1));\n *\n *  // { type: 7, value: { type: 0, value: 1n } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction responseOkCV<T extends ClarityValue = ClarityValue>(value: T): ResponseOkCV<T> {\n  return { type: ClarityType.ResponseOk, value };\n}\n\nexport { ResponseCV, ResponseErrorCV, ResponseOkCV, responseErrorCV, responseOkCV };\n","import { ClarityValue } from '../clarityValue';\nimport { ClarityType } from '../constants';\ntype OptionalCV<T extends ClarityValue = ClarityValue> = NoneCV | SomeCV<T>;\n\ninterface NoneCV {\n  readonly type: ClarityType.OptionalNone;\n}\n\ninterface SomeCV<T extends ClarityValue = ClarityValue> {\n  readonly type: ClarityType.OptionalSome;\n  readonly value: T;\n}\n\n/**\n * Create a null clarity type\n **\n * @returns {NoneCV} returns instance of type NoneCV\n *\n * @example\n * ```\n *  import { noneCV } from '@stacks/transactions';\n *\n *  const value = noneCV();\n *  // { type: 9 }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction noneCV(): NoneCV {\n  return { type: ClarityType.OptionalNone };\n}\n\n/**\n * Converts any ClarityValue in to OptionalCV clarity type\n *\n * @param {ClarityValue} value to be converted to OptionalCV clarity type\n *\n * @returns {OptionalCV} returns instance of type OptionalCV\n *\n * @example\n * ```\n *  import { someCV, trueCV } from '@stacks/transactions';\n *\n *  const value = someCV(trueCV());\n *  // { type: 10, value: { type: 3 } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction someCV<T extends ClarityValue = ClarityValue>(value: T): OptionalCV<T> {\n  return { type: ClarityType.OptionalSome, value };\n}\n\nfunction optionalCVOf<T extends ClarityValue = ClarityValue>(value?: T): OptionalCV<T> {\n  if (value) {\n    return someCV(value);\n  } else {\n    return noneCV();\n  }\n}\n\nexport { OptionalCV, NoneCV, SomeCV, noneCV, someCV, optionalCVOf };\n","import { ClarityValue } from '../clarityValue';\nimport { ClarityType } from '../constants';\n\ninterface ListCV<T extends ClarityValue = ClarityValue> {\n  type: ClarityType.List;\n  list: T[];\n}\n\n/**\n * Create list of clarity types\n *\n * @param {ClarityValue>values: T[]} list of  ClarityValues to be converted to ListCV clarity type\n *\n * @returns {ListCV<T>} returns instance of type ListCV<T>\n *\n * @example\n * ```\n *  import { listCV, intCV } from '@stacks/transactions';\n *\n *  const list = listCV([intCV(1), intCV(2), intCV(3), intCV(-4)]);\n *  // { type: 11, list: [ { type: 0, value: 1n }, { type: 0, value: 2n }, { type: 0, value: 3n }, { type: 0, value: -4n } ] }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction listCV<T extends ClarityValue = ClarityValue>(values: T[]): ListCV<T> {\n  return { type: ClarityType.List, list: values };\n}\n\nexport { ListCV, listCV };\n","import { ClarityValue } from '../clarityValue';\nimport { ClarityType } from '../constants';\nimport { isClarityName } from '../../utils';\n\ntype TupleData<T extends ClarityValue = ClarityValue> = { [key: string]: T };\n\ninterface TupleCV<T extends TupleData = TupleData> {\n  type: ClarityType.Tuple;\n  data: T;\n}\n\n/**\n * Create tuple of clarity values\n *\n * @param {tupleData} tuple value to be converted to tuple of clarity types\n *\n * @returns {TupleCV} returns instance of type clarity tuple\n *\n * @example\n * ```\n *  import { tupleCV, trueCV, falseCV } from '@stacks/transactions';\n *\n *  const tuple = tupleCV({\n *    c: trueCV(),\n *    b: falseCV(),\n *    a: trueCV(),\n *  });\n *  // { type: 12, data: { c: { type: 3 }, b: { type: 4 }, a: { type: 3 } } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction tupleCV<T extends ClarityValue = ClarityValue>(data: TupleData<T>): TupleCV<TupleData<T>> {\n  for (const key in data) {\n    if (!isClarityName(key)) {\n      throw new Error(`\"${key}\" is not a valid Clarity name`);\n    }\n  }\n\n  return { type: ClarityType.Tuple, data };\n}\n\nexport { TupleCV, tupleCV };\n","import { Buffer } from '@stacks/common';\nimport { SmartBuffer, SmartBufferOptions } from 'smart-buffer';\n\nfunction createEnumChecker<T extends string, TEnumValue extends number>(enumVariable: {\n  [key in T]: TEnumValue;\n}): (value: number) => value is TEnumValue {\n  // Create a set of valid enum number values.\n  const enumValues = Object.values<number>(enumVariable).filter(v => typeof v === 'number');\n  const enumValueSet = new Set<number>(enumValues);\n  return (value: number): value is TEnumValue => enumValueSet.has(value);\n}\n\nconst enumCheckFunctions = new Map<object, (value: number) => boolean>();\n\n/**\n * Type guard to check if a given value is a valid enum value.\n * @param enumVariable - Literal `enum` type.\n * @param value - A value to check against the enum's values.\n * @example\n * ```ts\n * enum Color {\n *   Purple = 3,\n *   Orange = 5\n * }\n * const val: number = 3;\n * if (isEnum(Color, val)) {\n *   // `val` is known as enum type `Color`, e.g.:\n *   const colorVal: Color = val;\n * }\n * ```\n */\nexport function isEnum<T extends string, TEnumValue extends number>(\n  enumVariable: { [key in T]: TEnumValue },\n  value: number\n): value is TEnumValue {\n  const checker = enumCheckFunctions.get(enumVariable);\n  if (checker !== undefined) {\n    return checker(value);\n  }\n  const newChecker = createEnumChecker(enumVariable);\n  enumCheckFunctions.set(enumVariable, newChecker);\n  return isEnum(enumVariable, value);\n}\n\nexport class BufferReader {\n  smartBuffer: SmartBuffer;\n\n  static fromBuffer(buffer: Buffer): BufferReader {\n    return new BufferReader({ buff: buffer });\n  }\n\n  constructor(options?: SmartBufferOptions | Buffer) {\n    if (Buffer.isBuffer(options)) {\n      this.smartBuffer = new SmartBuffer({ buff: options });\n    } else {\n      this.smartBuffer = new SmartBuffer(options);\n    }\n  }\n\n  readBuffer(length: number): Buffer {\n    return this.smartBuffer.readBuffer(length);\n  }\n\n  readUInt32BE(offset?: number): number {\n    return this.smartBuffer.readUInt32BE(offset);\n  }\n\n  readUInt8(): number {\n    return this.smartBuffer.readUInt8();\n  }\n\n  readUInt16BE(): number {\n    return this.smartBuffer.readUInt16BE();\n  }\n\n  readBigUIntLE(length: number): bigint {\n    const buffer = Buffer.from(this.smartBuffer.readBuffer(length)).reverse();\n    const hex = buffer.toString();\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUIntBE(length: number): bigint {\n    const buffer = this.smartBuffer.readBuffer(length);\n    const hex = buffer.toString('hex');\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUInt64BE(): bigint {\n    return this.smartBuffer.readBigUInt64BE();\n  }\n\n  readString(arg?: number | BufferEncoding, encoding?: BufferEncoding): string {\n    return this.smartBuffer.readString(arg, encoding);\n  }\n\n  get readOffset(): number {\n    return this.smartBuffer.readOffset;\n  }\n\n  set readOffset(val: number) {\n    this.smartBuffer.readOffset = val;\n  }\n\n  get internalBuffer(): Buffer {\n    return this.smartBuffer.internalBuffer;\n  }\n\n  readUInt8Enum<T extends string, TEnumValue extends number>(\n    enumVariable: { [key in T]: TEnumValue },\n    invalidEnumErrorFormatter: (val: number) => Error\n  ): TEnumValue {\n    const num = this.smartBuffer.readUInt8();\n    if (isEnum(enumVariable, num)) {\n      return num;\n    } else {\n      throw invalidEnumErrorFormatter(num);\n    }\n  }\n}\n","export class SerializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class DeserializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class NotImplementedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class SigningError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\nexport class VerificationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n","import { ClarityType } from '../constants';\n\ninterface StringAsciiCV {\n  readonly type: ClarityType.StringASCII;\n  readonly data: string;\n}\n\ninterface StringUtf8CV {\n  readonly type: ClarityType.StringUTF8;\n  readonly data: string;\n}\n\n/**\n * Converts ClarityValue to stringAsciiCV\n *\n * @param {data} ClarityValue value to be converted to stringAsciiCV clarity type\n *\n * @returns {StringAsciiCV} returns instance of type StringAsciiCV\n *\n * @example\n * ```\n *  import { stringAsciiCV } from '@stacks/transactions';\n *\n *  const stringAscii = stringAsciiCV('test');\n *\n *  // { type: 13, data: 'hello' }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst stringAsciiCV = (data: string): StringAsciiCV => {\n  return { type: ClarityType.StringASCII, data };\n};\n\n/**\n * Converts ClarityValue to stringUtf8CV\n *\n * @param {data} ClarityValue value to be converted to stringUtf8CV clarity type\n *\n * @returns {stringUtf8CV} returns instance of type stringUtf8CV\n *\n * @example\n * ```\n *  import { stringUtf8CV } from '@stacks/transactions';\n *\n *  const stringUTF8 = stringUtf8CV('test');\n *\n *  // { type: 13, data: 'hello' }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst stringUtf8CV = (data: string): StringUtf8CV => {\n  return { type: ClarityType.StringUTF8, data };\n};\n\n/**\n *  @ignore\n */\nconst stringCV = (data: string, encoding: 'ascii' | 'utf8'): StringAsciiCV | StringUtf8CV => {\n  switch (encoding) {\n    case 'ascii':\n      return stringAsciiCV(data);\n    case 'utf8':\n      return stringAsciiCV(data);\n  }\n};\n\nexport { StringAsciiCV, StringUtf8CV, stringAsciiCV, stringUtf8CV, stringCV };\n","import { Buffer } from '@stacks/common';\nimport {\n  ClarityType,\n  ClarityValue,\n  intCV,\n  uintCV,\n  bufferCV,\n  trueCV,\n  falseCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCVFromAddress,\n  responseOkCV,\n  responseErrorCV,\n  noneCV,\n  someCV,\n  listCV,\n  tupleCV,\n} from '.';\nimport { BufferReader } from '../bufferReader';\nimport { deserializeAddress, deserializeLPString } from '../types';\nimport { DeserializationError } from '../errors';\nimport { stringAsciiCV, stringUtf8CV } from './types/stringCV';\n\n/**\n * Deserializes clarity value to clarity type\n *\n * @param {value} Buffer | string value to be converted to clarity type\n **\n * @returns {ClarityType} returns the clarity type instance\n *\n * @example\n * ```\n *  import { intCV, serializeCV, deserializeCV } from '@stacks/transactions';\n *\n *  const serialized = serializeCV(intCV(100)); // Similarly works for other clarity types as well like listCV, booleanCV ...\n *\n *  // <Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64>\n *\n *  const deserialized = deserializeCV(serialized);\n *  // { type: 0, value: 100n }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nexport default function deserializeCV<T extends ClarityValue = ClarityValue>(\n  serializedClarityValue: BufferReader | Buffer | string\n): T {\n  let bufferReader: BufferReader;\n  if (typeof serializedClarityValue === 'string') {\n    const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === '0x';\n    bufferReader = new BufferReader(\n      Buffer.from(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue, 'hex')\n    );\n  } else if (Buffer.isBuffer(serializedClarityValue)) {\n    bufferReader = new BufferReader(serializedClarityValue);\n  } else {\n    bufferReader = serializedClarityValue;\n  }\n  const type = bufferReader.readUInt8Enum(ClarityType, n => {\n    throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);\n  });\n\n  switch (type) {\n    case ClarityType.Int:\n      return intCV(bufferReader.readBuffer(16)) as T;\n\n    case ClarityType.UInt:\n      return uintCV(bufferReader.readBuffer(16)) as T;\n\n    case ClarityType.Buffer:\n      const bufferLength = bufferReader.readUInt32BE();\n      return bufferCV(bufferReader.readBuffer(bufferLength)) as T;\n\n    case ClarityType.BoolTrue:\n      return trueCV() as T;\n\n    case ClarityType.BoolFalse:\n      return falseCV() as T;\n\n    case ClarityType.PrincipalStandard:\n      const sAddress = deserializeAddress(bufferReader);\n      return standardPrincipalCVFromAddress(sAddress) as T;\n\n    case ClarityType.PrincipalContract:\n      const cAddress = deserializeAddress(bufferReader);\n      const contractName = deserializeLPString(bufferReader);\n      return contractPrincipalCVFromAddress(cAddress, contractName) as T;\n\n    case ClarityType.ResponseOk:\n      return responseOkCV(deserializeCV(bufferReader)) as T;\n\n    case ClarityType.ResponseErr:\n      return responseErrorCV(deserializeCV(bufferReader)) as T;\n\n    case ClarityType.OptionalNone:\n      return noneCV() as T;\n\n    case ClarityType.OptionalSome:\n      return someCV(deserializeCV(bufferReader)) as T;\n\n    case ClarityType.List:\n      const listLength = bufferReader.readUInt32BE();\n      const listContents: ClarityValue[] = [];\n      for (let i = 0; i < listLength; i++) {\n        listContents.push(deserializeCV(bufferReader));\n      }\n      return listCV(listContents) as T;\n\n    case ClarityType.Tuple:\n      const tupleLength = bufferReader.readUInt32BE();\n      const tupleContents: { [key: string]: ClarityValue } = {};\n      for (let i = 0; i < tupleLength; i++) {\n        const clarityName = deserializeLPString(bufferReader).content;\n        if (clarityName === undefined) {\n          throw new DeserializationError('\"content\" is undefined');\n        }\n        tupleContents[clarityName] = deserializeCV(bufferReader);\n      }\n      return tupleCV(tupleContents) as T;\n\n    case ClarityType.StringASCII:\n      const asciiStrLen = bufferReader.readUInt32BE();\n      const asciiStr = bufferReader.readBuffer(asciiStrLen).toString('ascii');\n      return stringAsciiCV(asciiStr) as T;\n\n    case ClarityType.StringUTF8:\n      const utf8StrLen = bufferReader.readUInt32BE();\n      const utf8Str = bufferReader.readBuffer(utf8StrLen).toString('utf8');\n      return stringUtf8CV(utf8Str) as T;\n\n    default:\n      throw new DeserializationError(\n        'Unable to deserialize Clarity Value from buffer. Could not find valid Clarity Type.'\n      );\n  }\n}\n","import { Buffer, IntegerType, intToBigInt, intToBytes } from '@stacks/common';\nimport { COINBASE_BUFFER_LENGTH_BYTES, PayloadType, StacksMessageType } from './constants';\n\nimport { BufferArray } from './utils';\n\nimport {\n  MemoString,\n  createMemoString,\n  serializeStacksMessage,\n  deserializeAddress,\n  deserializeLPString,\n  deserializeMemoString,\n  codeBodyString,\n} from './types';\nimport { createAddress, LengthPrefixedString, createLPString } from './postcondition-types';\nimport { Address } from './common';\nimport { ClarityValue, serializeCV, deserializeCV } from './clarity/';\n\nimport { BufferReader } from './bufferReader';\nimport { PrincipalCV, principalCV } from './clarity/types/principalCV';\n\nexport type Payload =\n  | TokenTransferPayload\n  | ContractCallPayload\n  | SmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload;\n\nexport interface TokenTransferPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.TokenTransfer;\n  readonly recipient: PrincipalCV;\n  readonly amount: bigint;\n  readonly memo: MemoString;\n}\n\nexport type PayloadInput =\n  | (TokenTransferPayload | (Omit<TokenTransferPayload, 'amount'> & { amount: IntegerType }))\n  | ContractCallPayload\n  | SmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload;\n\nexport function createTokenTransferPayload(\n  recipient: string | PrincipalCV,\n  amount: IntegerType,\n  memo?: string | MemoString\n): TokenTransferPayload {\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount: intToBigInt(amount, false),\n    memo: memo ?? createMemoString(''),\n  };\n}\n\nexport interface ContractCallPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.ContractCall;\n  readonly contractAddress: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly functionName: LengthPrefixedString;\n  readonly functionArgs: ClarityValue[];\n}\n\nexport function createContractCallPayload(\n  contractAddress: string | Address,\n  contractName: string | LengthPrefixedString,\n  functionName: string | LengthPrefixedString,\n  functionArgs: ClarityValue[]\n): ContractCallPayload {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs,\n  };\n}\n\nexport interface SmartContractPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.SmartContract;\n  readonly contractName: LengthPrefixedString;\n  readonly codeBody: LengthPrefixedString;\n}\n\nexport function createSmartContractPayload(\n  contractName: string | LengthPrefixedString,\n  codeBody: string | LengthPrefixedString\n): SmartContractPayload {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody,\n  };\n}\n\nexport interface PoisonPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.PoisonMicroblock;\n}\n\nexport function createPoisonPayload(): PoisonPayload {\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };\n}\n\nexport interface CoinbasePayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.Coinbase;\n  readonly coinbaseBuffer: Buffer;\n}\n\nexport function createCoinbasePayload(coinbaseBuffer: Buffer): CoinbasePayload {\n  if (coinbaseBuffer.byteLength != COINBASE_BUFFER_LENGTH_BYTES) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BUFFER_LENGTH_BYTES} bytes`);\n  }\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.Coinbase, coinbaseBuffer };\n}\n\nexport function serializePayload(payload: PayloadInput): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(payload.payloadType);\n\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bufferArray.push(serializeCV(payload.recipient));\n      bufferArray.push(intToBytes(payload.amount, false, 8));\n      bufferArray.push(serializeStacksMessage(payload.memo));\n      break;\n    case PayloadType.ContractCall:\n      bufferArray.push(serializeStacksMessage(payload.contractAddress));\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = Buffer.alloc(4);\n      numArgs.writeUInt32BE(payload.functionArgs.length, 0);\n      bufferArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bufferArray.push(serializeCV(arg));\n      });\n      break;\n    case PayloadType.SmartContract:\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      break;\n    case PayloadType.Coinbase:\n      bufferArray.push(payload.coinbaseBuffer);\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePayload(bufferReader: BufferReader): Payload {\n  const payloadType = bufferReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bufferReader) as PrincipalCV;\n      const amount = intToBigInt(bufferReader.readBuffer(8), false);\n      const memo = deserializeMemoString(bufferReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bufferReader);\n      const contractCallName = deserializeLPString(bufferReader);\n      const functionName = deserializeLPString(bufferReader);\n      const functionArgs: ClarityValue[] = [];\n      const numberOfArgs = bufferReader.readUInt32BE();\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bufferReader);\n        functionArgs.push(clarityValue);\n      }\n      return createContractCallPayload(\n        contractAddress,\n        contractCallName,\n        functionName,\n        functionArgs\n      );\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bufferReader);\n      const codeBody = deserializeLPString(bufferReader, 4, 100000);\n      return createSmartContractPayload(smartContractName, codeBody);\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      return createPoisonPayload();\n    case PayloadType.Coinbase:\n      const coinbaseBuffer = bufferReader.readBuffer(COINBASE_BUFFER_LENGTH_BYTES);\n      return createCoinbasePayload(coinbaseBuffer);\n  }\n}\n","import { BufferReader } from './bufferReader';\nimport { DeserializationError } from './errors';\nimport { PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport {\n  compressPublicKey,\n  deserializePublicKey,\n  serializePublicKey,\n  StacksPublicKey,\n} from './keys';\n\nimport { createMessageSignature, MessageSignature } from './common';\n\n// @ts-ignore\nimport { Buffer } from '@stacks/common';\nimport { BufferArray } from './utils';\n\nexport enum AuthFieldType {\n  PublicKeyCompressed = 0x00,\n  PublicKeyUncompressed = 0x01,\n  SignatureCompressed = 0x02,\n  SignatureUncompressed = 0x03,\n}\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;\n\nexport function deserializeMessageSignature(bufferReader: BufferReader): MessageSignature {\n  return createMessageSignature(\n    bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex')\n  );\n}\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport function createTransactionAuthField(\n  pubKeyEncoding: PubKeyEncoding,\n  contents: TransactionAuthFieldContents\n): TransactionAuthField {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents,\n  };\n}\n\nexport function deserializeTransactionAuthField(bufferReader: BufferReader): TransactionAuthField {\n  const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializePublicKey(bufferReader)\n      );\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializePublicKey(bufferReader)\n      );\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializeMessageSignature(bufferReader)\n      );\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializeMessageSignature(bufferReader)\n      );\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\n\nexport function serializeMessageSignature(messageSignature: MessageSignature): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(messageSignature.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function serializeTransactionAuthField(field: TransactionAuthField): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n        bufferArray.push(serializePublicKey(field.contents));\n      } else {\n        bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n        bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n      break;\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n      } else {\n        bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n      }\n      bufferArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n","import { Buffer, hexToInt, intToBytes, intToHex } from '@stacks/common';\nimport {\n  MEMO_MAX_LENGTH_BYTES,\n  AddressHashMode,\n  AddressVersion,\n  TransactionVersion,\n  StacksMessageType,\n  PostConditionPrincipalID,\n  PostConditionType,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n} from './constants';\n\nimport { StacksPublicKey, serializePublicKey, deserializePublicKey, isCompressed } from './keys';\n\nimport {\n  BufferArray,\n  exceedsMaxLengthBytes,\n  hashP2PKH,\n  rightPadHexToLength,\n  hashP2SH,\n  hashP2WSH,\n  hashP2WPKH,\n} from './utils';\n\nimport { BufferReader } from './bufferReader';\nimport {\n  PostCondition,\n  StandardPrincipal,\n  ContractPrincipal,\n  PostConditionPrincipal,\n  LengthPrefixedString,\n  AssetInfo,\n  createLPString,\n} from './postcondition-types';\nimport { Payload, deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport {\n  deserializeTransactionAuthField,\n  deserializeMessageSignature,\n  serializeMessageSignature,\n  serializeTransactionAuthField,\n  TransactionAuthField,\n} from './signature';\nimport {\n  MessageSignature,\n  Address,\n  addressHashModeToVersion,\n  addressFromVersionHash,\n} from './common';\nimport { deserializeCV, serializeCV } from './clarity';\nexport type StacksMessage =\n  | Address\n  | PostConditionPrincipal\n  | LengthPrefixedString\n  | LengthPrefixedList\n  | Payload\n  | MemoString\n  | AssetInfo\n  | PostCondition\n  | StacksPublicKey\n  | TransactionAuthField\n  | MessageSignature;\n\nexport function serializeStacksMessage(message: StacksMessage): Buffer {\n  switch (message.type) {\n    case StacksMessageType.Address:\n      return serializeAddress(message);\n    case StacksMessageType.Principal:\n      return serializePrincipal(message);\n    case StacksMessageType.LengthPrefixedString:\n      return serializeLPString(message);\n    case StacksMessageType.MemoString:\n      return serializeMemoString(message);\n    case StacksMessageType.AssetInfo:\n      return serializeAssetInfo(message);\n    case StacksMessageType.PostCondition:\n      return serializePostCondition(message);\n    case StacksMessageType.PublicKey:\n      return serializePublicKey(message);\n    case StacksMessageType.LengthPrefixedList:\n      return serializeLPList(message);\n    case StacksMessageType.Payload:\n      return serializePayload(message);\n    case StacksMessageType.TransactionAuthField:\n      return serializeTransactionAuthField(message);\n    case StacksMessageType.MessageSignature:\n      return serializeMessageSignature(message);\n  }\n}\n\nexport function deserializeStacksMessage(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  listType?: StacksMessageType\n): StacksMessage {\n  switch (type) {\n    case StacksMessageType.Address:\n      return deserializeAddress(bufferReader);\n    case StacksMessageType.Principal:\n      return deserializePrincipal(bufferReader);\n    case StacksMessageType.LengthPrefixedString:\n      return deserializeLPString(bufferReader);\n    case StacksMessageType.MemoString:\n      return deserializeMemoString(bufferReader);\n    case StacksMessageType.AssetInfo:\n      return deserializeAssetInfo(bufferReader);\n    case StacksMessageType.PostCondition:\n      return deserializePostCondition(bufferReader);\n    case StacksMessageType.PublicKey:\n      return deserializePublicKey(bufferReader);\n    case StacksMessageType.Payload:\n      return deserializePayload(bufferReader);\n    case StacksMessageType.LengthPrefixedList:\n      if (!listType) {\n        throw new DeserializationError('No List Type specified');\n      }\n      return deserializeLPList(bufferReader, listType);\n    case StacksMessageType.MessageSignature:\n      return deserializeMessageSignature(bufferReader);\n    default:\n      throw new Error('Could not recognize StacksMessageType');\n  }\n}\n\nexport function createEmptyAddress(): Address {\n  return {\n    type: StacksMessageType.Address,\n    version: AddressVersion.MainnetSingleSig,\n    hash160: '0'.repeat(40),\n  };\n}\n\nexport function addressFromHashMode(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion,\n  data: string\n): Address {\n  const version = addressHashModeToVersion(hashMode, txVersion);\n  return addressFromVersionHash(version, data);\n}\n\nexport function addressFromPublicKeys(\n  version: AddressVersion,\n  hashMode: AddressHashMode,\n  numSigs: number,\n  publicKeys: StacksPublicKey[]\n): Address {\n  if (publicKeys.length === 0) {\n    throw Error('Invalid number of public keys');\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    if (publicKeys.length !== 1 || numSigs !== 1) {\n      throw Error('Invalid number of public keys or signatures');\n    }\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n    for (let i = 0; i < publicKeys.length; i++) {\n      if (!isCompressed(publicKeys[i])) {\n        throw Error('Public keys must be compressed for segwit');\n      }\n    }\n  }\n\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2WPKH:\n      return addressFromVersionHash(version, hashP2WPKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2SH:\n      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n    case AddressHashMode.SerializeP2WSH:\n      return addressFromVersionHash(\n        version,\n        hashP2WSH(numSigs, publicKeys.map(serializePublicKey))\n      );\n  }\n}\n\nexport function serializeAddress(address: Address): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHex(address.version, 1));\n  bufferArray.appendHexString(address.hash160);\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAddress(bufferReader: BufferReader): Address {\n  const version = hexToInt(bufferReader.readBuffer(1).toString('hex'));\n  const data = bufferReader.readBuffer(20).toString('hex');\n\n  return { type: StacksMessageType.Address, version, hash160: data };\n}\n\nexport function serializePrincipal(principal: PostConditionPrincipal): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(Buffer.from([principal.prefix]));\n  bufferArray.push(serializeAddress(principal.address));\n  if (principal.prefix === PostConditionPrincipalID.Contract) {\n    bufferArray.push(serializeLPString(principal.contractName));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePrincipal(bufferReader: BufferReader): PostConditionPrincipal {\n  const prefix = bufferReader.readUInt8Enum(PostConditionPrincipalID, _ => {\n    throw new DeserializationError('Unexpected Principal payload type: ${n}');\n  });\n  const address = deserializeAddress(bufferReader);\n  if (prefix === PostConditionPrincipalID.Standard) {\n    return { type: StacksMessageType.Principal, prefix, address } as StandardPrincipal;\n  }\n  const contractName = deserializeLPString(bufferReader);\n  return {\n    type: StacksMessageType.Principal,\n    prefix,\n    address,\n    contractName,\n  } as ContractPrincipal;\n}\n\nexport function serializeLPString(lps: LengthPrefixedString) {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(lps.content);\n  const length = contentBuffer.byteLength;\n  bufferArray.appendHexString(intToHex(length, lps.lengthPrefixBytes));\n  bufferArray.push(contentBuffer);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPString(\n  bufferReader: BufferReader,\n  prefixBytes?: number,\n  maxLength?: number\n): LengthPrefixedString {\n  prefixBytes = prefixBytes ? prefixBytes : 1;\n  const length = hexToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));\n  const content = bufferReader.readBuffer(length).toString();\n  return createLPString(content, prefixBytes, maxLength ?? 128);\n}\n\nexport function codeBodyString(content: string): LengthPrefixedString {\n  return createLPString(content, 4, 100000);\n}\n\nexport interface MemoString {\n  readonly type: StacksMessageType.MemoString;\n  readonly content: string;\n}\n\nexport function createMemoString(content: string): MemoString {\n  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES.toString()} bytes`);\n  }\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeMemoString(memoString: MemoString): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(memoString.content);\n  const paddedContent = rightPadHexToLength(\n    contentBuffer.toString('hex'),\n    MEMO_MAX_LENGTH_BYTES * 2\n  );\n  bufferArray.push(Buffer.from(paddedContent, 'hex'));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeMemoString(bufferReader: BufferReader): MemoString {\n  const content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeAssetInfo(info: AssetInfo): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(serializeAddress(info.address));\n  bufferArray.push(serializeLPString(info.contractName));\n  bufferArray.push(serializeLPString(info.assetName));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAssetInfo(bufferReader: BufferReader): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: deserializeAddress(bufferReader),\n    contractName: deserializeLPString(bufferReader),\n    assetName: deserializeLPString(bufferReader),\n  };\n}\n\nexport interface LengthPrefixedList {\n  readonly type: StacksMessageType.LengthPrefixedList;\n  readonly lengthPrefixBytes: number;\n  readonly values: StacksMessage[];\n}\n\nexport function createLPList<T extends StacksMessage>(\n  values: T[],\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  return {\n    type: StacksMessageType.LengthPrefixedList,\n    lengthPrefixBytes: lengthPrefixBytes || 4,\n    values,\n  };\n}\n\nexport function serializeLPList(lpList: LengthPrefixedList): Buffer {\n  const list = lpList.values;\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHex(list.length, lpList.lengthPrefixBytes));\n  for (let index = 0; index < list.length; index++) {\n    bufferArray.push(serializeStacksMessage(list[index]));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPList(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  const length = hexToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));\n  const l: StacksMessage[] = [];\n  for (let index = 0; index < length; index++) {\n    switch (type) {\n      case StacksMessageType.Address:\n        l.push(deserializeAddress(bufferReader));\n        break;\n      case StacksMessageType.LengthPrefixedString:\n        l.push(deserializeLPString(bufferReader));\n        break;\n      case StacksMessageType.MemoString:\n        l.push(deserializeMemoString(bufferReader));\n        break;\n      case StacksMessageType.AssetInfo:\n        l.push(deserializeAssetInfo(bufferReader));\n        break;\n      case StacksMessageType.PostCondition:\n        l.push(deserializePostCondition(bufferReader));\n        break;\n      case StacksMessageType.PublicKey:\n        l.push(deserializePublicKey(bufferReader));\n        break;\n      case StacksMessageType.TransactionAuthField:\n        l.push(deserializeTransactionAuthField(bufferReader));\n        break;\n    }\n  }\n  return createLPList(l, lengthPrefixBytes);\n}\n\nexport function serializePostCondition(postCondition: PostCondition): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(postCondition.conditionType);\n  bufferArray.push(serializePrincipal(postCondition.principal));\n\n  if (\n    postCondition.conditionType === PostConditionType.Fungible ||\n    postCondition.conditionType === PostConditionType.NonFungible\n  ) {\n    bufferArray.push(serializeAssetInfo(postCondition.assetInfo));\n  }\n\n  if (postCondition.conditionType === PostConditionType.NonFungible) {\n    bufferArray.push(serializeCV(postCondition.assetName));\n  }\n\n  bufferArray.appendByte(postCondition.conditionCode);\n\n  if (\n    postCondition.conditionType === PostConditionType.STX ||\n    postCondition.conditionType === PostConditionType.Fungible\n  ) {\n    bufferArray.push(intToBytes(postCondition.amount, false, 8));\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePostCondition(bufferReader: BufferReader): PostCondition {\n  const postConditionType = bufferReader.readUInt8Enum(PostConditionType, n => {\n    throw new DeserializationError(`Could not read ${n} as PostConditionType`);\n  });\n\n  const principal = deserializePrincipal(bufferReader);\n\n  let conditionCode;\n  let assetInfo;\n  let amount: bigint;\n  switch (postConditionType) {\n    case PostConditionType.STX:\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.STX,\n        principal,\n        conditionCode,\n        amount,\n      };\n    case PostConditionType.Fungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.Fungible,\n        principal,\n        conditionCode,\n        amount,\n        assetInfo,\n      };\n    case PostConditionType.NonFungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      const assetName = deserializeCV(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(NonFungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.NonFungible,\n        principal,\n        conditionCode,\n        assetInfo,\n        assetName,\n      };\n  }\n}\n","import { Buffer, toTwos, toBuffer } from '@stacks/common';\nimport { serializeAddress, serializeLPString } from '../types';\nimport { createLPString } from '../postcondition-types';\nimport {\n  BooleanCV,\n  OptionalCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseCV,\n  ListCV,\n  TupleCV,\n  ClarityValue,\n} from '.';\nimport { ClarityType } from './constants';\nimport { BufferArray } from '../utils';\nimport { SerializationError } from '../errors';\nimport { StringAsciiCV, StringUtf8CV } from './types/stringCV';\nimport { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';\n\nfunction bufferWithTypeID(typeId: ClarityType, buffer: Buffer): Buffer {\n  const id = Buffer.from([typeId]);\n  return Buffer.concat([id, buffer]);\n}\n\nfunction serializeBoolCV(value: BooleanCV): Buffer {\n  return Buffer.from([value.type]);\n}\n\nfunction serializeOptionalCV(cv: OptionalCV): Buffer {\n  if (cv.type === ClarityType.OptionalNone) {\n    return Buffer.from([cv.type]);\n  } else {\n    return bufferWithTypeID(cv.type, serializeCV(cv.value));\n  }\n}\n\nfunction serializeBufferCV(cv: BufferCV): Buffer {\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.buffer.length, 0);\n  return bufferWithTypeID(cv.type, Buffer.concat([length, cv.buffer]));\n}\n\nfunction serializeIntCV(cv: IntCV): Buffer {\n  const buffer = toBuffer(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeUIntCV(cv: UIntCV): Buffer {\n  const buffer = toBuffer(cv.value, CLARITY_INT_BYTE_SIZE);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeStandardPrincipalCV(cv: StandardPrincipalCV): Buffer {\n  return bufferWithTypeID(cv.type, serializeAddress(cv.address));\n}\n\nfunction serializeContractPrincipalCV(cv: ContractPrincipalCV): Buffer {\n  return bufferWithTypeID(\n    cv.type,\n    Buffer.concat([serializeAddress(cv.address), serializeLPString(cv.contractName)])\n  );\n}\n\nfunction serializeResponseCV(cv: ResponseCV) {\n  return bufferWithTypeID(cv.type, serializeCV(cv.value));\n}\n\nfunction serializeListCV(cv: ListCV) {\n  const buffers = new BufferArray();\n\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.list.length, 0);\n  buffers.push(length);\n\n  for (const value of cv.list) {\n    const serializedValue = serializeCV(value);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeTupleCV(cv: TupleCV) {\n  const buffers = new BufferArray();\n\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(Object.keys(cv.data).length, 0);\n  buffers.push(length);\n\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => {\n    const bufA = Buffer.from(a);\n    const bufB = Buffer.from(b);\n    return bufA.compare(bufB);\n  });\n\n  for (const key of lexicographicOrder) {\n    const nameWithLength = createLPString(key);\n    buffers.push(serializeLPString(nameWithLength));\n\n    const serializedValue = serializeCV(cv.data[key]);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringCV(cv: StringAsciiCV | StringUtf8CV, encoding: 'ascii' | 'utf8') {\n  const buffers = new BufferArray();\n\n  const str = Buffer.from(cv.data, encoding);\n  const len = Buffer.alloc(4);\n  len.writeUInt32BE(str.length, 0);\n\n  buffers.push(len);\n  buffers.push(str);\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringAsciiCV(cv: StringAsciiCV) {\n  return serializeStringCV(cv, 'ascii');\n}\n\nfunction serializeStringUtf8CV(cv: StringUtf8CV) {\n  return serializeStringCV(cv, 'utf8');\n}\n\n/**\n * Serializes clarity value to buffer\n *\n * @param {value} clarity value to be converted to buffer\n **\n * @returns {Buffer} returns the buffer instance\n *\n * @example\n * ```\n *  import { intCV, serializeCV } from '@stacks/transactions';\n *\n *  const serialized = serializeCV(intCV(100)); // Similarly works for other clarity types as well like listCV, booleanCV ...\n *\n *  // <Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64>\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nexport function serializeCV(value: ClarityValue): Buffer {\n  switch (value.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return serializeBoolCV(value);\n    case ClarityType.OptionalNone:\n    case ClarityType.OptionalSome:\n      return serializeOptionalCV(value);\n    case ClarityType.Buffer:\n      return serializeBufferCV(value);\n    case ClarityType.UInt:\n      return serializeUIntCV(value);\n    case ClarityType.Int:\n      return serializeIntCV(value);\n    case ClarityType.PrincipalStandard:\n      return serializeStandardPrincipalCV(value);\n    case ClarityType.PrincipalContract:\n      return serializeContractPrincipalCV(value);\n    case ClarityType.ResponseOk:\n    case ClarityType.ResponseErr:\n      return serializeResponseCV(value);\n    case ClarityType.List:\n      return serializeListCV(value);\n    case ClarityType.Tuple:\n      return serializeTupleCV(value);\n    case ClarityType.StringASCII:\n      return serializeStringAsciiCV(value);\n    case ClarityType.StringUTF8:\n      return serializeStringUtf8CV(value);\n    default:\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n  }\n}\n","import { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512_256 } from '@noble/hashes/sha512';\nimport { utils } from '@noble/secp256k1';\nimport { Buffer, bytesToHex, with0x } from '@stacks/common';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash.clonedeep';\nimport { ClarityValue, deserializeCV, serializeCV } from './clarity';\n\n// Export verify as utility method for signature verification\nexport { verify as verifySignature } from '@noble/secp256k1';\n\n/**\n * Use utils.randomBytes to replace randombytes dependency\n * Generates a buffer with random bytes of given length\n * @param {bytesLength} an optional bytes length, default is 32 bytes\n * @return {Buffer} For return type compatibility converting utils.randomBytes return value to buffer\n */\nexport const randomBytes = (bytesLength?: number) => Buffer.from(utils.randomBytes(bytesLength));\n\n/**\n * @deprecated Import from `@stacks/common` instead\n */\nexport { bytesToHex };\n\nexport class BufferArray {\n  _value: Buffer[] = [];\n  get value() {\n    return this._value;\n  }\n  appendHexString(hexString: string) {\n    this.value.push(Buffer.from(hexString, 'hex'));\n  }\n\n  push(buffer: Buffer) {\n    return this._value.push(buffer);\n  }\n  appendByte(octet: number) {\n    if (!Number.isInteger(octet) || octet < 0 || octet > 255) {\n      throw new Error(`Value ${octet} is not a valid byte`);\n    }\n    this.value.push(Buffer.from([octet]));\n  }\n\n  concatBuffer(): Buffer {\n    return Buffer.concat(this.value);\n  }\n}\n\nexport const leftPadHex = (hexString: string): string =>\n  hexString.length % 2 == 0 ? hexString : `0${hexString}`;\n\nexport const leftPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padStart(length, '0');\n\nexport const rightPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padEnd(length, '0');\n\nexport const exceedsMaxLengthBytes = (string: string, maxLengthBytes: number): boolean =>\n  string ? Buffer.from(string).length > maxLengthBytes : false;\n\nexport function cloneDeep<T>(obj: T): T {\n  return lodashCloneDeep(obj);\n}\n\nexport function omit<T, K extends keyof any>(obj: T, prop: K): Omit<T, K> {\n  const clone = cloneDeep(obj);\n  // @ts-expect-error\n  delete clone[prop];\n  return clone;\n}\n\nexport const txidFromData = (data: Buffer): string => {\n  return Buffer.from(sha512_256(data)).toString('hex');\n};\n\nexport const hash160 = (input: Buffer): Buffer => {\n  return Buffer.from(ripemd160(sha256(input)));\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address (p2pkh)\nexport const hashP2PKH = (input: Buffer): string => {\n  return hash160(input).toString('hex');\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address over p2sh (p2h-p2wpkh)\nexport const hashP2WPKH = (input: Buffer): string => {\n  const keyHash = hash160(input);\n\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(0);\n  bufferArray.appendByte(keyHash.length);\n  bufferArray.push(keyHash);\n\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multi-sig address (p2sh)\nexport const hashP2SH = (numSigs: number, pubKeys: Buffer[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const bufferArray = new BufferArray();\n  // OP_n\n  bufferArray.appendByte(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    bufferArray.appendByte(pubKey.length);\n    bufferArray.push(pubKey);\n  });\n  // OP_m\n  bufferArray.appendByte(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  bufferArray.appendByte(174);\n\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multisig address over p2sh (p2sh-p2wsh)\nexport const hashP2WSH = (numSigs: number, pubKeys: Buffer[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2WSH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const scriptArray = new BufferArray();\n  // OP_n\n  scriptArray.appendByte(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    scriptArray.appendByte(pubKey.length);\n    scriptArray.push(pubKey);\n  });\n  // OP_m\n  scriptArray.appendByte(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  scriptArray.appendByte(174);\n\n  const script = scriptArray.concatBuffer();\n  const digest = Buffer.from(sha256(script));\n\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(0);\n  bufferArray.appendByte(digest.length);\n  bufferArray.push(digest);\n\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\n\nexport function isClarityName(name: string) {\n  const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n  return regex.test(name) && name.length < 128;\n}\n\n/**\n * Converts a clarity value to a hex encoded string with `0x` prefix\n * @param {ClarityValue} cv  - the clarity value to convert\n */\nexport function cvToHex(cv: ClarityValue) {\n  const serialized = serializeCV(cv);\n  return `0x${serialized.toString('hex')}`;\n}\n\n/**\n * Converts a hex encoded string to a clarity value\n * @param {string} hex - the hex encoded string with or without `0x` prefix\n */\nexport function hexToCV(hex: string) {\n  return deserializeCV(hex);\n}\n/**\n * Read only function response object\n *\n * @param {Boolean} okay - the status of the response\n * @param {string} result - serialized hex clarity value\n */\n\nexport interface ReadOnlyFunctionSuccessResponse {\n  okay: true;\n  result: string;\n}\n\nexport interface ReadOnlyFunctionErrorResponse {\n  okay: false;\n  cause: string;\n}\n\nexport type ReadOnlyFunctionResponse =\n  | ReadOnlyFunctionSuccessResponse\n  | ReadOnlyFunctionErrorResponse;\n\n/**\n * Converts the response of a read-only function call into its Clarity Value\n * @param param\n */\nexport const parseReadOnlyResponse = (response: ReadOnlyFunctionResponse): ClarityValue => {\n  if (response.okay) {\n    return hexToCV(response.result);\n  } else {\n    throw new Error(response.cause);\n  }\n};\n\nexport const validateStacksAddress = (stacksAddress: string): boolean => {\n  try {\n    c32addressDecode(stacksAddress);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nexport const validateTxId = (txid: string): boolean => {\n  if (txid === 'success') return true; // Bypass fetchMock tests\n  const value = with0x(txid).toLowerCase();\n  if (value.length !== 66) return false;\n  return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;\n};\n","import { Buffer, IntegerType, intToBigInt, intToBytes } from '@stacks/common';\nimport {\n  AddressHashMode,\n  AuthType,\n  MultiSigHashMode,\n  PubKeyEncoding,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  SingleSigHashMode,\n  StacksMessageType,\n} from './constants';\n\nimport { BufferArray, cloneDeep, leftPadHex, txidFromData } from './utils';\nimport {\n  TransactionAuthField,\n  serializeMessageSignature,\n  deserializeMessageSignature,\n} from './signature';\nimport {\n  addressFromPublicKeys,\n  createEmptyAddress,\n  createLPList,\n  deserializeLPList,\n  serializeLPList,\n} from './types';\n\nimport {\n  createStacksPublicKey,\n  getPublicKey,\n  isCompressed,\n  publicKeyFromSignature,\n  signWithKey,\n  StacksPrivateKey,\n  StacksPublicKey,\n} from './keys';\n\nimport { BufferReader } from './bufferReader';\nimport { MessageSignature } from './common';\nimport { DeserializationError, SigningError, VerificationError } from './errors';\n\nexport function emptyMessageSignature(): MessageSignature {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex'),\n  };\n}\n\nexport interface SingleSigSpendingCondition {\n  hashMode: SingleSigHashMode;\n  signer: string;\n  nonce: bigint;\n  fee: bigint;\n  keyEncoding: PubKeyEncoding;\n  signature: MessageSignature;\n}\n\nexport interface SingleSigSpendingConditionOpts\n  extends Omit<SingleSigSpendingCondition, 'nonce' | 'fee'> {\n  nonce: IntegerType;\n  fee: IntegerType;\n}\n\nexport interface MultiSigSpendingCondition {\n  hashMode: MultiSigHashMode;\n  signer: string;\n  nonce: bigint;\n  fee: bigint;\n  fields: TransactionAuthField[];\n  signaturesRequired: number;\n}\n\nexport interface MultiSigSpendingConditionOpts\n  extends Omit<MultiSigSpendingCondition, 'nonce' | 'fee'> {\n  nonce: IntegerType;\n  fee: IntegerType;\n}\n\nexport type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;\n\nexport type SpendingConditionOpts = SingleSigSpendingConditionOpts | MultiSigSpendingConditionOpts;\n\nexport function createSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  pubKey: string,\n  nonce: IntegerType,\n  fee: IntegerType\n): SingleSigSpendingCondition {\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey))\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    keyEncoding,\n    signature: emptyMessageSignature(),\n  };\n}\n\nexport function createMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  numSigs: number,\n  pubKeys: string[],\n  nonce: IntegerType,\n  fee: IntegerType\n): MultiSigSpendingCondition {\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    fields: [],\n    signaturesRequired: numSigs,\n  };\n}\n\nexport function isSingleSig(\n  condition: SpendingConditionOpts\n): condition is SingleSigSpendingConditionOpts {\n  return 'signature' in condition;\n}\n\nfunction clearCondition(condition: SpendingConditionOpts): SpendingCondition {\n  const cloned = cloneDeep(condition);\n  cloned.nonce = 0;\n  cloned.fee = 0;\n\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n\n  return {\n    ...cloned,\n    nonce: BigInt(0),\n    fee: BigInt(0),\n  };\n}\n\nexport function serializeSingleSigSpendingCondition(\n  condition: SingleSigSpendingConditionOpts\n): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n  bufferArray.appendByte(condition.keyEncoding);\n  bufferArray.push(serializeMessageSignature(condition.signature));\n  return bufferArray.concatBuffer();\n}\n\nexport function serializeMultiSigSpendingCondition(\n  condition: MultiSigSpendingConditionOpts\n): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n\n  const fields = createLPList(condition.fields);\n  bufferArray.push(serializeLPList(fields));\n\n  const numSigs = Buffer.alloc(2);\n  numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n  bufferArray.push(numSigs);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  bufferReader: BufferReader\n): SingleSigSpendingCondition {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n\n  const keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, n => {\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n  });\n  if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {\n    throw new DeserializationError(\n      'Failed to parse singlesig spending condition: incomaptible hash mode and key encoding'\n    );\n  }\n  const signature = deserializeMessageSignature(bufferReader);\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature,\n  };\n}\n\nexport function deserializeMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  bufferReader: BufferReader\n): MultiSigSpendingCondition {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n\n  const fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField)\n    .values as TransactionAuthField[];\n\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of fields) {\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        break;\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        numSigs += 1;\n        if (numSigs === 65536)\n          throw new VerificationError(\n            'Failed to parse multisig spending condition: too many signatures'\n          );\n        break;\n    }\n  }\n  const signaturesRequired = bufferReader.readUInt16BE();\n\n  // Partially signed multi-sig tx can be serialized and deserialized without exception (Incorrect number of signatures)\n  // No need to check numSigs !== signaturesRequired to throw Incorrect number of signatures error\n\n  if (haveUncompressed && hashMode === AddressHashMode.SerializeP2SH)\n    throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields,\n    signaturesRequired,\n  };\n}\n\nexport function serializeSpendingCondition(condition: SpendingConditionOpts): Buffer {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  } else {\n    return serializeMultiSigSpendingCondition(condition);\n  }\n}\n\nexport function deserializeSpendingCondition(bufferReader: BufferReader): SpendingCondition {\n  const hashMode = bufferReader.readUInt8Enum(AddressHashMode, n => {\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n  }\n}\n\nexport function makeSigHashPreSign(\n  curSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType\n): string {\n  // new hash combines the previous hash and all the new data this signature will add. This\n  // includes:\n  // * the previous hash\n  // * the auth flag\n  // * the tx fee (big-endian 8-byte number)\n  // * nonce (big-endian 8-byte number)\n  const hashLength = 32 + 1 + 8 + 8;\n\n  const sigHash =\n    curSigHash +\n    Buffer.from([authType]).toString('hex') +\n    intToBytes(fee, false, 8).toString('hex') +\n    intToBytes(nonce, false, 8).toString('hex');\n\n  if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(Buffer.from(sigHash, 'hex'));\n}\n\nfunction makeSigHashPostSign(\n  curSigHash: string,\n  pubKey: StacksPublicKey,\n  signature: MessageSignature\n): string {\n  // new hash combines the previous hash and all the new data this signature will add.  This\n  // includes:\n  // * the public key compression flag\n  // * the signature\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n\n  const pubKeyEncoding = isCompressed(pubKey)\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n\n  const sigHashBuffer = Buffer.from(sigHash, 'hex');\n  if (sigHashBuffer.byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(sigHashBuffer);\n}\n\nexport function nextSignature(\n  curSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType,\n  privateKey: StacksPrivateKey\n): {\n  nextSig: MessageSignature;\n  nextSigHash: string;\n} {\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n\n  const signature = signWithKey(privateKey, sigHashPreSign);\n  const publicKey = getPublicKey(privateKey);\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n\n  return {\n    nextSig: signature,\n    nextSigHash,\n  };\n}\n\nexport function nextVerification(\n  initialSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType,\n  pubKeyEncoding: PubKeyEncoding,\n  signature: MessageSignature\n) {\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n\n  const publicKey = createStacksPublicKey(\n    publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding)\n  );\n\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n\n  return {\n    pubKey: publicKey,\n    nextSigHash,\n  };\n}\n\nfunction newInitialSigHash(): SpendingCondition {\n  const spendingCondition = createSingleSigSpendingCondition(\n    AddressHashMode.SerializeP2PKH,\n    '',\n    0,\n    0\n  );\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\n\nfunction verify(\n  condition: SpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    return verifyMultiSig(condition, initialSigHash, authType);\n  }\n}\n\nfunction verifySingleSig(\n  condition: SingleSigSpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const { pubKey, nextSigHash } = nextVerification(\n    initialSigHash,\n    authType,\n    condition.fee,\n    condition.nonce,\n    condition.keyEncoding,\n    condition.signature\n  );\n\n  // address version arg doesn't matter for signer hash generation\n  const addrBytes = addressFromPublicKeys(0, condition.hashMode, 1, [pubKey]).hash160;\n\n  if (addrBytes !== condition.signer)\n    throw new VerificationError(\n      `Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`\n    );\n\n  return nextSigHash;\n}\n\nfunction verifyMultiSig(\n  condition: MultiSigSpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const publicKeys: StacksPublicKey[] = [];\n  let curSigHash = initialSigHash;\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of condition.fields) {\n    let foundPubKey: StacksPublicKey;\n\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        foundPubKey = field.contents;\n        break;\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        const { pubKey, nextSigHash } = nextVerification(\n          curSigHash,\n          authType,\n          condition.fee,\n          condition.nonce,\n          field.pubKeyEncoding,\n          field.contents\n        );\n        curSigHash = nextSigHash;\n        foundPubKey = pubKey;\n\n        numSigs += 1;\n        if (numSigs === 65536) throw new VerificationError('Too many signatures');\n\n        break;\n    }\n    publicKeys.push(foundPubKey);\n  }\n\n  if (numSigs !== condition.signaturesRequired)\n    throw new VerificationError('Incorrect number of signatures');\n\n  if (haveUncompressed && condition.hashMode === AddressHashMode.SerializeP2SH)\n    throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n\n  const addrBytes = addressFromPublicKeys(\n    0,\n    condition.hashMode,\n    condition.signaturesRequired,\n    publicKeys\n  ).hash160;\n  if (addrBytes !== condition.signer)\n    throw new VerificationError(\n      `Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`\n    );\n\n  return curSigHash;\n}\n\nexport type Authorization = StandardAuthorization | SponsoredAuthorization;\n\nexport interface StandardAuthorization {\n  authType: AuthType.Standard;\n  spendingCondition: SpendingCondition;\n}\n\nexport interface SponsoredAuthorization {\n  authType: AuthType.Sponsored;\n  spendingCondition: SpendingCondition;\n  sponsorSpendingCondition: SpendingCondition;\n}\n\nexport function createStandardAuth(spendingCondition: SpendingCondition): StandardAuthorization {\n  return {\n    authType: AuthType.Standard,\n    spendingCondition,\n  };\n}\n\nexport function createSponsoredAuth(\n  spendingCondition: SpendingCondition,\n  sponsorSpendingCondition?: SpendingCondition\n): Authorization {\n  return {\n    authType: AuthType.Sponsored,\n    spendingCondition,\n    sponsorSpendingCondition: sponsorSpendingCondition\n      ? sponsorSpendingCondition\n      : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0),\n  };\n}\n\nexport function intoInitialSighashAuth(auth: Authorization): Authorization {\n  if (auth.spendingCondition) {\n    switch (auth.authType) {\n      case AuthType.Standard:\n        return createStandardAuth(clearCondition(auth.spendingCondition));\n      case AuthType.Sponsored:\n        return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());\n      default:\n        throw new SigningError('Unexpected authorization type for signing');\n    }\n  }\n\n  throw new Error('Authorization missing SpendingCondition');\n}\n\nexport function verifyOrigin(auth: Authorization, initialSigHash: string): string {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    case AuthType.Sponsored:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    default:\n      throw new SigningError('Invalid origin auth type');\n  }\n}\n\nexport function setFee(auth: Authorization, amount: IntegerType): Authorization {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      const spendingCondition = {\n        ...auth.spendingCondition,\n        fee: intToBigInt(amount, false),\n      };\n      return { ...auth, spendingCondition };\n    case AuthType.Sponsored:\n      const sponsorSpendingCondition = {\n        ...auth.sponsorSpendingCondition,\n        fee: intToBigInt(amount, false),\n      };\n      return { ...auth, sponsorSpendingCondition };\n  }\n}\n\nexport function getFee(auth: Authorization): bigint {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return auth.spendingCondition.fee;\n    case AuthType.Sponsored:\n      return auth.sponsorSpendingCondition.fee;\n  }\n}\n\nexport function setNonce(auth: Authorization, nonce: IntegerType): Authorization {\n  const spendingCondition = {\n    ...auth.spendingCondition,\n    nonce: intToBigInt(nonce, false),\n  };\n\n  return {\n    ...auth,\n    spendingCondition,\n  };\n}\n\nexport function setSponsorNonce(auth: SponsoredAuthorization, nonce: IntegerType): Authorization {\n  const sponsorSpendingCondition = {\n    ...auth.sponsorSpendingCondition,\n    nonce: intToBigInt(nonce, false),\n  };\n\n  return {\n    ...auth,\n    sponsorSpendingCondition,\n  };\n}\n\nexport function setSponsor(\n  auth: SponsoredAuthorization,\n  sponsorSpendingCondition: SpendingConditionOpts\n): Authorization {\n  const sc = {\n    ...sponsorSpendingCondition,\n    nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n    fee: intToBigInt(sponsorSpendingCondition.fee, false),\n  };\n\n  return {\n    ...auth,\n    sponsorSpendingCondition: sc,\n  };\n}\n\nexport function serializeAuthorization(auth: Authorization): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(auth.authType);\n\n  switch (auth.authType) {\n    case AuthType.Standard:\n      bufferArray.push(serializeSpendingCondition(auth.spendingCondition));\n      break;\n    case AuthType.Sponsored:\n      bufferArray.push(serializeSpendingCondition(auth.spendingCondition));\n      bufferArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAuthorization(bufferReader: BufferReader) {\n  const authType = bufferReader.readUInt8Enum(AuthType, n => {\n    throw new DeserializationError(`Could not parse ${n} as AuthType`);\n  });\n\n  let spendingCondition;\n  switch (authType) {\n    case AuthType.Standard:\n      spendingCondition = deserializeSpendingCondition(bufferReader);\n      return createStandardAuth(spendingCondition);\n    case AuthType.Sponsored:\n      spendingCondition = deserializeSpendingCondition(bufferReader);\n      const sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n      return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);\n  }\n}\n","import { Buffer, IntegerType, intToBigInt } from '@stacks/common';\nimport {\n  AnchorMode,\n  AuthType,\n  ChainID,\n  DEFAULT_CHAIN_ID,\n  PayloadType,\n  PostConditionMode,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n} from './constants';\n\nimport {\n  Authorization,\n  deserializeAuthorization,\n  intoInitialSighashAuth,\n  isSingleSig,\n  nextSignature,\n  serializeAuthorization,\n  setFee,\n  setNonce,\n  setSponsor,\n  setSponsorNonce,\n  SpendingConditionOpts,\n  verifyOrigin,\n} from './authorization';\nimport { createTransactionAuthField } from './signature';\n\nimport { BufferArray, cloneDeep, txidFromData } from './utils';\n\nimport { deserializePayload, Payload, PayloadInput, serializePayload } from './payload';\n\nimport { createLPList, deserializeLPList, LengthPrefixedList, serializeLPList } from './types';\n\nimport { isCompressed, StacksPrivateKey, StacksPublicKey } from './keys';\n\nimport { BufferReader } from './bufferReader';\n\nimport { SerializationError, SigningError } from './errors';\n\nexport class StacksTransaction {\n  version: TransactionVersion;\n  chainId: ChainID;\n  auth: Authorization;\n  anchorMode: AnchorMode;\n  payload: Payload;\n  postConditionMode: PostConditionMode;\n  postConditions: LengthPrefixedList;\n\n  constructor(\n    version: TransactionVersion,\n    auth: Authorization,\n    payload: PayloadInput,\n    postConditions?: LengthPrefixedList,\n    postConditionMode?: PostConditionMode,\n    anchorMode?: AnchorMode,\n    chainId?: ChainID\n  ) {\n    this.version = version;\n    this.auth = auth;\n    if ('amount' in payload) {\n      this.payload = {\n        ...payload,\n        amount: intToBigInt(payload.amount, false),\n      };\n    } else {\n      this.payload = payload;\n    }\n    this.chainId = chainId ?? DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;\n    this.postConditions = postConditions ?? createLPList([]);\n\n    if (anchorMode) {\n      this.anchorMode = anchorMode;\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.PoisonMicroblock: {\n          this.anchorMode = AnchorMode.OnChainOnly;\n          break;\n        }\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.TokenTransfer: {\n          this.anchorMode = AnchorMode.Any;\n          break;\n        }\n      }\n    }\n  }\n\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyOrigin(): string {\n    return verifyOrigin(this.auth, this.verifyBegin());\n  }\n\n  signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n\n  signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.authType === AuthType.Sponsored) {\n      return this.signAndAppend(\n        this.auth.sponsorSpendingCondition,\n        sigHash,\n        AuthType.Sponsored,\n        privateKey\n      );\n    } else {\n      throw new Error('\"auth.sponsorSpendingCondition\" is undefined');\n    }\n  }\n\n  appendPubkey(publicKey: StacksPublicKey) {\n    const cond = this.auth.spendingCondition;\n    if (cond && !isSingleSig(cond)) {\n      const compressed = isCompressed(publicKey);\n      cond.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          publicKey\n        )\n      );\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n\n  signAndAppend(\n    condition: SpendingConditionOpts,\n    curSigHash: string,\n    authType: AuthType,\n    privateKey: StacksPrivateKey\n  ): string {\n    const { nextSig, nextSigHash } = nextSignature(\n      curSigHash,\n      authType,\n      condition.fee,\n      condition.nonce,\n      privateKey\n    );\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      const compressed = privateKey.data.toString('hex').endsWith('01');\n      condition.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          nextSig\n        )\n      );\n    }\n\n    return nextSigHash;\n  }\n\n  txid(): string {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n\n  setSponsor(sponsorSpendingCondition: SpendingConditionOpts) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsor(this.auth, sponsorSpendingCondition);\n  }\n\n  /**\n   * Set the total fee to be paid for this transaction\n   *\n   * @param fee - the fee amount in microstacks\n   */\n  setFee(amount: IntegerType) {\n    this.auth = setFee(this.auth, amount);\n  }\n\n  /**\n   * Set the transaction nonce\n   *\n   * @param nonce - the nonce value\n   */\n  setNonce(nonce: IntegerType) {\n    this.auth = setNonce(this.auth, nonce);\n  }\n\n  /**\n   * Set the transaction sponsor nonce\n   *\n   * @param nonce - the sponsor nonce value\n   */\n  setSponsorNonce(nonce: IntegerType) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsorNonce(this.auth, nonce);\n  }\n\n  serialize(): Buffer {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n\n    const bufferArray: BufferArray = new BufferArray();\n\n    bufferArray.appendByte(this.version);\n    const chainIdBuffer = Buffer.alloc(4);\n    chainIdBuffer.writeUInt32BE(this.chainId, 0);\n    bufferArray.push(chainIdBuffer);\n    bufferArray.push(serializeAuthorization(this.auth));\n    bufferArray.appendByte(this.anchorMode);\n    bufferArray.appendByte(this.postConditionMode);\n    bufferArray.push(serializeLPList(this.postConditions));\n    bufferArray.push(serializePayload(this.payload));\n\n    return bufferArray.concatBuffer();\n  }\n}\n\n/**\n * @param data Buffer or hex string\n */\nexport function deserializeTransaction(data: BufferReader | Buffer | string) {\n  let bufferReader: BufferReader;\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bufferReader = new BufferReader(Buffer.from(data.slice(2), 'hex'));\n    } else {\n      bufferReader = new BufferReader(Buffer.from(data, 'hex'));\n    }\n  } else if (Buffer.isBuffer(data)) {\n    bufferReader = new BufferReader(data);\n  } else {\n    bufferReader = data;\n  }\n  const version = bufferReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bufferReader.readUInt32BE();\n  const auth = deserializeAuthorization(bufferReader);\n  const anchorMode = bufferReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bufferReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bufferReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bufferReader);\n\n  return new StacksTransaction(\n    version,\n    auth,\n    payload,\n    postConditions,\n    postConditionMode,\n    anchorMode,\n    chainId\n  );\n}\n","import { IntegerType, intToBigInt } from '@stacks/common';\nimport {\n  PostConditionType,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  StacksMessageType,\n} from './constants';\n\nimport {\n  AssetInfo,\n  PostConditionPrincipal,\n  parseAssetInfoString,\n  parsePrincipalString,\n  STXPostCondition,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n} from './postcondition-types';\n\nimport { ClarityValue } from './clarity';\n\nexport function createSTXPostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.STX,\n    principal,\n    conditionCode,\n    amount: intToBigInt(amount, false),\n  };\n}\n\nexport function createFungiblePostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n  if (typeof assetInfo === 'string') {\n    assetInfo = parseAssetInfoString(assetInfo);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.Fungible,\n    principal,\n    conditionCode,\n    amount: intToBigInt(amount, false),\n    assetInfo,\n  };\n}\n\nexport function createNonFungiblePostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n  if (typeof assetInfo === 'string') {\n    assetInfo = parseAssetInfoString(assetInfo);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.NonFungible,\n    principal,\n    conditionCode,\n    assetInfo,\n    assetName,\n  };\n}\n","import { Buffer } from '@stacks/common';\nimport {\n  BooleanCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseErrorCV,\n  ResponseOkCV,\n  ListCV,\n  TupleCV,\n  StringAsciiCV,\n  StringUtf8CV,\n  NoneCV,\n  SomeCV,\n} from '.';\n\nimport { principalToString } from './types/principalCV';\nimport { ClarityType } from './constants';\n\nexport type ClarityValue =\n  | BooleanCV\n  | BufferCV\n  | IntCV\n  | UIntCV\n  | StandardPrincipalCV\n  | ContractPrincipalCV\n  | ResponseErrorCV\n  | ResponseOkCV\n  | NoneCV\n  | SomeCV\n  | ListCV\n  | TupleCV\n  | StringAsciiCV\n  | StringUtf8CV;\n\nexport function cvToString(val: ClarityValue, encoding: 'tryAscii' | 'hex' = 'hex'): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n    case ClarityType.BoolFalse:\n      return 'false';\n    case ClarityType.Int:\n      return val.value.toString();\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = val.buffer.toString('ascii');\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n      return `0x${val.buffer.toString('hex')}`;\n    case ClarityType.OptionalNone:\n      return 'none';\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\n\n/**\n * @param strictJsonCompat If true then ints and uints are returned as JSON serializable numbers when\n * less than or equal to 53 bit length, otherwise string wrapped integers when larger than 53 bits.\n * If false, they are returned as js native `bigint`s which are _not_ JSON serializable.\n */\nexport function cvToValue(val: ClarityValue, strictJsonCompat: boolean = false): any {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n    case ClarityType.BoolFalse:\n      return false;\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      if (strictJsonCompat) {\n        return val.value.toString();\n      } else {\n        return val.value;\n      }\n    case ClarityType.Buffer:\n      return `0x${val.buffer.toString('hex')}`;\n    case ClarityType.OptionalNone:\n      return null;\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n    case ClarityType.Tuple:\n      const result: { [key: string]: any } = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n    case ClarityType.StringASCII:\n      return val.data;\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\n\nexport function cvToJSON(val: ClarityValue): any {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: false };\n    case ClarityType.ResponseOk:\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: true };\n    default:\n      return { type: getCVTypeString(val), value: cvToValue(val, true) };\n  }\n}\n\nexport function getCVTypeString(val: ClarityValue): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n    case ClarityType.Int:\n      return 'int';\n    case ClarityType.UInt:\n      return 'uint';\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n    case ClarityType.List:\n      return `(list ${val.list.length} ${\n        val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'\n      })`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${getCVTypeString(val.data[key])})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `(string-ascii ${Buffer.from(val.data, 'ascii').length})`;\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${Buffer.from(val.data, 'utf8').length})`;\n  }\n}\n","import 'cross-fetch/polyfill';\nconst defaultFetchOpts = {\n    referrerPolicy: 'origin',\n};\nexport const getFetchOptions = () => {\n    return defaultFetchOpts;\n};\nexport const setFetchOptions = (ops) => {\n    return Object.assign(defaultFetchOpts, ops);\n};\nexport async function fetchWrapper(input, init) {\n    const fetchOpts = {};\n    Object.assign(fetchOpts, init, defaultFetchOpts);\n    const fetchResult = await fetch(input, fetchOpts);\n    return fetchResult;\n}\nexport function hostMatches(host, pattern) {\n    if (typeof pattern === 'string')\n        return pattern === host;\n    return pattern.exec(host);\n}\nexport function createApiKeyMiddleware({ apiKey, host = /(.*)api(.*)\\.stacks\\.co$/i, httpHeader = 'x-api-key', }) {\n    return {\n        pre: context => {\n            const reqUrl = new URL(context.url);\n            if (!hostMatches(reqUrl.host, host))\n                return;\n            const headers = new Headers(context.init.headers);\n            headers.set(httpHeader, apiKey);\n            context.init.headers = headers;\n        },\n    };\n}\nfunction argsForCreateFetchFn(args) {\n    let fetchLib = fetchWrapper;\n    let middlewares = [];\n    if (args.length > 0 && typeof args[0] === 'function') {\n        fetchLib = args.shift();\n    }\n    if (args.length > 0) {\n        middlewares = args;\n    }\n    return { fetchLib, middlewares };\n}\nexport function createFetchFn(...args) {\n    const { fetchLib, middlewares } = argsForCreateFetchFn(args);\n    const fetchFn = async (url, init) => {\n        var _a;\n        let fetchParams = { url, init: init !== null && init !== void 0 ? init : {} };\n        for (const middleware of middlewares) {\n            if (typeof middleware.pre === 'function') {\n                const result = await Promise.resolve(middleware.pre(Object.assign({ fetch: fetchLib }, fetchParams)));\n                fetchParams = result !== null && result !== void 0 ? result : fetchParams;\n            }\n        }\n        let response = await fetchLib(fetchParams.url, fetchParams.init);\n        for (const middleware of middlewares) {\n            if (typeof middleware.post === 'function') {\n                const result = await Promise.resolve(middleware.post({\n                    fetch: fetchLib,\n                    url: fetchParams.url,\n                    init: fetchParams.init,\n                    response: (_a = response === null || response === void 0 ? void 0 : response.clone()) !== null && _a !== void 0 ? _a : response,\n                }));\n                response = result !== null && result !== void 0 ? result : response;\n            }\n        }\n        return response;\n    };\n    return fetchFn;\n}\n//# sourceMappingURL=fetch.js.map","import { TransactionVersion, ChainID } from '@stacks/common';\nimport { createFetchFn } from './fetch';\nexport const HIRO_MAINNET_DEFAULT = 'https://stacks-node-api.mainnet.stacks.co';\nexport const HIRO_TESTNET_DEFAULT = 'https://stacks-node-api.testnet.stacks.co';\nexport const HIRO_MOCKNET_DEFAULT = 'http://localhost:3999';\nexport const StacksNetworks = ['mainnet', 'testnet'];\nexport class StacksNetwork {\n    constructor(networkConfig) {\n        var _a;\n        this.version = TransactionVersion.Mainnet;\n        this.chainId = ChainID.Mainnet;\n        this.bnsLookupUrl = 'https://stacks-node-api.mainnet.stacks.co';\n        this.broadcastEndpoint = '/v2/transactions';\n        this.transferFeeEstimateEndpoint = '/v2/fees/transfer';\n        this.transactionFeeEstimateEndpoint = '/v2/fees/transaction';\n        this.accountEndpoint = '/v2/accounts';\n        this.contractAbiEndpoint = '/v2/contracts/interface';\n        this.readOnlyFunctionCallEndpoint = '/v2/contracts/call-read';\n        this.isMainnet = () => this.version === TransactionVersion.Mainnet;\n        this.getBroadcastApiUrl = () => `${this.coreApiUrl}${this.broadcastEndpoint}`;\n        this.getTransferFeeEstimateApiUrl = () => `${this.coreApiUrl}${this.transferFeeEstimateEndpoint}`;\n        this.getTransactionFeeEstimateApiUrl = () => `${this.coreApiUrl}${this.transactionFeeEstimateEndpoint}`;\n        this.getAccountApiUrl = (address) => `${this.coreApiUrl}${this.accountEndpoint}/${address}?proof=0`;\n        this.getAbiApiUrl = (address, contract) => `${this.coreApiUrl}${this.contractAbiEndpoint}/${address}/${contract}`;\n        this.getReadOnlyFunctionCallApiUrl = (contractAddress, contractName, functionName) => `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}/${contractAddress}/${contractName}/${encodeURIComponent(functionName)}`;\n        this.getInfoUrl = () => `${this.coreApiUrl}/v2/info`;\n        this.getBlockTimeInfoUrl = () => `${this.coreApiUrl}/extended/v1/info/network_block_times`;\n        this.getPoxInfoUrl = () => `${this.coreApiUrl}/v2/pox`;\n        this.getRewardsUrl = (address, options) => {\n            let url = `${this.coreApiUrl}/extended/v1/burnchain/rewards/${address}`;\n            if (options) {\n                url = `${url}?limit=${options.limit}&offset=${options.offset}`;\n            }\n            return url;\n        };\n        this.getRewardsTotalUrl = (address) => `${this.coreApiUrl}/extended/v1/burnchain/rewards/${address}/total`;\n        this.getRewardHoldersUrl = (address, options) => {\n            let url = `${this.coreApiUrl}/extended/v1/burnchain/reward_slot_holders/${address}`;\n            if (options) {\n                url = `${url}?limit=${options.limit}&offset=${options.offset}`;\n            }\n            return url;\n        };\n        this.getStackerInfoUrl = (contractAddress, contractName) => `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}\n    ${contractAddress}/${contractName}/get-stacker-info`;\n        this.coreApiUrl = networkConfig.url;\n        this.fetchFn = (_a = networkConfig.fetchFn) !== null && _a !== void 0 ? _a : createFetchFn();\n    }\n    getNameInfo(fullyQualifiedName) {\n        const nameLookupURL = `${this.bnsLookupUrl}/v1/names/${fullyQualifiedName}`;\n        return this.fetchFn(nameLookupURL)\n            .then(resp => {\n            if (resp.status === 404) {\n                throw new Error('Name not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then(nameInfo => {\n            if (nameInfo.address) {\n                return Object.assign({}, nameInfo, { address: nameInfo.address });\n            }\n            else {\n                return nameInfo;\n            }\n        });\n    }\n}\nStacksNetwork.fromName = (networkName) => {\n    switch (networkName) {\n        case 'mainnet':\n            return new StacksMainnet();\n        case 'testnet':\n            return new StacksTestnet();\n        default:\n            throw new Error(`Invalid network name provided. Must be one of the following: ${StacksNetworks.join(', ')}`);\n    }\n};\nStacksNetwork.fromNameOrNetwork = (network) => {\n    if (typeof network !== 'string' && 'version' in network) {\n        return network;\n    }\n    return StacksNetwork.fromName(network);\n};\nexport class StacksMainnet extends StacksNetwork {\n    constructor(opts) {\n        var _a;\n        super({\n            url: (_a = opts === null || opts === void 0 ? void 0 : opts.url) !== null && _a !== void 0 ? _a : HIRO_MAINNET_DEFAULT,\n            fetchFn: opts === null || opts === void 0 ? void 0 : opts.fetchFn,\n        });\n        this.version = TransactionVersion.Mainnet;\n        this.chainId = ChainID.Mainnet;\n    }\n}\nexport class StacksTestnet extends StacksNetwork {\n    constructor(opts) {\n        var _a;\n        super({\n            url: (_a = opts === null || opts === void 0 ? void 0 : opts.url) !== null && _a !== void 0 ? _a : HIRO_TESTNET_DEFAULT,\n            fetchFn: opts === null || opts === void 0 ? void 0 : opts.fetchFn,\n        });\n        this.version = TransactionVersion.Testnet;\n        this.chainId = ChainID.Testnet;\n    }\n}\nexport class StacksMocknet extends StacksNetwork {\n    constructor(opts) {\n        var _a;\n        super({\n            url: (_a = opts === null || opts === void 0 ? void 0 : opts.url) !== null && _a !== void 0 ? _a : HIRO_MOCKNET_DEFAULT,\n            fetchFn: opts === null || opts === void 0 ? void 0 : opts.fetchFn,\n        });\n        this.version = TransactionVersion.Testnet;\n        this.chainId = ChainID.Testnet;\n    }\n}\n//# sourceMappingURL=network.js.map","import { Buffer } from '@stacks/common';\nimport { cloneDeep } from './utils';\nimport {\n  ClarityValue,\n  uintCV,\n  intCV,\n  contractPrincipalCV,\n  standardPrincipalCV,\n  noneCV,\n  bufferCV,\n  falseCV,\n  trueCV,\n  ClarityType,\n  getCVTypeString,\n  bufferCVFromString,\n} from './clarity';\nimport { ContractCallPayload } from './payload';\nimport { NotImplementedError } from './errors';\nimport { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';\n\n// From https://github.com/blockstack/stacks-blockchain-sidecar/blob/master/src/event-stream/contract-abi.ts\n\nexport type ClarityAbiTypeBuffer = { buffer: { length: number } };\nexport type ClarityAbiTypeStringAscii = { 'string-ascii': { length: number } };\nexport type ClarityAbiTypeStringUtf8 = { 'string-utf8': { length: number } };\nexport type ClarityAbiTypeResponse = { response: { ok: ClarityAbiType; error: ClarityAbiType } };\nexport type ClarityAbiTypeOptional = { optional: ClarityAbiType };\nexport type ClarityAbiTypeTuple = { tuple: { name: string; type: ClarityAbiType }[] };\nexport type ClarityAbiTypeList = { list: { type: ClarityAbiType; length: number } };\n\nexport type ClarityAbiTypeUInt128 = 'uint128';\nexport type ClarityAbiTypeInt128 = 'int128';\nexport type ClarityAbiTypeBool = 'bool';\nexport type ClarityAbiTypePrincipal = 'principal';\nexport type ClarityAbiTypeTraitReference = 'trait_reference';\nexport type ClarityAbiTypeNone = 'none';\n\nexport type ClarityAbiTypePrimitive =\n  | ClarityAbiTypeUInt128\n  | ClarityAbiTypeInt128\n  | ClarityAbiTypeBool\n  | ClarityAbiTypePrincipal\n  | ClarityAbiTypeTraitReference\n  | ClarityAbiTypeNone;\n\nexport type ClarityAbiType =\n  | ClarityAbiTypePrimitive\n  | ClarityAbiTypeBuffer\n  | ClarityAbiTypeResponse\n  | ClarityAbiTypeOptional\n  | ClarityAbiTypeTuple\n  | ClarityAbiTypeList\n  | ClarityAbiTypeStringAscii\n  | ClarityAbiTypeStringUtf8\n  | ClarityAbiTypeTraitReference;\n\nexport enum ClarityAbiTypeId {\n  ClarityAbiTypeUInt128 = 1,\n  ClarityAbiTypeInt128 = 2,\n  ClarityAbiTypeBool = 3,\n  ClarityAbiTypePrincipal = 4,\n  ClarityAbiTypeNone = 5,\n  ClarityAbiTypeBuffer = 6,\n  ClarityAbiTypeResponse = 7,\n  ClarityAbiTypeOptional = 8,\n  ClarityAbiTypeTuple = 9,\n  ClarityAbiTypeList = 10,\n  ClarityAbiTypeStringAscii = 11,\n  ClarityAbiTypeStringUtf8 = 12,\n  ClarityAbiTypeTraitReference = 13,\n}\n\nexport const isClarityAbiPrimitive = (val: ClarityAbiType): val is ClarityAbiTypePrimitive =>\n  typeof val === 'string';\nexport const isClarityAbiBuffer = (val: ClarityAbiType): val is ClarityAbiTypeBuffer =>\n  (val as ClarityAbiTypeBuffer).buffer !== undefined;\nexport const isClarityAbiStringAscii = (val: ClarityAbiType): val is ClarityAbiTypeStringAscii =>\n  (val as ClarityAbiTypeStringAscii)['string-ascii'] !== undefined;\nexport const isClarityAbiStringUtf8 = (val: ClarityAbiType): val is ClarityAbiTypeStringUtf8 =>\n  (val as ClarityAbiTypeStringUtf8)['string-utf8'] !== undefined;\nexport const isClarityAbiResponse = (val: ClarityAbiType): val is ClarityAbiTypeResponse =>\n  (val as ClarityAbiTypeResponse).response !== undefined;\nexport const isClarityAbiOptional = (val: ClarityAbiType): val is ClarityAbiTypeOptional =>\n  (val as ClarityAbiTypeOptional).optional !== undefined;\nexport const isClarityAbiTuple = (val: ClarityAbiType): val is ClarityAbiTypeTuple =>\n  (val as ClarityAbiTypeTuple).tuple !== undefined;\nexport const isClarityAbiList = (val: ClarityAbiType): val is ClarityAbiTypeList =>\n  (val as ClarityAbiTypeList).list !== undefined;\n\nexport type ClarityAbiTypeUnion =\n  | { id: ClarityAbiTypeId.ClarityAbiTypeUInt128; type: ClarityAbiTypeUInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeInt128; type: ClarityAbiTypeInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBool; type: ClarityAbiTypeBool }\n  | { id: ClarityAbiTypeId.ClarityAbiTypePrincipal; type: ClarityAbiTypePrincipal }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference; type: ClarityAbiTypeTraitReference }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeNone; type: ClarityAbiTypeNone }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBuffer; type: ClarityAbiTypeBuffer }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeResponse; type: ClarityAbiTypeResponse }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeOptional; type: ClarityAbiTypeOptional }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTuple; type: ClarityAbiTypeTuple }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeList; type: ClarityAbiTypeList }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii; type: ClarityAbiTypeStringAscii }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8; type: ClarityAbiTypeStringUtf8 };\n\nexport function getTypeUnion(val: ClarityAbiType): ClarityAbiTypeUnion {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'uint128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };\n    } else if (val === 'int128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };\n    } else if (val === 'bool') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };\n    } else if (val === 'principal') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };\n    } else if (val === 'trait_reference') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };\n    } else if (val === 'none') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };\n    } else {\n      throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);\n    }\n  } else if (isClarityAbiBuffer(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };\n  } else if (isClarityAbiResponse(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };\n  } else if (isClarityAbiOptional(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };\n  } else if (isClarityAbiTuple(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };\n  } else if (isClarityAbiList(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };\n  } else if (isClarityAbiStringAscii(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };\n  } else if (isClarityAbiStringUtf8(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };\n  } else {\n    throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);\n  }\n}\n\nfunction encodeClarityValue(type: ClarityAbiType, val: string): ClarityValue;\nfunction encodeClarityValue(type: ClarityAbiTypeUnion, val: string): ClarityValue;\nfunction encodeClarityValue(\n  input: ClarityAbiTypeUnion | ClarityAbiType,\n  val: string\n): ClarityValue {\n  let union: ClarityAbiTypeUnion;\n  if ((input as ClarityAbiTypeUnion).id !== undefined) {\n    union = input as ClarityAbiTypeUnion;\n  } else {\n    union = getTypeUnion(input as ClarityAbiType);\n  }\n  switch (union.id) {\n    case ClarityAbiTypeId.ClarityAbiTypeUInt128:\n      return uintCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeInt128:\n      return intCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeBool:\n      if (val === 'false' || val === '0') return falseCV();\n      else if (val === 'true' || val === '1') return trueCV();\n      else throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);\n    case ClarityAbiTypeId.ClarityAbiTypePrincipal:\n      if (val.includes('.')) {\n        const [addr, name] = val.split('.');\n        return contractPrincipalCV(addr, name);\n      } else {\n        return standardPrincipalCV(val);\n      }\n    case ClarityAbiTypeId.ClarityAbiTypeTraitReference:\n      const [addr, name] = val.split('.');\n      return contractPrincipalCV(addr, name);\n    case ClarityAbiTypeId.ClarityAbiTypeNone:\n      return noneCV();\n    case ClarityAbiTypeId.ClarityAbiTypeBuffer:\n      return bufferCV(Buffer.from(val, 'utf8'));\n    case ClarityAbiTypeId.ClarityAbiTypeStringAscii:\n      return stringAsciiCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:\n      return stringUtf8CV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeResponse:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeOptional:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeTuple:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeList:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    default:\n      throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);\n  }\n}\nexport { encodeClarityValue };\n\nexport function getTypeString(val: ClarityAbiType): string {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'int128') {\n      return 'int';\n    } else if (val === 'uint128') {\n      return 'uint';\n    }\n    return val;\n  } else if (isClarityAbiBuffer(val)) {\n    return `(buff ${val.buffer.length})`;\n  } else if (isClarityAbiStringAscii(val)) {\n    return `(string-ascii ${val['string-ascii'].length})`;\n  } else if (isClarityAbiStringUtf8(val)) {\n    return `(string-utf8 ${val['string-utf8'].length})`;\n  } else if (isClarityAbiResponse(val)) {\n    return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;\n  } else if (isClarityAbiOptional(val)) {\n    return `(optional ${getTypeString(val.optional)})`;\n  } else if (isClarityAbiTuple(val)) {\n    return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;\n  } else if (isClarityAbiList(val)) {\n    return `(list ${val.list.length} ${getTypeString(val.list.type)})`;\n  } else {\n    throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);\n  }\n}\n\nexport interface ClarityAbiFunction {\n  name: string;\n  access: 'private' | 'public' | 'read_only';\n  args: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  outputs: {\n    type: ClarityAbiType;\n  };\n}\n\nexport function abiFunctionToString(func: ClarityAbiFunction): string {\n  const access = func.access === 'read_only' ? 'read-only' : func.access;\n  return `(define-${access} (${func.name} ${func.args\n    .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)\n    .join(' ')}))`;\n}\n\nexport interface ClarityAbiVariable {\n  name: string;\n  access: 'variable' | 'constant';\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbiMap {\n  name: string;\n  key: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  value: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n}\n\nexport interface ClarityAbiTypeFungibleToken {\n  name: string;\n}\n\nexport interface ClarityAbiTypeNonFungibleToken {\n  name: string;\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbi {\n  functions: ClarityAbiFunction[];\n  variables: ClarityAbiVariable[];\n  maps: ClarityAbiMap[];\n  fungible_tokens: ClarityAbiTypeFungibleToken[];\n  non_fungible_tokens: ClarityAbiTypeNonFungibleToken[];\n}\n\nfunction matchType(cv: ClarityValue, abiType: ClarityAbiType): boolean {\n  const union = getTypeUnion(abiType);\n\n  switch (cv.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;\n    case ClarityType.Int:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;\n    case ClarityType.UInt:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;\n    case ClarityType.Buffer:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&\n        union.type.buffer.length >= cv.buffer.length\n      );\n    case ClarityType.StringASCII:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&\n        union.type['string-ascii'].length >= cv.data.length\n      );\n    case ClarityType.StringUTF8:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&\n        union.type['string-utf8'].length >= cv.data.length\n      );\n    case ClarityType.OptionalNone:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional\n      );\n    case ClarityType.OptionalSome:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&\n        matchType(cv.value, union.type.optional)\n      );\n    case ClarityType.ResponseErr:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.error)\n      );\n    case ClarityType.ResponseOk:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.ok)\n      );\n    case ClarityType.PrincipalContract:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference\n      );\n    case ClarityType.PrincipalStandard:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;\n    case ClarityType.List:\n      return (\n        union.id == ClarityAbiTypeId.ClarityAbiTypeList &&\n        union.type.list.length >= cv.list.length &&\n        cv.list.every(val => matchType(val, union.type.list.type))\n      );\n    case ClarityType.Tuple:\n      if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {\n        const tuple = cloneDeep(cv.data);\n        for (let i = 0; i < union.type.tuple.length; i++) {\n          const abiTupleEntry = union.type.tuple[i];\n          const key = abiTupleEntry.name;\n          const val = tuple[key];\n\n          // if key exists in cv tuple, check if its type matches the abi\n          // return false if key doesn't exist\n          if (val) {\n            if (!matchType(val, abiTupleEntry.type)) {\n              return false;\n            }\n            delete tuple[key];\n          } else {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n}\n\n/**\n * Validates a contract-call payload with a contract ABI\n *\n * @param {ContractCallPayload} payload - a contract-call payload\n * @param {ClarityAbi} abi - a contract ABI\n *\n * @returns {boolean} true if the payloads functionArgs type check against those in the ABI\n */\nexport function validateContractCall(payload: ContractCallPayload, abi: ClarityAbi): boolean {\n  const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);\n  if (filtered.length === 1) {\n    const abiFunc = filtered[0];\n    const abiArgs = abiFunc.args;\n\n    if (payload.functionArgs.length !== abiArgs.length) {\n      throw new Error(\n        `Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`\n      );\n    }\n\n    for (let i = 0; i < payload.functionArgs.length; i++) {\n      const payloadArg = payload.functionArgs[i];\n      const abiArg = abiArgs[i];\n\n      if (!matchType(payloadArg, abiArg.type)) {\n        const argNum = i + 1;\n        throw new Error(\n          `Clarity function \\`${\n            payload.functionName.content\n          }\\` expects argument ${argNum} to be of type ${getTypeString(\n            abiArg.type\n          )}, not ${getCVTypeString(payloadArg)}`\n        );\n      }\n    }\n\n    return true;\n  } else if (filtered.length === 0) {\n    throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);\n  } else {\n    throw new Error(\n      `Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`\n    );\n  }\n}\n\n/**\n * Convert string input to Clarity value based on contract ABI data. Only handles Clarity\n * primitives and buffers. Responses, optionals, tuples and lists are not supported.\n *\n * @param {string} input - string to be parsed into Clarity value\n * @param {ClarityAbiType} type - the contract function argument object\n *\n * @returns {ClarityValue} returns a Clarity value\n */\nexport function parseToCV(input: string, type: ClarityAbiType): ClarityValue {\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(input);\n    } else if (type === 'int128') {\n      return intCV(input);\n    } else if (type === 'bool') {\n      if (input.toLowerCase() === 'true') {\n        return trueCV();\n      } else if (input.toLowerCase() === 'false') {\n        return falseCV();\n      } else {\n        throw new Error(`Invalid bool value: ${input}`);\n      }\n    } else if (type === 'principal') {\n      if (input.includes('.')) {\n        const [address, contractName] = input.split('.');\n        return contractPrincipalCV(address, contractName);\n      } else {\n        return standardPrincipalCV(input);\n      }\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    const inputLength = Buffer.from(input).byteLength;\n    if (inputLength > type.buffer.length) {\n      throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);\n    }\n    return bufferCVFromString(input);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}\n","import { StacksTransaction } from './transaction';\n\nimport { StacksPrivateKey, StacksPublicKey } from './keys';\nimport { isSingleSig, nextVerification, SpendingConditionOpts } from './authorization';\nimport { cloneDeep } from './utils';\nimport { AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\n\nexport class TransactionSigner {\n  transaction: StacksTransaction;\n  sigHash: string;\n  originDone: boolean;\n  checkOversign: boolean;\n  checkOverlap: boolean;\n\n  constructor(transaction: StacksTransaction) {\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n\n    // If multi-sig spending condition exists, iterate over\n    // auth fields and reconstruct sigHash\n    const spendingCondition = transaction.auth.spendingCondition;\n    if (spendingCondition && !isSingleSig(spendingCondition)) {\n      if (\n        spendingCondition.fields.filter(\n          field => field.contents.type === StacksMessageType.MessageSignature\n        ).length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('SpendingCondition has more signatures than are expected');\n      }\n\n      spendingCondition.fields.forEach(field => {\n        if (field.contents.type === StacksMessageType.MessageSignature) {\n          const signature = field.contents;\n          const nextVerify = nextVerification(\n            this.sigHash,\n            transaction.auth.authType,\n            spendingCondition.fee,\n            spendingCondition.nonce,\n            PubKeyEncoding.Compressed, // always compressed for multisig\n            signature\n          );\n          this.sigHash = nextVerify.nextSigHash;\n        }\n      });\n    }\n  }\n\n  static createSponsorSigner(\n    transaction: StacksTransaction,\n    spendingCondition: SpendingConditionOpts\n  ) {\n    if (transaction.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n    }\n\n    const tx: StacksTransaction = cloneDeep(transaction);\n    tx.setSponsor(spendingCondition);\n    const originSigHash = tx.verifyOrigin();\n    const signer = new this(tx);\n    signer.originDone = true;\n    signer.sigHash = originSigHash;\n    signer.checkOversign = true;\n    signer.checkOverlap = true;\n    return signer;\n  }\n\n  signOrigin(privateKey: StacksPrivateKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw new SigningError('Cannot sign origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n      const spendingCondition = this.transaction.auth.spendingCondition;\n      if (\n        this.checkOversign &&\n        spendingCondition.fields.filter(\n          field => field.contents.type === StacksMessageType.MessageSignature\n        ).length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('Origin would have too many signatures');\n      }\n    }\n\n    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n  }\n\n  appendOrigin(publicKey: StacksPublicKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw Error('Cannot append public key to origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new Error('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    this.transaction.appendPubkey(publicKey);\n  }\n\n  signSponsor(privateKey: StacksPrivateKey) {\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.authType !== AuthType.Sponsored) {\n      throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n    }\n\n    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n    this.originDone = true;\n  }\n\n  getTxInComplete(): StacksTransaction {\n    return cloneDeep(this.transaction);\n  }\n\n  resume(transaction: StacksTransaction) {\n    this.transaction = cloneDeep(transaction);\n    this.sigHash = transaction.signBegin();\n  }\n}\n","import { Buffer, IntegerType, intToBigInt } from '@stacks/common';\nimport {\n  StacksNetwork,\n  StacksMainnet,\n  StacksNetworkName,\n  StacksTestnet,\n  FetchFn,\n  createFetchFn,\n} from '@stacks/network';\nimport { c32address } from 'c32check';\nimport {\n  Authorization,\n  createMultiSigSpendingCondition,\n  createSingleSigSpendingCondition,\n  createSponsoredAuth,\n  createStandardAuth,\n  SpendingCondition,\n  MultiSigSpendingCondition,\n} from './authorization';\nimport { ClarityValue, PrincipalCV } from './clarity';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  AnchorMode,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  PayloadType,\n  PostConditionMode,\n  SingleSigHashMode,\n  TransactionVersion,\n  TxRejectedReason,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  StacksMessageType,\n} from './constants';\nimport { ClarityAbi, validateContractCall } from './contract-abi';\nimport {\n  createStacksPrivateKey,\n  createStacksPublicKey,\n  getPublicKey,\n  pubKeyfromPrivKey,\n  publicKeyFromBuffer,\n  publicKeyToAddress,\n  publicKeyToString,\n} from './keys';\nimport {\n  createContractCallPayload,\n  createSmartContractPayload,\n  createTokenTransferPayload,\n  Payload,\n  serializePayload,\n} from './payload';\nimport {\n  createFungiblePostCondition,\n  createNonFungiblePostCondition,\n  createSTXPostCondition,\n} from './postcondition';\nimport {\n  AssetInfo,\n  createContractPrincipal,\n  createStandardPrincipal,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n  PostCondition,\n  STXPostCondition,\n} from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\n\n/**\n * Lookup the nonce for an address from a core node\n *\n * @param {string} address - the c32check address to look up\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to look up address on\n *\n * @return a promise that resolves to an integer\n */\nexport async function getNonce(\n  address: string,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getAccountApiUrl(address);\n\n  const response = await derivedNetwork.fetchFn(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const responseText = await response.text();\n  const result = JSON.parse(responseText) as { nonce: string };\n  return BigInt(result.nonce);\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a token transfer\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateTransfer(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(\n      `Transaction fee estimation only possible with ${\n        PayloadType[PayloadType.TokenTransfer]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\n\ninterface FeeEstimation {\n  fee: number;\n  fee_rate: number;\n}\ninterface FeeEstimateResponse {\n  cost_scalar_change_by_byte: bigint;\n  estimated_cost: {\n    read_count: bigint;\n    read_length: bigint;\n    runtime: bigint;\n    write_count: bigint;\n    write_length: bigint;\n  };\n  estimated_cost_scalar: bigint;\n  estimations: [FeeEstimation, FeeEstimation, FeeEstimation];\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a Stacks transaction\n *\n * @param {StacksTransaction} transaction - the transaction to estimate fees for\n * @param {number} estimatedLen - is an optional argument that provides the endpoint with an\n * estimation of the final length (in bytes) of the transaction, including any post-conditions\n * and signatures\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction fees for\n *\n * @return a promise that resolves to FeeEstimate\n */\nexport async function estimateTransaction(\n  transactionPayload: Payload,\n  estimatedLen?: number,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<[FeeEstimation, FeeEstimation, FeeEstimation]> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      transaction_payload: serializePayload(transactionPayload).toString('hex'),\n      ...(estimatedLen ? { estimated_len: estimatedLen } : {}),\n    }),\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, options);\n\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  const data: FeeEstimateResponse = await response.json();\n  return data.estimations;\n}\n\nexport type SerializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Serialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type DeserializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Deserialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type SignatureValidationRejection = {\n  error: string;\n  reason: TxRejectedReason.SignatureValidation;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type BadNonceRejection = {\n  error: string;\n  reason: TxRejectedReason.BadNonce;\n  reason_data: {\n    expected: number;\n    actual: number;\n    is_origin: boolean;\n    principal: boolean;\n  };\n  txid: string;\n};\n\nexport type FeeTooLowRejection = {\n  error: string;\n  reason: TxRejectedReason.FeeTooLow;\n  reason_data: {\n    expected: number;\n    actual: number;\n  };\n  txid: string;\n};\n\nexport type NotEnoughFundsRejection = {\n  error: string;\n  reason: TxRejectedReason.NotEnoughFunds;\n  reason_data: {\n    expected: string;\n    actual: string;\n  };\n  txid: string;\n};\n\nexport type NoSuchContractRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchContract;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoSuchPublicFunctionRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchPublicFunction;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadFunctionArgumentRejection = {\n  error: string;\n  reason: TxRejectedReason.BadFunctionArgument;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ContractAlreadyExistsRejection = {\n  error: string;\n  reason: TxRejectedReason.ContractAlreadyExists;\n  reason_data: {\n    contract_identifier: string;\n  };\n  txid: string;\n};\n\nexport type PoisonMicroblocksDoNotConflictRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblocksDoNotConflict;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockHasUnknownPubKeyHashRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockHasUnknownPubKeyHash;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockIsInvalidRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockIsInvalid;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadAddressVersionByteRejection = {\n  error: string;\n  reason: TxRejectedReason.BadAddressVersionByte;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoCoinbaseViaMempoolRejection = {\n  error: string;\n  reason: TxRejectedReason.NoCoinbaseViaMempool;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureNoSuchChainTipRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureNoSuchChainTip;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureDatabaseRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureDatabase;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ServerFailureOtherRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureOther;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type TxBroadcastResultOk = {\n  txid: string;\n  error?: undefined;\n  reason?: undefined;\n  reason_data?: undefined;\n};\n\nexport type TxBroadcastResultRejected =\n  | SerializationRejection\n  | DeserializationRejection\n  | SignatureValidationRejection\n  | BadNonceRejection\n  | FeeTooLowRejection\n  | NotEnoughFundsRejection\n  | NoSuchContractRejection\n  | NoSuchPublicFunctionRejection\n  | BadFunctionArgumentRejection\n  | ContractAlreadyExistsRejection\n  | PoisonMicroblocksDoNotConflictRejection\n  | PoisonMicroblockHasUnknownPubKeyHashRejection\n  | PoisonMicroblockIsInvalidRejection\n  | BadAddressVersionByteRejection\n  | NoCoinbaseViaMempoolRejection\n  | ServerFailureNoSuchChainTipRejection\n  | ServerFailureDatabaseRejection\n  | ServerFailureOtherRejection;\n\nexport type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to broadcast\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastTransaction(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork,\n  attachment?: Buffer\n): Promise<TxBroadcastResult> {\n  const rawTx = transaction.serialize();\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getBroadcastApiUrl();\n\n  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);\n}\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {Buffer} rawTx - the raw serialized transaction buffer to broadcast\n * @param {string} url - the broadcast endpoint URL\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastRawTransaction(\n  rawTx: Buffer,\n  url: string,\n  attachment?: Buffer,\n  fetchFn: FetchFn = createFetchFn()\n): Promise<TxBroadcastResult> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\n    body: attachment\n      ? JSON.stringify({\n          tx: rawTx.toString('hex'),\n          attachment: attachment.toString('hex'),\n        })\n      : rawTx,\n  };\n\n  const response = await fetchFn(url, options);\n  if (!response.ok) {\n    try {\n      return (await response.json()) as TxBroadcastResult;\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${(e as Error).message}`);\n    }\n  }\n\n  const text = await response.text();\n  // Replace extra quotes around txid string\n  const txid = text.replace(/[\"]+/g, '');\n  const isValidTxId = validateTxId(txid);\n  if (!isValidTxId) {\n    throw new Error(text);\n  }\n  return {\n    txid,\n  } as TxBroadcastResult;\n}\n\n/**\n * Fetch a contract's ABI\n *\n * @param {string} address - the contracts address\n * @param {string} contractName - the contracts name\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds\n */\nexport async function getAbi(\n  address: string,\n  contractName: string,\n  network: StacksNetworkName | StacksNetwork\n): Promise<ClarityAbi> {\n  const options = {\n    method: 'GET',\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getAbiApiUrl(address, contractName);\n\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return JSON.parse(await response.text()) as ClarityAbi;\n}\n\nfunction deriveNetwork(transaction: StacksTransaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\n\nexport interface MultiSigOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys?: string[];\n}\n\n/**\n * STX token transfer transaction options\n */\nexport interface TokenTransferOptions {\n  /** the address of the recipient of the token transfer */\n  recipient: string | PrincipalCV;\n  /** the amount to be transfered in microstacks */\n  amount: IntegerType;\n  /** the transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorMode;\n  /** an arbitrary string to include in the transaction, must be less than 34 bytes */\n  memo?: string;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedTokenTransferOptions extends TokenTransferOptions {\n  publicKey: string;\n}\n\nexport interface SignedTokenTransferOptions extends TokenTransferOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * Generates an unsigned Stacks token transfer transaction\n *\n * Returns a Stacks token transfer transaction.\n *\n * @param  {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedSTXTokenTransfer(\n  txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    memo: '',\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n\n  let authorization: Authorization | null = null;\n  let spendingCondition: SpendingCondition | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    const txFee = await estimateTransaction(payload, estimatedLen, options.network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a signed Stacks token transfer transaction\n *\n * Returns a signed Stacks token transfer transaction.\n *\n * @param  {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {StacksTransaction}\n */\nexport async function makeSTXTokenTransfer(\n  txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    // txOptions is SignedTokenTransferOptions\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    // txOptions is SignedMultiSigTokenTransferOptions\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Contract deploy transaction options\n */\nexport interface BaseContractDeployOptions {\n  contractName: string;\n  /** the Clarity code to be deployed */\n  codeBody: string;\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface ContractDeployOptions extends BaseContractDeployOptions {\n  /** a hex string of the private key of the transaction sender */\n  senderKey: string;\n}\n\nexport interface UnsignedContractDeployOptions extends BaseContractDeployOptions {\n  /** a hex string of the public key of the transaction sender */\n  publicKey: string;\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract deploy\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractDeploy(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.SmartContract) {\n    throw new Error(\n      `Contract deploy fee estimation only possible with ${\n        PayloadType[PayloadType.SmartContract]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract deploy fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates a Clarity smart contract deploy transaction\n *\n * @param  {ContractDeployOptions} txOptions - an options object for the contract deploy\n *\n * Returns a signed Stacks smart contract deploy transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractDeploy(\n  txOptions: ContractDeployOptions\n): Promise<StacksTransaction> {\n  const privKey = createStacksPrivateKey(txOptions.senderKey);\n  const stacksPublicKey = getPublicKey(privKey);\n  const publicKey = publicKeyToString(stacksPublicKey);\n  const unsignedTxOptions: UnsignedContractDeployOptions = { ...txOptions, publicKey };\n  const transaction: StacksTransaction = await makeUnsignedContractDeploy(unsignedTxOptions);\n\n  if (txOptions.senderKey) {\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n  }\n\n  return transaction;\n}\n\nexport async function makeUnsignedContractDeploy(\n  txOptions: UnsignedContractDeployOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createSmartContractPayload(options.contractName, options.codeBody);\n\n  const addressHashMode = AddressHashMode.SerializeP2PKH;\n  const pubKey = createStacksPublicKey(options.publicKey);\n\n  let authorization: Authorization | null = null;\n\n  const spendingCondition = createSingleSigSpendingCondition(\n    addressHashMode,\n    publicKeyToString(pubKey),\n    options.nonce,\n    options.fee\n  );\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    const txFee = await estimateTransaction(payload, estimatedLen, options.network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Contract function call transaction options\n */\nexport interface ContractCallOptions {\n  /** the Stacks address of the contract */\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  feeEstimateApiUrl?: string;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the Stacks blockchain network that will ultimately be used to broadcast this transaction */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true to validate that the supplied function args match those specified in\n   * the published contract */\n  validateWithAbi?: boolean | ClarityAbi;\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractCallOptions extends ContractCallOptions {\n  publicKey: string;\n}\n\nexport interface SignedContractCallOptions extends ContractCallOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract function call\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractFunctionCall(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(\n      `Contract call fee estimation only possible with ${\n        PayloadType[PayloadType.ContractCall]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract call fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates an unsigned Clarity smart contract function call transaction\n *\n * @param {UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions} txOptions - an options object for the contract call\n *\n * @returns {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedContractCall(\n  txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createContractCallPayload(\n    options.contractAddress,\n    options.contractName,\n    options.functionName,\n    options.functionArgs\n  );\n\n  if (options?.validateWithAbi) {\n    let abi: ClarityAbi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options?.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition: SpendingCondition | null = null;\n  let authorization: Authorization | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    const txFee = await estimateTransaction(payload, estimatedLen, network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a Clarity smart contract function call transaction\n *\n * @param  {SignedContractCallOptions | SignedMultiSigContractCallOptions} txOptions - an options object for the contract function call\n *\n * Returns a signed Stacks smart contract function call transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractCall(\n  txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Generates a STX post condition with a standard principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens\n */\nexport function makeStandardSTXPostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\n\n/**\n * Generates a STX post condition with a contract principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address of the contract\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens\n *\n * @return {STXPostCondition}\n */\nexport function makeContractSTXPostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount\n  );\n}\n\n/**\n * Generates a fungible token post condition with a standard principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeStandardFungiblePostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a fungible token post condition with a contract principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeContractFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a standard principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param  {ClarityValue} assetName - asset name describing the non-fungible token\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeStandardNonFungiblePostCondition(\n  address: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    assetInfo,\n    assetName\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a contract principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {String} contractName - the name of the contract\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param  {ClarityValue} assetName - asset name describing the non-fungible token\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeContractNonFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    assetInfo,\n    assetName\n  );\n}\n\n/**\n * Read only function options\n *\n * @param  {String} contractAddress - the c32check address of the contract\n * @param  {String} contractName - the contract name\n * @param  {String} functionName - name of the function to be called\n * @param  {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {String} senderAddress - the c32check address of the sender\n */\n\nexport interface ReadOnlyFunctionOptions {\n  contractName: string;\n  contractAddress: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** the network that the contract which contains the function is deployed to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** address of the sender */\n  senderAddress: string;\n}\n\n/**\n * Calls a function as read-only from a contract interface\n * It is not necessary that the function is defined as read-only in the contract\n *\n * @param  {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object\n *\n * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.\n *\n * @return {ClarityValue}\n */\nexport async function callReadOnlyFunction(\n  readOnlyFunctionOptions: ReadOnlyFunctionOptions\n): Promise<ClarityValue> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n\n  const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n\n  const args = functionArgs.map(arg => cvToHex(arg));\n\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args,\n  });\n\n  const response = await network.fetchFn(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\n\n/**\n * Sponsored transaction options\n */\nexport interface SponsorOptionsOpts {\n  /** the origin-signed transaction */\n  transaction: StacksTransaction;\n  /** the sponsor's private key */\n  sponsorPrivateKey: string;\n  /** the transaction fee amount to sponsor */\n  fee?: IntegerType;\n  /** the nonce of the sponsor account */\n  sponsorNonce?: IntegerType;\n  /** the hashmode of the sponsor's address */\n  sponsorAddressHashmode?: AddressHashMode;\n  /** the Stacks blockchain network that this transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n}\n\n/**\n * Constructs and signs a sponsored transaction as the sponsor\n *\n * @param  {SponsorOptionsOpts} sponsorOptions - the sponsor options object\n *\n * Returns a signed sponsored transaction.\n *\n * @return {ClarityValue}\n */\nexport async function sponsorTransaction(\n  sponsorOptions: SponsorOptionsOpts\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: 0 as IntegerType,\n    sponsorNonce: 0 as IntegerType,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH as SingleSigHashMode,\n    network:\n      sponsorOptions.transaction.version === TransactionVersion.Mainnet\n        ? new StacksMainnet()\n        : new StacksTestnet(),\n  };\n\n  const options = Object.assign(defaultOptions, sponsorOptions);\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = 0;\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n      case PayloadType.SmartContract:\n      case PayloadType.ContractCall:\n        const estimatedLen = estimateTransactionByteLength(options.transaction);\n        try {\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]\n            .fee;\n        } catch (e) {\n          throw e;\n        }\n        break;\n      default:\n        throw new Error(\n          `Sponsored transactions not supported for transaction type ${\n            PayloadType[options.transaction.payload.payloadType]\n          }`\n        );\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(\n    options.sponsorAddressHashmode,\n    publicKeyToString(sponsorPubKey),\n    options.sponsorNonce,\n    options.fee\n  );\n\n  options.transaction.setSponsor(sponsorSpendingCondition);\n\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(\n    options.transaction,\n    sponsorSpendingCondition\n  );\n  signer.signSponsor(privKey);\n\n  return signer.transaction;\n}\n\n/**\n * Estimates transaction byte length\n * Context:\n * 1) Multi-sig transaction byte length increases by adding signatures\n *    which causes the incorrect fee estimation because the fee value is set while creating unsigned transaction\n * 2) Single-sig transaction byte length remain same due to empty message signature which allocates the space for signature\n * @param {transaction} - StacksTransaction object to be estimated\n * @return {number} Estimated transaction byte length\n */\nexport function estimateTransactionByteLength(transaction: StacksTransaction): number {\n  const hashMode = transaction.auth.spendingCondition.hashMode;\n  // List of Multi-sig transaction hash modes\n  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\n\n  // Check if its a Multi-sig transaction\n  if (multiSigHashModes.includes(hashMode)) {\n    const multiSigSpendingCondition: MultiSigSpendingCondition = transaction.auth\n      .spendingCondition as MultiSigSpendingCondition;\n\n    // Find number of existing signatures if the transaction is signed or partially signed\n    const existingSignatures = multiSigSpendingCondition.fields.filter(\n      field => field.contents.type === StacksMessageType.MessageSignature\n    ).length; // existingSignatures will be 0 if its a unsigned transaction\n\n    // Estimate total signature bytes size required for this multi-sig transaction\n    // Formula: totalSignatureLength = (signaturesRequired - existingSignatures) * (SIG_LEN_BYTES + 1 byte of type of signature)\n    const totalSignatureLength =\n      (multiSigSpendingCondition.signaturesRequired - existingSignatures) *\n      (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\n\n    return transaction.serialize().byteLength + totalSignatureLength;\n  } else {\n    // Single-sig transaction\n    // Signature space already allocated by empty message signature\n    return transaction.serialize().byteLength;\n  }\n}\n","import { sha256 } from '@noble/hashes/sha256';\nimport { Buffer } from '@stacks/common';\nimport { ClarityType, ClarityValue, serializeCV } from './clarity';\nimport { StacksMessageType } from './constants';\nimport { signMessageHashRsv, StacksPrivateKey } from './keys';\n\n// Refer to SIP018 https://github.com/stacksgov/sips/\nexport const STRUCTURED_DATA_PREFIX = Buffer.from('SIP018', 'ascii');\n\nexport function hashStructuredData(structuredData: ClarityValue): Buffer {\n  return Buffer.from(sha256(serializeCV(structuredData)));\n}\n\nconst hash256BytesLength = 32;\n\nfunction isDomain(value: ClarityValue): boolean {\n  if (value.type !== ClarityType.Tuple) return false;\n  // Check that the tuple has at least 'name', 'version' and 'chain-id'\n  if (!['name', 'version', 'chain-id'].every(key => key in value.data)) return false;\n  // Check each key is of the right type\n  if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII))\n    return false;\n\n  if (value.data['chain-id'].type !== ClarityType.UInt) return false;\n  return true;\n}\n\nexport function encodeStructuredData({\n  message,\n  domain,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n}): Buffer {\n  const structuredDataHash: Buffer = hashStructuredData(message);\n  if (!isDomain(domain)) {\n    throw new Error(\n      \"domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt\"\n    );\n  }\n  const domainHash: Buffer = hashStructuredData(domain);\n\n  return Buffer.concat([STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash]);\n}\n\nexport type DecodedStructuredData = {\n  domainHash: Buffer;\n  messageHash: Buffer;\n};\n\nexport function decodeStructuredDataSignature(signature: string | Buffer): DecodedStructuredData {\n  const encodedMessageBuffer: Buffer = Buffer.from(signature);\n  const domainHash = encodedMessageBuffer.slice(\n    STRUCTURED_DATA_PREFIX.length,\n    STRUCTURED_DATA_PREFIX.length + hash256BytesLength\n  );\n  const messageHash = encodedMessageBuffer.slice(\n    STRUCTURED_DATA_PREFIX.length + hash256BytesLength\n  );\n  return {\n    domainHash,\n    messageHash,\n  };\n}\n\nexport interface StructuredDataSignature {\n  readonly type: StacksMessageType.StructuredDataSignature;\n  data: string;\n}\n\n/**\n * Signs a structured message (ClarityValue) and a domain (ClarityValue) using a private key.\n * The resulting signature along with the original message can be verified using {@link verifyMessageSignature}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signStructuredData({\n  message,\n  domain,\n  privateKey,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n  privateKey: StacksPrivateKey;\n}): StructuredDataSignature {\n  const structuredDataHash: string = Buffer.from(\n    sha256(encodeStructuredData({ message, domain }))\n  ).toString('hex');\n\n  const { data } = signMessageHashRsv({\n    messageHash: structuredDataHash,\n    privateKey,\n  });\n  return {\n    data,\n    type: StacksMessageType.StructuredDataSignature,\n  };\n}\n"],"names":["root","factory","exports","module","define","amd","this","leafPrototypes","getProto","byteLength","b64","lens","getLens","validLen","placeHoldersLen","toByteArray","tmp","i","arr","Arr","_byteLength","curByte","len","revLookup","charCodeAt","fromByteArray","uint8","length","extraBytes","parts","maxChunkLength","len2","push","encodeChunk","lookup","join","Uint8Array","Array","code","Error","indexOf","start","end","num","output","base64","ieee754","customInspectSymbol","Symbol","Buffer","SlowBuffer","alloc","INSPECT_MAX_BYTES","K_MAX_LENGTH","createBuffer","RangeError","buf","Object","setPrototypeOf","prototype","arg","encodingOrOffset","TypeError","allocUnsafe","from","value","string","encoding","isEncoding","actual","write","slice","fromString","ArrayBuffer","isView","arrayView","isInstance","copy","fromArrayBuffer","buffer","byteOffset","fromArrayLike","fromArrayView","SharedArrayBuffer","valueOf","b","obj","isBuffer","checked","undefined","numberIsNaN","type","isArray","data","fromObject","toPrimitive","assertSize","size","array","toString","mustMatch","arguments","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","m","bidirectionalIndexOf","val","dir","arrayIndexOf","call","lastIndexOf","indexSize","arrLength","valLength","String","read","readUInt16BE","foundIndex","found","j","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","asciiToBytes","base64Write","ucs2Write","units","c","hi","lo","utf16leToBytes","Math","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","decodeCodePointsArray","kMaxLength","TYPED_ARRAY_SUPPORT","proto","foo","e","typedArraySupport","console","error","defineProperty","enumerable","get","poolSize","fill","allocUnsafeSlow","_isBuffer","compare","a","x","y","concat","list","pos","set","swap16","swap32","swap64","toLocaleString","equals","inspect","max","replace","trim","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","hexSliceLookupTable","bytes","checkOffset","ext","checkInt","wrtBigUInt64LE","checkIntBI","BigInt","wrtBigUInt64BE","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","subarray","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","defineBigIntMethod","validateNumber","first","last","boundsError","readBigUInt64BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","errors","E","sym","getMessage","Base","constructor","super","writable","configurable","name","stack","message","addNumericalSeparator","range","ERR_OUT_OF_RANGE","checkBounds","ERR_INVALID_ARG_TYPE","floor","ERR_BUFFER_OUT_OF_BOUNDS","input","msg","received","isInteger","abs","INVALID_BASE64_RE","Infinity","leadSurrogate","split","base64clean","src","dst","alphabet","table","i16","fn","BufferBigIntNotDefined","c32ToB58","b58ToC32","c32addressDecode","c32address","versions","checksum_1","base58check","mainnet","p2pkh","p2sh","testnet","ADDR_BITCOIN_TO_STACKS","ADDR_STACKS_TO_BITCOIN","version","hash160hex","match","c32checkEncode","c32addr","c32checkDecode","b58check","stacksVersion","addrInfo","decode","hash160String","addrVersion","prefix","c32string","bitcoinVersion","encode","buffer_1","cross_sha256_1","basex","ALPHABET","hash","hashSha256","forEach","check","index","encoding_1","c32checksum","dataHex","versionHex","checksumHex","c32str","c32encode","c32","c32data","c32normalize","c32decode","versionChar","checksum","substring","hex","c32input","toUpperCase","inputHex","minLength","carry","currentCode","nextCode","nextBits","nextLowBits","curC32Digit","unshift","C32leadingZeros","zeroPrefix","numLeadingZeroBytesInHex","count","numLeadingZeroBytes","carryBits","currentValue","currentHexDigit","hexLeadingZeros","hexStr","address_1","_Buffer","BASE_MAP","charAt","xc","BASE","LEADER","FACTOR","log","iFACTOR","decodeUnsafe","source","psz","zeroes","b256","it3","it4","vch","pbegin","pend","b58","it1","it2","repeat","self","support","Blob","viewClasses","isArrayBufferView","normalizeName","test","normalizeValue","iteratorFor","items","iterator","next","shift","done","Headers","headers","map","append","header","getOwnPropertyNames","consumed","body","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","onload","result","onerror","readBlobAsArrayBuffer","blob","FileReader","promise","readAsArrayBuffer","bufferClone","view","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","FormData","_bodyFormData","URLSearchParams","DataView","_bodyArrayBuffer","rejected","arrayBuffer","then","text","readAsText","chars","readArrayBufferAsText","formData","json","JSON","parse","oldValue","has","hasOwnProperty","callback","thisArg","keys","values","entries","methods","Request","options","method","upcased","url","credentials","mode","signal","referrer","form","decodeURIComponent","Response","bodyInit","status","ok","statusText","clone","response","redirectStatuses","redirect","location","DOMException","err","create","fetch","init","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","rawHeaders","getAllResponseHeaders","line","key","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","addEventListener","onreadystatechange","readyState","removeEventListener","send","polyfill","sha256","sha256nodeCrypto","sha256js","_blockSize","_finalSize","_len","_w","_a","_b","_c","_d","_e","_f","_g","_h","_block","update","block","blockSize","accum","assigned","remainder","_update","digest","rem","bits","lowBits","highBits","ch","z","maj","sigma0","sigma1","gamma0","gamma1","M","W","d","f","g","h","T1","K","T2","useCryptoModuleCache","nodeCryptoCreateHash","_nodeCryptoAvailable","isAvailable","cryptoModule","createHash","isNodeCryptoAvailable","instance","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","s","NaN","rt","isNaN","LN2","HASH_UNDEFINED","MAX_SAFE_INTEGER","argsTag","boolTag","dateTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reFlags","reIsHostCtor","reIsUint","cloneableTags","freeGlobal","freeSelf","Function","freeExports","nodeType","freeModule","moduleExports","addMapEntry","pair","addSetEntry","add","arrayReduce","iteratee","accumulator","initAccum","isHostObject","mapToArray","overArg","func","transform","setToArray","uid","arrayProto","funcProto","objectProto","coreJsData","maskSrcKey","exec","IE_PROTO","funcToString","objectToString","reIsNative","RegExp","getPrototype","getPrototypeOf","objectCreate","propertyIsEnumerable","splice","nativeGetSymbols","getOwnPropertySymbols","nativeIsBuffer","nativeKeys","getNative","Map","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","Hash","clear","entry","ListCache","MapCache","Stack","__data__","assignValue","object","objValue","eq","assocIndexOf","baseClone","isDeep","isFull","customizer","isObject","isArr","initCloneArray","copyArray","tag","getTag","isFunc","cloneBuffer","isPrototype","initCloneObject","copyObject","getSymbols","copySymbols","baseAssign","cloneFunc","symbol","Ctor","cloneArrayBuffer","dataView","cloneDataView","typedArray","cloneTypedArray","cloneMap","regexp","lastIndex","cloneRegExp","cloneSet","initCloneByTag","stacked","props","keysFunc","symbolsFunc","arrayPush","baseGetAllKeys","getAllKeys","arrayEach","subValue","newValue","getMapData","getValue","isFunction","baseIsNative","pop","cache","pairs","LARGE_ARRAY_SIZE","isIndex","other","ctorString","isArrayLike","isLength","inherited","isObjectLike","isArrayLikeObject","isArguments","baseTimes","skipIndexes","arrayLikeKeys","baseKeys","copyProps","SafeBuffer","utils_1","SmartBuffer","_encoding","_writeOffset","_readOffset","isSmartBufferOptions","checkEncoding","isFiniteInteger","ERRORS","INVALID_SMARTBUFFER_SIZE","_buff","buff","INVALID_SMARTBUFFER_BUFFER","INVALID_SMARTBUFFER_OBJECT","static","castOptions","_readNumberValue","bigIntAndBufferInt64Check","_writeNumberValue","insertInt8","_insertNumberValue","insertInt16BE","insertInt16LE","insertInt32BE","insertInt32LE","insertBigInt64BE","insertBigInt64LE","insertUInt8","insertUInt16BE","insertUInt16LE","insertUInt32BE","insertUInt32LE","insertBigUInt64BE","insertBigUInt64LE","insertFloatBE","insertFloatLE","insertDoubleBE","insertDoubleLE","readString","arg1","lengthVal","checkLengthValue","insertString","checkOffsetValue","_handleString","writeString","arg2","readStringNT","nullPos","insertStringNT","writeStringNT","writeOffset","readBuffer","endPoint","insertBuffer","_handleBuffer","writeBuffer","readBufferNT","insertBufferNT","writeBufferNT","readOffset","checkTargetOffset","internalBuffer","toBuffer","encodingVal","destroy","isInsert","arg3","offsetVal","ensureInsertable","_ensureWriteable","ensureReadable","INVALID_READ_BEYOND_BOUNDS","dataLength","_ensureCapacity","oldLength","newLength","byteSize","INVALID_WRITE_BEYOND_BOUNDS","INVALID_ENCODING","INVALID_OFFSET","INVALID_OFFSET_NON_NUMBER","INVALID_LENGTH","INVALID_LENGTH_NON_NUMBER","INVALID_TARGET_OFFSET","INVALID_TARGET_LENGTH","checkOffsetOrLengthValue","bufferMethod","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","id","loaded","__webpack_modules__","getter","__esModule","t","ns","r","def","current","definition","o","globalThis","window","prop","toStringTag","nmd","paths","children","AvailableBufferModule","intToBytes","signed","intToBigInt","parsedValue","startsWith","padStart","SyntaxError","bn","width","nthBit","fromTwos","bytesToHex","with0x","hexToBigInt","intToHex","integer","lengthBytes","hexToInt","hexByte","byte","hexToBytes","hexes","_","uint8a","u","DEFAULT_CHAIN_ID","MAX_STRING_LENGTH_BYTES","CLARITY_INT_SIZE","CLARITY_INT_BYTE_SIZE","COINBASE_BUFFER_LENGTH_BYTES","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","COMPRESSED_PUBKEY_LENGTH_BYTES","UNCOMPRESSED_PUBKEY_LENGTH_BYTES","MEMO_MAX_LENGTH_BYTES","DEFAULT_CORE_NODE_API_URL","StacksMessageType","PayloadType","AnchorMode","DEFAULT_TRANSACTION_VERSION","PostConditionMode","PostConditionType","AuthType","AddressHashMode","AddressVersion","PubKeyEncoding","FungibleConditionCode","NonFungibleConditionCode","PostConditionPrincipalID","AssetType","TxRejectedReason","number","isSafeInteger","lengths","bool","outputLen","blockLen","exists","checkFinished","destroyed","finished","createView","crypto","rotr","word","Uint32Array","TextEncoder","v","_cloneInto","wrapConstructor","hashConstructor","hashC","SHA2","padOffset","take","process","roundClean","digestInto","setBigUint64","_32n","_u32_max","wh","wl","l","setUint32","oview","to","Rho","Id","Pi","idxL","idxR","k","shifts","shiftsL","idx","shiftsR","Kl","Kr","rotl","group","BUF","RIPEMD160","h0","h1","h2","h3","h4","getUint32","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","tr","ripemd160","Maj","SHA256_K","IV","SHA256_W","SHA256","A","B","C","D","F","G","H","W15","W2","s0","s1","U32_MASK64","fromBig","le","lst","Ah","Al","Bh","Bl","Cl","low","Ch","Dl","Dh","Eh","El","SHA512_Kh","SHA512_Kl","SHA512_W_H","SHA512_W_L","SHA512","Fh","Fl","Gh","Gl","Hh","Hl","W15h","W15l","s0h","s0l","W2h","W2l","s1h","s1l","SUMl","SUMh","sigma1h","sigma1l","CHIh","T1ll","T1h","T1l","sigma0h","sigma0l","MAJh","MAJl","All","SHA512_256","SHA384","sha512_256","_0n","_1n","_2n","_3n","_8n","POW_2_256","CURVE","P","Gx","Gy","beta","weistrass","x2","mod","x3","USE_ENDOMORPHISM","JacobianPoint","p","Point","points","toInv","nums","scratch","inverted","invert","reduce","acc","reduceRight","invertBatch","toAffine","toAffineBatch","fromAffine","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","negate","double","X3","Y3","Z3","ZERO","HH","HHH","V","subtract","multiplyUnsafe","scalar","P0","normalizeScalar","k1neg","k1","k2neg","k2","splitScalarEndo","k1p","k2p","precomputeWindow","windows","base","wNAF","affinePoint","_WINDOW_SIZE","precomputes","pointPrecomputes","normalizeZ","windowSize","mask","maxNumber","shiftBy","wbits","pr","cached","multiply","point","fake","f2p","f1p","invZ","iz1","iz2","iz3","ax","ay","_setWindowSize","delete","isShort","bytesToNumber","isValidFieldElement","_6n","_11n","_22n","_23n","_44n","_88n","b2","b3","b6","pow2","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","sqrtMod","isYOdd","assertValidity","ensureBytes","fromCompressedHex","fromUncompressedHex","privateKey","normalizePrivateKey","msgHash","signature","recovery","truncateHash","normalizeSignature","R","fromHex","numTo32bStr","rinv","u1","u2","Q","multiplyAndAddUnsafe","toRawBytes","isCompressed","toHex","toHexX","toRawX","left","aP","bQ","sum","sliceDER","parseDERInt","Signature","isUint8a","hexToNumber","sBytes","rBytesLeft","parseDERSignature","fromDER","isWithinCurveOrder","hasHighS","HALF","normalizeS","toDERRawBytes","toDERHex","sHex","numberToHexUnpadded","rHex","rLen","sLen","toCompactRawBytes","toCompactHex","arrays","every","pad","numTo32b","power","modulo","q","divNearest","POW_2_128","a1","b1","a2","c1","c2","delta","HmacDrbg","counter","hmac","utils","hmacSha256","hmacSync","hmacSha256Sync","incr","async","seed","reseedSync","generateSync","kmdToSig","kBytes","sig","fromCompact","bits2int","bits2octets","z1","z2","int2octets","vopts","strict","verify","publicKey","opts","normalizePublicKey","sinv","node","web","TAGGED_HASH_PREFIXES","isValidPrivateKey","privateAdd","tweak","privateNegate","pointAddScalar","pointMultiply","hashToPrivateKey","randomBytes","bytesLength","getRandomValues","randomPrivateKey","concatBytes","messages","subtle","ckey","importKey","sign","createHmac","sha256Sync","taggedHash","tagP","tagH","taggedHashSync","precompute","HMAC","_key","iHash","oHash","parseRecoverableSignatureVrs","COORDINATE_BYTES","recoveryIdHex","recoveryId","TransactionVersion","ChainID","createMessageSignature","MessageSignature","addressHashModeToVersion","hashMode","txVersion","SerializeP2PKH","MainnetSingleSig","TestnetSingleSig","stringify","SerializeP2SH","SerializeP2WPKH","SerializeP2WSH","MainnetMultiSig","TestnetMultiSig","addressFromVersionHash","Address","hash160","addressToString","address","getAddressFromPrivateKey","transactionVersion","getAddressFromPublicKey","pubKeyfromPrivKey","hashP2PKH","createStacksPublicKey","PublicKey","publicKeyFromSignatureVrs","messageSignature","pubKeyEncoding","Compressed","parsedSignature","fromSignature","compressed","publicKeyFromSignatureRsv","msgs","publicKeyFromSignature","publicKeyFromBuffer","publicKeyToString","serializePublicKey","bufferArray","BufferArray","concatBuffer","privKey","createStacksPrivateKey","fromPrivateKey","compressPublicKey","deserializePublicKey","bufferReader","fieldId","keyLength","privateKeyBuffer","privateKeyToBuffer","makeRandomPrivKey","signWithKey","messageHash","rawSignature","extraEntropy","seedArgs","initSigArgs","drbg","recSig","canonical","der","recovered","assign","hashed","finalizeSig","signSync","signMessageHashRsv","parseRecoverableSignature","privateKeyToString","publicKeyToAddress","parseAssetInfoString","assetAddress","assetContractName","assetTokenName","createAssetInfo","createLPString","content","lengthPrefixBytes","maxLengthBytes","prefixLength","maxLength","exceedsMaxLengthBytes","LengthPrefixedString","addressString","contractName","assetName","AssetInfo","createAddress","c32AddressString","addressData","parsePrincipalString","principalString","createContractPrincipal","createStandardPrincipal","addr","Principal","Contract","Standard","ClarityType","MAX_U128","MIN_U128","MAX_I128","MIN_I128","intCV","bigInt","Int","uintCV","UInt","bufferCV","bufferCVFromString","trueCV","BoolTrue","falseCV","BoolFalse","principalToString","principal","PrincipalStandard","PrincipalContract","principalCV","contractPrincipalCV","standardPrincipalCV","standardPrincipalCVFromAddress","contractPrincipalCVFromAddress","contractPrincipalCVFromStandard","sp","lengthPrefixedContractName","responseErrorCV","ResponseErr","responseOkCV","ResponseOk","noneCV","OptionalNone","someCV","OptionalSome","listCV","List","tupleCV","isClarityName","Tuple","enumCheckFunctions","isEnum","enumVariable","checker","newChecker","enumValues","filter","enumValueSet","createEnumChecker","BufferReader","smartBuffer","readBigUIntLE","reverse","readBigUIntBE","readUInt8Enum","invalidEnumErrorFormatter","SerializationError","captureStackTrace","DeserializationError","NotImplementedError","SigningError","VerificationError","stringAsciiCV","StringASCII","stringUtf8CV","StringUTF8","deserializeCV","serializedClarityValue","hasHexPrefix","bufferLength","deserializeAddress","deserializeLPString","listLength","listContents","tupleLength","tupleContents","clarityName","asciiStrLen","asciiStr","utf8StrLen","utf8Str","createTokenTransferPayload","recipient","amount","memo","createMemoString","Payload","payloadType","TokenTransfer","createContractCallPayload","contractAddress","functionName","functionArgs","ContractCall","createSmartContractPayload","codeBody","codeBodyString","SmartContract","serializePayload","payload","appendByte","serializeCV","serializeStacksMessage","numArgs","PoisonMicroblock","Coinbase","coinbaseBuffer","deserializePayload","deserializeMemoString","contractCallName","numberOfArgs","clarityValue","createCoinbasePayload","AuthFieldType","deserializeMessageSignature","createTransactionAuthField","contents","TransactionAuthField","deserializeTransactionAuthField","authFieldType","Uncompressed","serializeMessageSignature","appendHexString","serializeTransactionAuthField","field","serializeAddress","serializePrincipal","serializeLPString","MemoString","serializeMemoString","serializeAssetInfo","PostCondition","serializePostCondition","LengthPrefixedList","serializeLPList","deserializeStacksMessage","listType","deserializePrincipal","deserializeAssetInfo","deserializePostCondition","deserializeLPList","createEmptyAddress","addressFromHashMode","addressFromPublicKeys","numSigs","publicKeys","hashP2WPKH","hashP2SH","hashP2WSH","lps","contentBuffer","prefixBytes","memoString","paddedContent","rightPadHexToLength","info","createLPList","lpList","postCondition","conditionType","Fungible","NonFungible","assetInfo","conditionCode","STX","postConditionType","bufferWithTypeID","typeId","serializeStringCV","cv","buffers","serializeBoolCV","serializeBufferCV","serializeUIntCV","toTwos","serializeIntCV","serializeStandardPrincipalCV","serializeContractPrincipalCV","serializeResponseCV","serializedValue","serializeListCV","lexicographicOrder","sort","bufA","bufB","nameWithLength","serializeTupleCV","serializeStringAsciiCV","serializeStringUtf8CV","_value","hexString","octet","leftPadHex","leftPadHexToLength","padEnd","cloneDeep","omit","txidFromData","keyHash","redeemScript","pubKeys","pubKey","scriptArray","script","cvToHex","hexToCV","parseReadOnlyResponse","okay","cause","validateStacksAddress","stacksAddress","validateTxId","txid","emptyMessageSignature","createSingleSigSpendingCondition","nonce","fee","signer","keyEncoding","createMultiSigSpendingCondition","fields","signaturesRequired","isSingleSig","condition","clearCondition","cloned","serializeSingleSigSpendingCondition","serializeMultiSigSpendingCondition","deserializeSingleSigSpendingCondition","deserializeMultiSigSpendingCondition","haveUncompressed","serializeSpendingCondition","deserializeSpendingCondition","makeSigHashPreSign","curSigHash","authType","sigHash","makeSigHashPostSign","hashLength","sigHashBuffer","nextSignature","sigHashPreSign","nextSig","nextSigHash","nextVerification","initialSigHash","createStandardAuth","spendingCondition","createSponsoredAuth","sponsorSpendingCondition","Sponsored","intoInitialSighashAuth","auth","newInitialSigHash","verifyOrigin","addrBytes","verifySingleSig","foundPubKey","verifyMultiSig","setFee","getFee","setNonce","setSponsorNonce","setSponsor","sc","serializeAuthorization","deserializeAuthorization","StacksTransaction","postConditions","postConditionMode","anchorMode","chainId","Deny","OnChainOnly","Any","signBegin","tx","verifyBegin","signNextOrigin","signAndAppend","signNextSponsor","appendPubkey","cond","endsWith","serialized","serialize","chainIdBuffer","deserializeTransaction","createSTXPostCondition","createFungiblePostCondition","createNonFungiblePostCondition","cvToString","cvToValue","strictJsonCompat","cvToJSON","getCVTypeString","success","defaultFetchOpts","referrerPolicy","fetchWrapper","fetchOpts","createFetchFn","args","fetchLib","middlewares","argsForCreateFetchFn","fetchParams","middleware","pre","post","StacksNetworks","StacksNetwork","networkConfig","bnsLookupUrl","broadcastEndpoint","transferFeeEstimateEndpoint","transactionFeeEstimateEndpoint","accountEndpoint","contractAbiEndpoint","readOnlyFunctionCallEndpoint","isMainnet","getBroadcastApiUrl","coreApiUrl","getTransferFeeEstimateApiUrl","getTransactionFeeEstimateApiUrl","getAccountApiUrl","getAbiApiUrl","contract","getReadOnlyFunctionCallApiUrl","encodeURIComponent","getInfoUrl","getBlockTimeInfoUrl","getPoxInfoUrl","getRewardsUrl","getRewardsTotalUrl","getRewardHoldersUrl","getStackerInfoUrl","fetchFn","getNameInfo","fullyQualifiedName","nameLookupURL","resp","nameInfo","fromName","networkName","StacksMainnet","StacksTestnet","fromNameOrNetwork","network","ClarityAbiTypeId","isClarityAbiPrimitive","isClarityAbiBuffer","isClarityAbiStringAscii","isClarityAbiStringUtf8","isClarityAbiResponse","isClarityAbiOptional","optional","isClarityAbiTuple","tuple","isClarityAbiList","getTypeUnion","encodeClarityValue","union","getTypeString","abiFunctionToString","access","matchType","abiType","abiTupleEntry","validateContractCall","abi","filtered","functions","abiArgs","payloadArg","abiArg","argNum","parseToCV","typeString","TransactionSigner","transaction","originDone","checkOversign","checkOverlap","nextVerify","originSigHash","signOrigin","nextSighash","appendOrigin","signSponsor","getTxInComplete","resume","getNonce","derivedNetwork","estimateTransfer","deriveNetwork","Accept","feeRateResult","txBytes","estimateTransaction","transactionPayload","estimatedLen","transaction_payload","estimated_len","estimations","broadcastTransaction","attachment","rawTx","broadcastRawTransaction","getAbi","catch","makeUnsignedSTXTokenTransfer","txOptions","defaultOptions","sponsored","authorization","numSignatures","lpPostConditions","estimateTransactionByteLength","txFee","addressVersion","senderAddress","txNonce","makeSTXTokenTransfer","senderKey","signerKeys","pk","estimateContractDeploy","makeContractDeploy","unsignedTxOptions","makeUnsignedContractDeploy","addressHashMode","estimateContractFunctionCall","makeUnsignedContractCall","validateWithAbi","makeContractCall","makeStandardSTXPostCondition","makeContractSTXPostCondition","makeStandardFungiblePostCondition","makeContractFungiblePostCondition","makeStandardNonFungiblePostCondition","makeContractNonFungiblePostCondition","callReadOnlyFunction","readOnlyFunctionOptions","sender","responseJson","sponsorTransaction","sponsorOptions","sponsorNonce","sponsorAddressHashmode","sponsorPubKey","sponsorPrivateKey","createSponsorSigner","multiSigSpendingCondition","existingSignatures","totalSignatureLength","STRUCTURED_DATA_PREFIX","hashStructuredData","structuredData","encodeStructuredData","domain","structuredDataHash","domainHash","decodeStructuredDataSignature","encodedMessageBuffer","signStructuredData","StructuredDataSignature"],"sourceRoot":""}