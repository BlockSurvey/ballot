"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseToCV = exports.validateContractCall = exports.abiFunctionToString = exports.getTypeString = exports.encodeClarityValue = exports.getTypeUnion = exports.isClarityAbiList = exports.isClarityAbiTuple = exports.isClarityAbiOptional = exports.isClarityAbiResponse = exports.isClarityAbiStringUtf8 = exports.isClarityAbiStringAscii = exports.isClarityAbiBuffer = exports.isClarityAbiPrimitive = exports.ClarityAbiTypeId = void 0;
const common_1 = require("@stacks/common");
const utils_1 = require("./utils");
const clarity_1 = require("./clarity");
const errors_1 = require("./errors");
const stringCV_1 = require("./clarity/types/stringCV");
var ClarityAbiTypeId;
(function (ClarityAbiTypeId) {
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeUInt128"] = 1] = "ClarityAbiTypeUInt128";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeInt128"] = 2] = "ClarityAbiTypeInt128";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeBool"] = 3] = "ClarityAbiTypeBool";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypePrincipal"] = 4] = "ClarityAbiTypePrincipal";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeNone"] = 5] = "ClarityAbiTypeNone";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeBuffer"] = 6] = "ClarityAbiTypeBuffer";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeResponse"] = 7] = "ClarityAbiTypeResponse";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeOptional"] = 8] = "ClarityAbiTypeOptional";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeTuple"] = 9] = "ClarityAbiTypeTuple";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeList"] = 10] = "ClarityAbiTypeList";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeStringAscii"] = 11] = "ClarityAbiTypeStringAscii";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeStringUtf8"] = 12] = "ClarityAbiTypeStringUtf8";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeTraitReference"] = 13] = "ClarityAbiTypeTraitReference";
})(ClarityAbiTypeId = exports.ClarityAbiTypeId || (exports.ClarityAbiTypeId = {}));
const isClarityAbiPrimitive = (val) => typeof val === 'string';
exports.isClarityAbiPrimitive = isClarityAbiPrimitive;
const isClarityAbiBuffer = (val) => val.buffer !== undefined;
exports.isClarityAbiBuffer = isClarityAbiBuffer;
const isClarityAbiStringAscii = (val) => val['string-ascii'] !== undefined;
exports.isClarityAbiStringAscii = isClarityAbiStringAscii;
const isClarityAbiStringUtf8 = (val) => val['string-utf8'] !== undefined;
exports.isClarityAbiStringUtf8 = isClarityAbiStringUtf8;
const isClarityAbiResponse = (val) => val.response !== undefined;
exports.isClarityAbiResponse = isClarityAbiResponse;
const isClarityAbiOptional = (val) => val.optional !== undefined;
exports.isClarityAbiOptional = isClarityAbiOptional;
const isClarityAbiTuple = (val) => val.tuple !== undefined;
exports.isClarityAbiTuple = isClarityAbiTuple;
const isClarityAbiList = (val) => val.list !== undefined;
exports.isClarityAbiList = isClarityAbiList;
function getTypeUnion(val) {
    if ((0, exports.isClarityAbiPrimitive)(val)) {
        if (val === 'uint128') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };
        }
        else if (val === 'int128') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };
        }
        else if (val === 'bool') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };
        }
        else if (val === 'principal') {
            return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };
        }
        else if (val === 'trait_reference') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };
        }
        else if (val === 'none') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };
        }
        else {
            throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);
        }
    }
    else if ((0, exports.isClarityAbiBuffer)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };
    }
    else if ((0, exports.isClarityAbiResponse)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };
    }
    else if ((0, exports.isClarityAbiOptional)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };
    }
    else if ((0, exports.isClarityAbiTuple)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };
    }
    else if ((0, exports.isClarityAbiList)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };
    }
    else if ((0, exports.isClarityAbiStringAscii)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };
    }
    else if ((0, exports.isClarityAbiStringUtf8)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };
    }
    else {
        throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);
    }
}
exports.getTypeUnion = getTypeUnion;
function encodeClarityValue(input, val) {
    let union;
    if (input.id !== undefined) {
        union = input;
    }
    else {
        union = getTypeUnion(input);
    }
    switch (union.id) {
        case ClarityAbiTypeId.ClarityAbiTypeUInt128:
            return (0, clarity_1.uintCV)(val);
        case ClarityAbiTypeId.ClarityAbiTypeInt128:
            return (0, clarity_1.intCV)(val);
        case ClarityAbiTypeId.ClarityAbiTypeBool:
            if (val === 'false' || val === '0')
                return (0, clarity_1.falseCV)();
            else if (val === 'true' || val === '1')
                return (0, clarity_1.trueCV)();
            else
                throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);
        case ClarityAbiTypeId.ClarityAbiTypePrincipal:
            if (val.includes('.')) {
                const [addr, name] = val.split('.');
                return (0, clarity_1.contractPrincipalCV)(addr, name);
            }
            else {
                return (0, clarity_1.standardPrincipalCV)(val);
            }
        case ClarityAbiTypeId.ClarityAbiTypeTraitReference:
            const [addr, name] = val.split('.');
            return (0, clarity_1.contractPrincipalCV)(addr, name);
        case ClarityAbiTypeId.ClarityAbiTypeNone:
            return (0, clarity_1.noneCV)();
        case ClarityAbiTypeId.ClarityAbiTypeBuffer:
            return (0, clarity_1.bufferCV)(common_1.Buffer.from(val, 'utf8'));
        case ClarityAbiTypeId.ClarityAbiTypeStringAscii:
            return (0, stringCV_1.stringAsciiCV)(val);
        case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:
            return (0, stringCV_1.stringUtf8CV)(val);
        case ClarityAbiTypeId.ClarityAbiTypeResponse:
            throw new errors_1.NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        case ClarityAbiTypeId.ClarityAbiTypeOptional:
            throw new errors_1.NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        case ClarityAbiTypeId.ClarityAbiTypeTuple:
            throw new errors_1.NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        case ClarityAbiTypeId.ClarityAbiTypeList:
            throw new errors_1.NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        default:
            throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);
    }
}
exports.encodeClarityValue = encodeClarityValue;
function getTypeString(val) {
    if ((0, exports.isClarityAbiPrimitive)(val)) {
        if (val === 'int128') {
            return 'int';
        }
        else if (val === 'uint128') {
            return 'uint';
        }
        return val;
    }
    else if ((0, exports.isClarityAbiBuffer)(val)) {
        return `(buff ${val.buffer.length})`;
    }
    else if ((0, exports.isClarityAbiStringAscii)(val)) {
        return `(string-ascii ${val['string-ascii'].length})`;
    }
    else if ((0, exports.isClarityAbiStringUtf8)(val)) {
        return `(string-utf8 ${val['string-utf8'].length})`;
    }
    else if ((0, exports.isClarityAbiResponse)(val)) {
        return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;
    }
    else if ((0, exports.isClarityAbiOptional)(val)) {
        return `(optional ${getTypeString(val.optional)})`;
    }
    else if ((0, exports.isClarityAbiTuple)(val)) {
        return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;
    }
    else if ((0, exports.isClarityAbiList)(val)) {
        return `(list ${val.list.length} ${getTypeString(val.list.type)})`;
    }
    else {
        throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);
    }
}
exports.getTypeString = getTypeString;
function abiFunctionToString(func) {
    const access = func.access === 'read_only' ? 'read-only' : func.access;
    return `(define-${access} (${func.name} ${func.args
        .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)
        .join(' ')}))`;
}
exports.abiFunctionToString = abiFunctionToString;
function matchType(cv, abiType) {
    const union = getTypeUnion(abiType);
    switch (cv.type) {
        case clarity_1.ClarityType.BoolTrue:
        case clarity_1.ClarityType.BoolFalse:
            return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;
        case clarity_1.ClarityType.Int:
            return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;
        case clarity_1.ClarityType.UInt:
            return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;
        case clarity_1.ClarityType.Buffer:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&
                union.type.buffer.length >= cv.buffer.length);
        case clarity_1.ClarityType.StringASCII:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&
                union.type['string-ascii'].length >= cv.data.length);
        case clarity_1.ClarityType.StringUTF8:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&
                union.type['string-utf8'].length >= cv.data.length);
        case clarity_1.ClarityType.OptionalNone:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||
                union.id === ClarityAbiTypeId.ClarityAbiTypeOptional);
        case clarity_1.ClarityType.OptionalSome:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&
                matchType(cv.value, union.type.optional));
        case clarity_1.ClarityType.ResponseErr:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&
                matchType(cv.value, union.type.response.error));
        case clarity_1.ClarityType.ResponseOk:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&
                matchType(cv.value, union.type.response.ok));
        case clarity_1.ClarityType.PrincipalContract:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||
                union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference);
        case clarity_1.ClarityType.PrincipalStandard:
            return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;
        case clarity_1.ClarityType.List:
            return (union.id == ClarityAbiTypeId.ClarityAbiTypeList &&
                union.type.list.length >= cv.list.length &&
                cv.list.every(val => matchType(val, union.type.list.type)));
        case clarity_1.ClarityType.Tuple:
            if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {
                const tuple = (0, utils_1.cloneDeep)(cv.data);
                for (let i = 0; i < union.type.tuple.length; i++) {
                    const abiTupleEntry = union.type.tuple[i];
                    const key = abiTupleEntry.name;
                    const val = tuple[key];
                    if (val) {
                        if (!matchType(val, abiTupleEntry.type)) {
                            return false;
                        }
                        delete tuple[key];
                    }
                    else {
                        return false;
                    }
                }
                return true;
            }
            else {
                return false;
            }
        default:
            return false;
    }
}
function validateContractCall(payload, abi) {
    const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);
    if (filtered.length === 1) {
        const abiFunc = filtered[0];
        const abiArgs = abiFunc.args;
        if (payload.functionArgs.length !== abiArgs.length) {
            throw new Error(`Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`);
        }
        for (let i = 0; i < payload.functionArgs.length; i++) {
            const payloadArg = payload.functionArgs[i];
            const abiArg = abiArgs[i];
            if (!matchType(payloadArg, abiArg.type)) {
                const argNum = i + 1;
                throw new Error(`Clarity function \`${payload.functionName.content}\` expects argument ${argNum} to be of type ${getTypeString(abiArg.type)}, not ${(0, clarity_1.getCVTypeString)(payloadArg)}`);
            }
        }
        return true;
    }
    else if (filtered.length === 0) {
        throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);
    }
    else {
        throw new Error(`Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`);
    }
}
exports.validateContractCall = validateContractCall;
function parseToCV(input, type) {
    const typeString = getTypeString(type);
    if ((0, exports.isClarityAbiPrimitive)(type)) {
        if (type === 'uint128') {
            return (0, clarity_1.uintCV)(input);
        }
        else if (type === 'int128') {
            return (0, clarity_1.intCV)(input);
        }
        else if (type === 'bool') {
            if (input.toLowerCase() === 'true') {
                return (0, clarity_1.trueCV)();
            }
            else if (input.toLowerCase() === 'false') {
                return (0, clarity_1.falseCV)();
            }
            else {
                throw new Error(`Invalid bool value: ${input}`);
            }
        }
        else if (type === 'principal') {
            if (input.includes('.')) {
                const [address, contractName] = input.split('.');
                return (0, clarity_1.contractPrincipalCV)(address, contractName);
            }
            else {
                return (0, clarity_1.standardPrincipalCV)(input);
            }
        }
        else {
            throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
        }
    }
    else if ((0, exports.isClarityAbiBuffer)(type)) {
        const inputLength = common_1.Buffer.from(input).byteLength;
        if (inputLength > type.buffer.length) {
            throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);
        }
        return (0, clarity_1.bufferCVFromString)(input);
    }
    else if ((0, exports.isClarityAbiResponse)(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else if ((0, exports.isClarityAbiOptional)(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else if ((0, exports.isClarityAbiTuple)(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else if ((0, exports.isClarityAbiList)(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
}
exports.parseToCV = parseToCV;
//# sourceMappingURL=contract-abi.js.map