"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTxId = exports.validateStacksAddress = exports.parseReadOnlyResponse = exports.hexToCV = exports.cvToHex = exports.isClarityName = exports.hashP2WSH = exports.hashP2SH = exports.hashP2WPKH = exports.hashP2PKH = exports.hash160 = exports.txidFromData = exports.omit = exports.cloneDeep = exports.exceedsMaxLengthBytes = exports.rightPadHexToLength = exports.leftPadHexToLength = exports.leftPadHex = exports.BufferArray = exports.bytesToHex = exports.randomBytes = exports.verifySignature = void 0;
const ripemd160_1 = require("@noble/hashes/ripemd160");
const sha256_1 = require("@noble/hashes/sha256");
const sha512_1 = require("@noble/hashes/sha512");
const secp256k1_1 = require("@noble/secp256k1");
const common_1 = require("@stacks/common");
Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function () { return common_1.bytesToHex; } });
const c32check_1 = require("c32check");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const clarity_1 = require("./clarity");
var secp256k1_2 = require("@noble/secp256k1");
Object.defineProperty(exports, "verifySignature", { enumerable: true, get: function () { return secp256k1_2.verify; } });
const randomBytes = (bytesLength) => common_1.Buffer.from(secp256k1_1.utils.randomBytes(bytesLength));
exports.randomBytes = randomBytes;
class BufferArray {
    constructor() {
        this._value = [];
    }
    get value() {
        return this._value;
    }
    appendHexString(hexString) {
        this.value.push(common_1.Buffer.from(hexString, 'hex'));
    }
    push(buffer) {
        return this._value.push(buffer);
    }
    appendByte(octet) {
        if (!Number.isInteger(octet) || octet < 0 || octet > 255) {
            throw new Error(`Value ${octet} is not a valid byte`);
        }
        this.value.push(common_1.Buffer.from([octet]));
    }
    concatBuffer() {
        return common_1.Buffer.concat(this.value);
    }
}
exports.BufferArray = BufferArray;
const leftPadHex = (hexString) => hexString.length % 2 == 0 ? hexString : `0${hexString}`;
exports.leftPadHex = leftPadHex;
const leftPadHexToLength = (hexString, length) => hexString.padStart(length, '0');
exports.leftPadHexToLength = leftPadHexToLength;
const rightPadHexToLength = (hexString, length) => hexString.padEnd(length, '0');
exports.rightPadHexToLength = rightPadHexToLength;
const exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? common_1.Buffer.from(string).length > maxLengthBytes : false;
exports.exceedsMaxLengthBytes = exceedsMaxLengthBytes;
function cloneDeep(obj) {
    return (0, lodash_clonedeep_1.default)(obj);
}
exports.cloneDeep = cloneDeep;
function omit(obj, prop) {
    const clone = cloneDeep(obj);
    delete clone[prop];
    return clone;
}
exports.omit = omit;
const txidFromData = (data) => {
    return common_1.Buffer.from((0, sha512_1.sha512_256)(data)).toString('hex');
};
exports.txidFromData = txidFromData;
const hash160 = (input) => {
    return common_1.Buffer.from((0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(input)));
};
exports.hash160 = hash160;
const hashP2PKH = (input) => {
    return (0, exports.hash160)(input).toString('hex');
};
exports.hashP2PKH = hashP2PKH;
const hashP2WPKH = (input) => {
    const keyHash = (0, exports.hash160)(input);
    const bufferArray = new BufferArray();
    bufferArray.appendByte(0);
    bufferArray.appendByte(keyHash.length);
    bufferArray.push(keyHash);
    const redeemScript = bufferArray.concatBuffer();
    const redeemScriptHash = (0, exports.hash160)(redeemScript);
    return redeemScriptHash.toString('hex');
};
exports.hashP2WPKH = hashP2WPKH;
const hashP2SH = (numSigs, pubKeys) => {
    if (numSigs > 15 || pubKeys.length > 15) {
        throw Error('P2SH multisig address can only contain up to 15 public keys');
    }
    const bufferArray = new BufferArray();
    bufferArray.appendByte(80 + numSigs);
    pubKeys.forEach(pubKey => {
        bufferArray.appendByte(pubKey.length);
        bufferArray.push(pubKey);
    });
    bufferArray.appendByte(80 + pubKeys.length);
    bufferArray.appendByte(174);
    const redeemScript = bufferArray.concatBuffer();
    const redeemScriptHash = (0, exports.hash160)(redeemScript);
    return redeemScriptHash.toString('hex');
};
exports.hashP2SH = hashP2SH;
const hashP2WSH = (numSigs, pubKeys) => {
    if (numSigs > 15 || pubKeys.length > 15) {
        throw Error('P2WSH multisig address can only contain up to 15 public keys');
    }
    const scriptArray = new BufferArray();
    scriptArray.appendByte(80 + numSigs);
    pubKeys.forEach(pubKey => {
        scriptArray.appendByte(pubKey.length);
        scriptArray.push(pubKey);
    });
    scriptArray.appendByte(80 + pubKeys.length);
    scriptArray.appendByte(174);
    const script = scriptArray.concatBuffer();
    const digest = common_1.Buffer.from((0, sha256_1.sha256)(script));
    const bufferArray = new BufferArray();
    bufferArray.appendByte(0);
    bufferArray.appendByte(digest.length);
    bufferArray.push(digest);
    const redeemScript = bufferArray.concatBuffer();
    const redeemScriptHash = (0, exports.hash160)(redeemScript);
    return redeemScriptHash.toString('hex');
};
exports.hashP2WSH = hashP2WSH;
function isClarityName(name) {
    const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;
    return regex.test(name) && name.length < 128;
}
exports.isClarityName = isClarityName;
function cvToHex(cv) {
    const serialized = (0, clarity_1.serializeCV)(cv);
    return `0x${serialized.toString('hex')}`;
}
exports.cvToHex = cvToHex;
function hexToCV(hex) {
    return (0, clarity_1.deserializeCV)(hex);
}
exports.hexToCV = hexToCV;
const parseReadOnlyResponse = (response) => {
    if (response.okay) {
        return hexToCV(response.result);
    }
    else {
        throw new Error(response.cause);
    }
};
exports.parseReadOnlyResponse = parseReadOnlyResponse;
const validateStacksAddress = (stacksAddress) => {
    try {
        (0, c32check_1.c32addressDecode)(stacksAddress);
        return true;
    }
    catch (e) {
        return false;
    }
};
exports.validateStacksAddress = validateStacksAddress;
const validateTxId = (txid) => {
    if (txid === 'success')
        return true;
    const value = (0, common_1.with0x)(txid).toLowerCase();
    if (value.length !== 66)
        return false;
    return (0, common_1.with0x)(BigInt(value).toString(16).padStart(64, '0')) === value;
};
exports.validateTxId = validateTxId;
//# sourceMappingURL=utils.js.map