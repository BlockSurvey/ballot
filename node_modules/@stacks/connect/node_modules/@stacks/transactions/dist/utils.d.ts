/// <reference types="node" />
import { Buffer, bytesToHex } from '@stacks/common';
import { ClarityValue } from './clarity';
export declare const randomBytes: (bytesLength?: number) => Buffer;
export { bytesToHex };
export declare class BufferArray {
    _value: Buffer[];
    get value(): Buffer[];
    appendHexString(hexString: string): void;
    push(buffer: Buffer): number;
    appendByte(octet: number): void;
    concatBuffer(): Buffer;
}
export declare const leftPadHex: (hexString: string) => string;
export declare const leftPadHexToLength: (hexString: string, length: number) => string;
export declare const rightPadHexToLength: (hexString: string, length: number) => string;
export declare const exceedsMaxLengthBytes: (string: string, maxLengthBytes: number) => boolean;
export declare function cloneDeep<T>(obj: T): T;
export declare function omit<T, K extends keyof any>(obj: T, prop: K): Omit<T, K>;
export declare const txidFromData: (data: Buffer) => string;
export declare const hash160: (input: Buffer) => Buffer;
export declare const hashP2PKH: (input: Buffer) => string;
export declare const hashP2WPKH: (input: Buffer) => string;
export declare const hashP2SH: (numSigs: number, pubKeys: Buffer[]) => string;
export declare const hashP2WSH: (numSigs: number, pubKeys: Buffer[]) => string;
export declare function isClarityName(name: string): boolean;
export declare function cvToHex(cv: ClarityValue): string;
export declare function hexToCV(hex: string): ClarityValue;
export interface ReadOnlyFunctionSuccessResponse {
    okay: true;
    result: string;
}
export interface ReadOnlyFunctionErrorResponse {
    okay: false;
    cause: string;
}
export declare type ReadOnlyFunctionResponse = ReadOnlyFunctionSuccessResponse | ReadOnlyFunctionErrorResponse;
export declare const parseReadOnlyResponse: (response: ReadOnlyFunctionResponse) => ClarityValue;
export declare const validateStacksAddress: (stacksAddress: string) => boolean;
export declare const validateTxId: (txid: string) => boolean;
