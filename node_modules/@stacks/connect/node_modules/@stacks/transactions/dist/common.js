"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addressToString = exports.addressFromVersionHash = exports.addressHashModeToVersion = exports.createMessageSignature = void 0;
const constants_1 = require("./constants");
const common_1 = require("@stacks/common");
const c32check_1 = require("c32check");
function createMessageSignature(signature) {
    const length = common_1.Buffer.from(signature, 'hex').byteLength;
    if (length != constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {
        throw Error('Invalid signature');
    }
    return {
        type: constants_1.StacksMessageType.MessageSignature,
        data: signature,
    };
}
exports.createMessageSignature = createMessageSignature;
function addressHashModeToVersion(hashMode, txVersion) {
    switch (hashMode) {
        case constants_1.AddressHashMode.SerializeP2PKH:
            switch (txVersion) {
                case constants_1.TransactionVersion.Mainnet:
                    return constants_1.AddressVersion.MainnetSingleSig;
                case constants_1.TransactionVersion.Testnet:
                    return constants_1.AddressVersion.TestnetSingleSig;
                default:
                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);
            }
        case constants_1.AddressHashMode.SerializeP2SH:
        case constants_1.AddressHashMode.SerializeP2WPKH:
        case constants_1.AddressHashMode.SerializeP2WSH:
            switch (txVersion) {
                case constants_1.TransactionVersion.Mainnet:
                    return constants_1.AddressVersion.MainnetMultiSig;
                case constants_1.TransactionVersion.Testnet:
                    return constants_1.AddressVersion.TestnetMultiSig;
                default:
                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);
            }
        default:
            throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);
    }
}
exports.addressHashModeToVersion = addressHashModeToVersion;
function addressFromVersionHash(version, hash) {
    return { type: constants_1.StacksMessageType.Address, version, hash160: hash };
}
exports.addressFromVersionHash = addressFromVersionHash;
function addressToString(address) {
    return (0, c32check_1.c32address)(address.version, address.hash160).toString();
}
exports.addressToString = addressToString;
//# sourceMappingURL=common.js.map