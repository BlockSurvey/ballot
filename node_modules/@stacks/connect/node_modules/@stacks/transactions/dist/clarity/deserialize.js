"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@stacks/common");
const _1 = require(".");
const bufferReader_1 = require("../bufferReader");
const types_1 = require("../types");
const errors_1 = require("../errors");
const stringCV_1 = require("./types/stringCV");
function deserializeCV(serializedClarityValue) {
    let bufferReader;
    if (typeof serializedClarityValue === 'string') {
        const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === '0x';
        bufferReader = new bufferReader_1.BufferReader(common_1.Buffer.from(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue, 'hex'));
    }
    else if (common_1.Buffer.isBuffer(serializedClarityValue)) {
        bufferReader = new bufferReader_1.BufferReader(serializedClarityValue);
    }
    else {
        bufferReader = serializedClarityValue;
    }
    const type = bufferReader.readUInt8Enum(_1.ClarityType, n => {
        throw new errors_1.DeserializationError(`Cannot recognize Clarity Type: ${n}`);
    });
    switch (type) {
        case _1.ClarityType.Int:
            return (0, _1.intCV)(bufferReader.readBuffer(16));
        case _1.ClarityType.UInt:
            return (0, _1.uintCV)(bufferReader.readBuffer(16));
        case _1.ClarityType.Buffer:
            const bufferLength = bufferReader.readUInt32BE();
            return (0, _1.bufferCV)(bufferReader.readBuffer(bufferLength));
        case _1.ClarityType.BoolTrue:
            return (0, _1.trueCV)();
        case _1.ClarityType.BoolFalse:
            return (0, _1.falseCV)();
        case _1.ClarityType.PrincipalStandard:
            const sAddress = (0, types_1.deserializeAddress)(bufferReader);
            return (0, _1.standardPrincipalCVFromAddress)(sAddress);
        case _1.ClarityType.PrincipalContract:
            const cAddress = (0, types_1.deserializeAddress)(bufferReader);
            const contractName = (0, types_1.deserializeLPString)(bufferReader);
            return (0, _1.contractPrincipalCVFromAddress)(cAddress, contractName);
        case _1.ClarityType.ResponseOk:
            return (0, _1.responseOkCV)(deserializeCV(bufferReader));
        case _1.ClarityType.ResponseErr:
            return (0, _1.responseErrorCV)(deserializeCV(bufferReader));
        case _1.ClarityType.OptionalNone:
            return (0, _1.noneCV)();
        case _1.ClarityType.OptionalSome:
            return (0, _1.someCV)(deserializeCV(bufferReader));
        case _1.ClarityType.List:
            const listLength = bufferReader.readUInt32BE();
            const listContents = [];
            for (let i = 0; i < listLength; i++) {
                listContents.push(deserializeCV(bufferReader));
            }
            return (0, _1.listCV)(listContents);
        case _1.ClarityType.Tuple:
            const tupleLength = bufferReader.readUInt32BE();
            const tupleContents = {};
            for (let i = 0; i < tupleLength; i++) {
                const clarityName = (0, types_1.deserializeLPString)(bufferReader).content;
                if (clarityName === undefined) {
                    throw new errors_1.DeserializationError('"content" is undefined');
                }
                tupleContents[clarityName] = deserializeCV(bufferReader);
            }
            return (0, _1.tupleCV)(tupleContents);
        case _1.ClarityType.StringASCII:
            const asciiStrLen = bufferReader.readUInt32BE();
            const asciiStr = bufferReader.readBuffer(asciiStrLen).toString('ascii');
            return (0, stringCV_1.stringAsciiCV)(asciiStr);
        case _1.ClarityType.StringUTF8:
            const utf8StrLen = bufferReader.readUInt32BE();
            const utf8Str = bufferReader.readBuffer(utf8StrLen).toString('utf8');
            return (0, stringCV_1.stringUtf8CV)(utf8Str);
        default:
            throw new errors_1.DeserializationError('Unable to deserialize Clarity Value from buffer. Could not find valid Clarity Type.');
    }
}
exports.default = deserializeCV;
//# sourceMappingURL=deserialize.js.map