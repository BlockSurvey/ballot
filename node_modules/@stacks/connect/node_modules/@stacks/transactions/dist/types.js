"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializePostCondition = exports.serializePostCondition = exports.deserializeLPList = exports.serializeLPList = exports.createLPList = exports.deserializeAssetInfo = exports.serializeAssetInfo = exports.deserializeMemoString = exports.serializeMemoString = exports.createMemoString = exports.codeBodyString = exports.deserializeLPString = exports.serializeLPString = exports.deserializePrincipal = exports.serializePrincipal = exports.deserializeAddress = exports.serializeAddress = exports.addressFromPublicKeys = exports.addressFromHashMode = exports.createEmptyAddress = exports.deserializeStacksMessage = exports.serializeStacksMessage = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("./constants");
const keys_1 = require("./keys");
const utils_1 = require("./utils");
const postcondition_types_1 = require("./postcondition-types");
const payload_1 = require("./payload");
const errors_1 = require("./errors");
const signature_1 = require("./signature");
const common_2 = require("./common");
const clarity_1 = require("./clarity");
function serializeStacksMessage(message) {
    switch (message.type) {
        case constants_1.StacksMessageType.Address:
            return serializeAddress(message);
        case constants_1.StacksMessageType.Principal:
            return serializePrincipal(message);
        case constants_1.StacksMessageType.LengthPrefixedString:
            return serializeLPString(message);
        case constants_1.StacksMessageType.MemoString:
            return serializeMemoString(message);
        case constants_1.StacksMessageType.AssetInfo:
            return serializeAssetInfo(message);
        case constants_1.StacksMessageType.PostCondition:
            return serializePostCondition(message);
        case constants_1.StacksMessageType.PublicKey:
            return (0, keys_1.serializePublicKey)(message);
        case constants_1.StacksMessageType.LengthPrefixedList:
            return serializeLPList(message);
        case constants_1.StacksMessageType.Payload:
            return (0, payload_1.serializePayload)(message);
        case constants_1.StacksMessageType.TransactionAuthField:
            return (0, signature_1.serializeTransactionAuthField)(message);
        case constants_1.StacksMessageType.MessageSignature:
            return (0, signature_1.serializeMessageSignature)(message);
    }
}
exports.serializeStacksMessage = serializeStacksMessage;
function deserializeStacksMessage(bufferReader, type, listType) {
    switch (type) {
        case constants_1.StacksMessageType.Address:
            return deserializeAddress(bufferReader);
        case constants_1.StacksMessageType.Principal:
            return deserializePrincipal(bufferReader);
        case constants_1.StacksMessageType.LengthPrefixedString:
            return deserializeLPString(bufferReader);
        case constants_1.StacksMessageType.MemoString:
            return deserializeMemoString(bufferReader);
        case constants_1.StacksMessageType.AssetInfo:
            return deserializeAssetInfo(bufferReader);
        case constants_1.StacksMessageType.PostCondition:
            return deserializePostCondition(bufferReader);
        case constants_1.StacksMessageType.PublicKey:
            return (0, keys_1.deserializePublicKey)(bufferReader);
        case constants_1.StacksMessageType.Payload:
            return (0, payload_1.deserializePayload)(bufferReader);
        case constants_1.StacksMessageType.LengthPrefixedList:
            if (!listType) {
                throw new errors_1.DeserializationError('No List Type specified');
            }
            return deserializeLPList(bufferReader, listType);
        case constants_1.StacksMessageType.MessageSignature:
            return (0, signature_1.deserializeMessageSignature)(bufferReader);
        default:
            throw new Error('Could not recognize StacksMessageType');
    }
}
exports.deserializeStacksMessage = deserializeStacksMessage;
function createEmptyAddress() {
    return {
        type: constants_1.StacksMessageType.Address,
        version: constants_1.AddressVersion.MainnetSingleSig,
        hash160: '0'.repeat(40),
    };
}
exports.createEmptyAddress = createEmptyAddress;
function addressFromHashMode(hashMode, txVersion, data) {
    const version = (0, common_2.addressHashModeToVersion)(hashMode, txVersion);
    return (0, common_2.addressFromVersionHash)(version, data);
}
exports.addressFromHashMode = addressFromHashMode;
function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {
    if (publicKeys.length === 0) {
        throw Error('Invalid number of public keys');
    }
    if (hashMode === constants_1.AddressHashMode.SerializeP2PKH || hashMode === constants_1.AddressHashMode.SerializeP2WPKH) {
        if (publicKeys.length !== 1 || numSigs !== 1) {
            throw Error('Invalid number of public keys or signatures');
        }
    }
    if (hashMode === constants_1.AddressHashMode.SerializeP2WPKH || hashMode === constants_1.AddressHashMode.SerializeP2WSH) {
        for (let i = 0; i < publicKeys.length; i++) {
            if (!(0, keys_1.isCompressed)(publicKeys[i])) {
                throw Error('Public keys must be compressed for segwit');
            }
        }
    }
    switch (hashMode) {
        case constants_1.AddressHashMode.SerializeP2PKH:
            return (0, common_2.addressFromVersionHash)(version, (0, utils_1.hashP2PKH)(publicKeys[0].data));
        case constants_1.AddressHashMode.SerializeP2WPKH:
            return (0, common_2.addressFromVersionHash)(version, (0, utils_1.hashP2WPKH)(publicKeys[0].data));
        case constants_1.AddressHashMode.SerializeP2SH:
            return (0, common_2.addressFromVersionHash)(version, (0, utils_1.hashP2SH)(numSigs, publicKeys.map(keys_1.serializePublicKey)));
        case constants_1.AddressHashMode.SerializeP2WSH:
            return (0, common_2.addressFromVersionHash)(version, (0, utils_1.hashP2WSH)(numSigs, publicKeys.map(keys_1.serializePublicKey)));
    }
}
exports.addressFromPublicKeys = addressFromPublicKeys;
function serializeAddress(address) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendHexString((0, common_1.intToHex)(address.version, 1));
    bufferArray.appendHexString(address.hash160);
    return bufferArray.concatBuffer();
}
exports.serializeAddress = serializeAddress;
function deserializeAddress(bufferReader) {
    const version = (0, common_1.hexToInt)(bufferReader.readBuffer(1).toString('hex'));
    const data = bufferReader.readBuffer(20).toString('hex');
    return { type: constants_1.StacksMessageType.Address, version, hash160: data };
}
exports.deserializeAddress = deserializeAddress;
function serializePrincipal(principal) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.push(common_1.Buffer.from([principal.prefix]));
    bufferArray.push(serializeAddress(principal.address));
    if (principal.prefix === constants_1.PostConditionPrincipalID.Contract) {
        bufferArray.push(serializeLPString(principal.contractName));
    }
    return bufferArray.concatBuffer();
}
exports.serializePrincipal = serializePrincipal;
function deserializePrincipal(bufferReader) {
    const prefix = bufferReader.readUInt8Enum(constants_1.PostConditionPrincipalID, _ => {
        throw new errors_1.DeserializationError('Unexpected Principal payload type: ${n}');
    });
    const address = deserializeAddress(bufferReader);
    if (prefix === constants_1.PostConditionPrincipalID.Standard) {
        return { type: constants_1.StacksMessageType.Principal, prefix, address };
    }
    const contractName = deserializeLPString(bufferReader);
    return {
        type: constants_1.StacksMessageType.Principal,
        prefix,
        address,
        contractName,
    };
}
exports.deserializePrincipal = deserializePrincipal;
function serializeLPString(lps) {
    const bufferArray = new utils_1.BufferArray();
    const contentBuffer = common_1.Buffer.from(lps.content);
    const length = contentBuffer.byteLength;
    bufferArray.appendHexString((0, common_1.intToHex)(length, lps.lengthPrefixBytes));
    bufferArray.push(contentBuffer);
    return bufferArray.concatBuffer();
}
exports.serializeLPString = serializeLPString;
function deserializeLPString(bufferReader, prefixBytes, maxLength) {
    prefixBytes = prefixBytes ? prefixBytes : 1;
    const length = (0, common_1.hexToInt)(bufferReader.readBuffer(prefixBytes).toString('hex'));
    const content = bufferReader.readBuffer(length).toString();
    return (0, postcondition_types_1.createLPString)(content, prefixBytes, maxLength !== null && maxLength !== void 0 ? maxLength : 128);
}
exports.deserializeLPString = deserializeLPString;
function codeBodyString(content) {
    return (0, postcondition_types_1.createLPString)(content, 4, 100000);
}
exports.codeBodyString = codeBodyString;
function createMemoString(content) {
    if (content && (0, utils_1.exceedsMaxLengthBytes)(content, constants_1.MEMO_MAX_LENGTH_BYTES)) {
        throw new Error(`Memo exceeds maximum length of ${constants_1.MEMO_MAX_LENGTH_BYTES.toString()} bytes`);
    }
    return { type: constants_1.StacksMessageType.MemoString, content };
}
exports.createMemoString = createMemoString;
function serializeMemoString(memoString) {
    const bufferArray = new utils_1.BufferArray();
    const contentBuffer = common_1.Buffer.from(memoString.content);
    const paddedContent = (0, utils_1.rightPadHexToLength)(contentBuffer.toString('hex'), constants_1.MEMO_MAX_LENGTH_BYTES * 2);
    bufferArray.push(common_1.Buffer.from(paddedContent, 'hex'));
    return bufferArray.concatBuffer();
}
exports.serializeMemoString = serializeMemoString;
function deserializeMemoString(bufferReader) {
    const content = bufferReader.readBuffer(constants_1.MEMO_MAX_LENGTH_BYTES).toString();
    return { type: constants_1.StacksMessageType.MemoString, content };
}
exports.deserializeMemoString = deserializeMemoString;
function serializeAssetInfo(info) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.push(serializeAddress(info.address));
    bufferArray.push(serializeLPString(info.contractName));
    bufferArray.push(serializeLPString(info.assetName));
    return bufferArray.concatBuffer();
}
exports.serializeAssetInfo = serializeAssetInfo;
function deserializeAssetInfo(bufferReader) {
    return {
        type: constants_1.StacksMessageType.AssetInfo,
        address: deserializeAddress(bufferReader),
        contractName: deserializeLPString(bufferReader),
        assetName: deserializeLPString(bufferReader),
    };
}
exports.deserializeAssetInfo = deserializeAssetInfo;
function createLPList(values, lengthPrefixBytes) {
    return {
        type: constants_1.StacksMessageType.LengthPrefixedList,
        lengthPrefixBytes: lengthPrefixBytes || 4,
        values,
    };
}
exports.createLPList = createLPList;
function serializeLPList(lpList) {
    const list = lpList.values;
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendHexString((0, common_1.intToHex)(list.length, lpList.lengthPrefixBytes));
    for (let index = 0; index < list.length; index++) {
        bufferArray.push(serializeStacksMessage(list[index]));
    }
    return bufferArray.concatBuffer();
}
exports.serializeLPList = serializeLPList;
function deserializeLPList(bufferReader, type, lengthPrefixBytes) {
    const length = (0, common_1.hexToInt)(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));
    const l = [];
    for (let index = 0; index < length; index++) {
        switch (type) {
            case constants_1.StacksMessageType.Address:
                l.push(deserializeAddress(bufferReader));
                break;
            case constants_1.StacksMessageType.LengthPrefixedString:
                l.push(deserializeLPString(bufferReader));
                break;
            case constants_1.StacksMessageType.MemoString:
                l.push(deserializeMemoString(bufferReader));
                break;
            case constants_1.StacksMessageType.AssetInfo:
                l.push(deserializeAssetInfo(bufferReader));
                break;
            case constants_1.StacksMessageType.PostCondition:
                l.push(deserializePostCondition(bufferReader));
                break;
            case constants_1.StacksMessageType.PublicKey:
                l.push((0, keys_1.deserializePublicKey)(bufferReader));
                break;
            case constants_1.StacksMessageType.TransactionAuthField:
                l.push((0, signature_1.deserializeTransactionAuthField)(bufferReader));
                break;
        }
    }
    return createLPList(l, lengthPrefixBytes);
}
exports.deserializeLPList = deserializeLPList;
function serializePostCondition(postCondition) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendByte(postCondition.conditionType);
    bufferArray.push(serializePrincipal(postCondition.principal));
    if (postCondition.conditionType === constants_1.PostConditionType.Fungible ||
        postCondition.conditionType === constants_1.PostConditionType.NonFungible) {
        bufferArray.push(serializeAssetInfo(postCondition.assetInfo));
    }
    if (postCondition.conditionType === constants_1.PostConditionType.NonFungible) {
        bufferArray.push((0, clarity_1.serializeCV)(postCondition.assetName));
    }
    bufferArray.appendByte(postCondition.conditionCode);
    if (postCondition.conditionType === constants_1.PostConditionType.STX ||
        postCondition.conditionType === constants_1.PostConditionType.Fungible) {
        bufferArray.push((0, common_1.intToBytes)(postCondition.amount, false, 8));
    }
    return bufferArray.concatBuffer();
}
exports.serializePostCondition = serializePostCondition;
function deserializePostCondition(bufferReader) {
    const postConditionType = bufferReader.readUInt8Enum(constants_1.PostConditionType, n => {
        throw new errors_1.DeserializationError(`Could not read ${n} as PostConditionType`);
    });
    const principal = deserializePrincipal(bufferReader);
    let conditionCode;
    let assetInfo;
    let amount;
    switch (postConditionType) {
        case constants_1.PostConditionType.STX:
            conditionCode = bufferReader.readUInt8Enum(constants_1.FungibleConditionCode, n => {
                throw new errors_1.DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.STX,
                principal,
                conditionCode,
                amount,
            };
        case constants_1.PostConditionType.Fungible:
            assetInfo = deserializeAssetInfo(bufferReader);
            conditionCode = bufferReader.readUInt8Enum(constants_1.FungibleConditionCode, n => {
                throw new errors_1.DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.Fungible,
                principal,
                conditionCode,
                amount,
                assetInfo,
            };
        case constants_1.PostConditionType.NonFungible:
            assetInfo = deserializeAssetInfo(bufferReader);
            const assetName = (0, clarity_1.deserializeCV)(bufferReader);
            conditionCode = bufferReader.readUInt8Enum(constants_1.NonFungibleConditionCode, n => {
                throw new errors_1.DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.NonFungible,
                principal,
                conditionCode,
                assetInfo,
                assetName,
            };
    }
}
exports.deserializePostCondition = deserializePostCondition;
//# sourceMappingURL=types.js.map