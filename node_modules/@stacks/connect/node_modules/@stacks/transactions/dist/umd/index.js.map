{"version":3,"file":"index.js","mappings":"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","sources":["webpack://StacksTransactions/webpack/universalModuleDefinition","webpack://StacksTransactions/../../node_modules/base64-js/index.js","webpack://StacksTransactions/../../node_modules/buffer/index.js","webpack://StacksTransactions/../../node_modules/c32check/lib/address.js","webpack://StacksTransactions/../../node_modules/c32check/lib/base58check.js","webpack://StacksTransactions/../../node_modules/c32check/lib/checksum.js","webpack://StacksTransactions/../../node_modules/c32check/lib/encoding.js","webpack://StacksTransactions/../../node_modules/c32check/lib/index.js","webpack://StacksTransactions/../../node_modules/c32check/node_modules/base-x/src/index.js","webpack://StacksTransactions/../../node_modules/c32check/node_modules/buffer/index.js","webpack://StacksTransactions/../../node_modules/cross-fetch/dist/browser-polyfill.js","webpack://StacksTransactions/../../node_modules/cross-sha256/index.js","webpack://StacksTransactions/../../node_modules/cross-sha256/node_modules/buffer/index.js","webpack://StacksTransactions/../../node_modules/ieee754/index.js","webpack://StacksTransactions/../../node_modules/lodash.clonedeep/index.js","webpack://StacksTransactions/../../node_modules/safe-buffer/index.js","webpack://StacksTransactions/../../node_modules/smart-buffer/build/smartbuffer.js","webpack://StacksTransactions/../../node_modules/smart-buffer/build/utils.js","webpack://StacksTransactions/webpack/bootstrap","webpack://StacksTransactions/webpack/runtime/compat get default export","webpack://StacksTransactions/webpack/runtime/define property getters","webpack://StacksTransactions/webpack/runtime/global","webpack://StacksTransactions/webpack/runtime/hasOwnProperty shorthand","webpack://StacksTransactions/webpack/runtime/make namespace object","webpack://StacksTransactions/webpack/runtime/node module decorator","webpack://StacksTransactions/../common/dist/esm/utils.js","webpack://StacksTransactions/./src/constants.ts","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/cryptoBrowser.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/utils.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/_sha2.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/ripemd160.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/sha256.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/_u64.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/sha512.js","webpack://StacksTransactions/../../node_modules/@noble/secp256k1/lib/esm/index.js","webpack://StacksTransactions/../../node_modules/@noble/hashes/esm/hmac.js","webpack://StacksTransactions/../common/dist/esm/signatures.js","webpack://StacksTransactions/../common/dist/esm/constants.js","webpack://StacksTransactions/./src/common.ts","webpack://StacksTransactions/./src/keys.ts","webpack://StacksTransactions/../common/dist/esm/keys.js","webpack://StacksTransactions/./src/postcondition-types.ts","webpack://StacksTransactions/./src/clarity/constants.ts","webpack://StacksTransactions/./src/clarity/types/intCV.ts","webpack://StacksTransactions/./src/clarity/types/bufferCV.ts","webpack://StacksTransactions/./src/clarity/types/booleanCV.ts","webpack://StacksTransactions/./src/clarity/types/principalCV.ts","webpack://StacksTransactions/./src/clarity/types/responseCV.ts","webpack://StacksTransactions/./src/clarity/types/optionalCV.ts","webpack://StacksTransactions/./src/clarity/types/listCV.ts","webpack://StacksTransactions/./src/clarity/types/tupleCV.ts","webpack://StacksTransactions/./src/bufferReader.ts","webpack://StacksTransactions/./src/errors.ts","webpack://StacksTransactions/./src/clarity/types/stringCV.ts","webpack://StacksTransactions/./src/clarity/deserialize.ts","webpack://StacksTransactions/./src/payload.ts","webpack://StacksTransactions/./src/signature.ts","webpack://StacksTransactions/./src/types.ts","webpack://StacksTransactions/./src/clarity/serialize.ts","webpack://StacksTransactions/./src/utils.ts","webpack://StacksTransactions/./src/authorization.ts","webpack://StacksTransactions/./src/transaction.ts","webpack://StacksTransactions/./src/postcondition.ts","webpack://StacksTransactions/./src/clarity/clarityValue.ts","webpack://StacksTransactions/../network/dist/esm/fetch.js","webpack://StacksTransactions/../network/dist/esm/network.js","webpack://StacksTransactions/./src/contract-abi.ts","webpack://StacksTransactions/./src/signer.ts","webpack://StacksTransactions/./src/builders.ts","webpack://StacksTransactions/./src/structuredDataSignature.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StacksTransactions\"] = factory();\n\telse\n\t\troot[\"StacksTransactions\"] = factory();\n})(this, () => {\nreturn ","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;\nvar checksum_1 = require(\"./checksum\");\nvar base58check = require(\"./base58check\");\nexports.versions = {\n    mainnet: {\n        p2pkh: 22,\n        p2sh: 20 // 'M'\n    },\n    testnet: {\n        p2pkh: 26,\n        p2sh: 21 // 'N'\n    }\n};\n// address conversion : bitcoin to stacks\nvar ADDR_BITCOIN_TO_STACKS = {};\nADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;\nADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh;\n// address conversion : stacks to bitcoin \nvar ADDR_STACKS_TO_BITCOIN = {};\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;\n/**\n * Make a c32check address with the given version and hash160\n * The only difference between a c32check string and c32 address\n * is that the letter 'S' is pre-pended.\n * @param {number} version - the address version number\n * @param {string} hash160hex - the hash160 to encode (must be a hash160)\n * @returns {string} the address\n */\nfunction c32address(version, hash160hex) {\n    if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {\n        throw new Error('Invalid argument: not a hash160 hex string');\n    }\n    var c32string = checksum_1.c32checkEncode(version, hash160hex);\n    return \"S\" + c32string;\n}\nexports.c32address = c32address;\n/**\n * Decode a c32 address into its version and hash160\n * @param {string} c32addr - the c32check-encoded address\n * @returns {[number, string]} a tuple with the version and hash160\n */\nfunction c32addressDecode(c32addr) {\n    if (c32addr.length <= 5) {\n        throw new Error('Invalid c32 address: invalid length');\n    }\n    if (c32addr[0] != 'S') {\n        throw new Error('Invalid c32 address: must start with \"S\"');\n    }\n    return checksum_1.c32checkDecode(c32addr.slice(1));\n}\nexports.c32addressDecode = c32addressDecode;\n/*\n * Convert a base58check address to a c32check address.\n * Try to convert the version number if one is not given.\n * @param {string} b58check - the base58check encoded address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the c32 address with the given version number (or the\n *   semantically-equivalent c32 version number, if not given)\n */\nfunction b58ToC32(b58check, version) {\n    if (version === void 0) { version = -1; }\n    var addrInfo = base58check.decode(b58check);\n    var hash160String = addrInfo.data.toString('hex');\n    var addrVersion = parseInt(addrInfo.prefix.toString('hex'), 16);\n    var stacksVersion;\n    if (version < 0) {\n        stacksVersion = addrVersion;\n        if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== undefined) {\n            stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];\n        }\n    }\n    else {\n        stacksVersion = version;\n    }\n    return c32address(stacksVersion, hash160String);\n}\nexports.b58ToC32 = b58ToC32;\n/*\n * Convert a c32check address to a base58check address.\n * @param {string} c32string - the c32check address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the base58 address with the given version number (or the\n *    semantically-equivalent bitcoin version number, if not given)\n */\nfunction c32ToB58(c32string, version) {\n    if (version === void 0) { version = -1; }\n    var addrInfo = c32addressDecode(c32string);\n    var stacksVersion = addrInfo[0];\n    var hash160String = addrInfo[1];\n    var bitcoinVersion;\n    if (version < 0) {\n        bitcoinVersion = stacksVersion;\n        if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== undefined) {\n            bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];\n        }\n    }\n    else {\n        bitcoinVersion = version;\n    }\n    var prefix = bitcoinVersion.toString(16);\n    if (prefix.length === 1) {\n        prefix = \"0\" + prefix;\n    }\n    return base58check.encode(hash160String, prefix);\n}\nexports.c32ToB58 = c32ToB58;\n","/*\n * From https://github.com/wzbg/base58check\n * @Author: zyc\n * @Date:   2016-09-11 23:36:05\n */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decode = exports.encode = void 0;\nvar buffer_1 = require(\"buffer/\");\nvar cross_sha256_1 = require(\"cross-sha256\");\nvar basex = require(\"base-x\");\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nfunction encode(data, prefix, encoding) {\n    if (prefix === void 0) { prefix = '00'; }\n    if (encoding === void 0) { encoding = 'hex'; }\n    if (typeof data === 'string') {\n        data = new buffer_1.Buffer(data, encoding);\n    }\n    if (!(data instanceof buffer_1.Buffer)) {\n        throw new TypeError('\"data\" argument must be an Array of Buffers');\n    }\n    if (!(prefix instanceof buffer_1.Buffer)) {\n        prefix = new buffer_1.Buffer(prefix, encoding);\n    }\n    var hash = buffer_1.Buffer.concat([prefix, data]);\n    hash = cross_sha256_1.hashSha256(hash);\n    hash = cross_sha256_1.hashSha256(hash);\n    hash = buffer_1.Buffer.concat([prefix, data, hash.slice(0, 4)]);\n    return basex(ALPHABET).encode(hash);\n}\nexports.encode = encode;\nfunction decode(string, encoding) {\n    var buffer = new buffer_1.Buffer(basex(ALPHABET).decode(string));\n    var prefix = buffer.slice(0, 1);\n    var data = buffer.slice(1, -4);\n    var hash = buffer_1.Buffer.concat([prefix, data]);\n    hash = cross_sha256_1.hashSha256(hash);\n    hash = cross_sha256_1.hashSha256(hash);\n    buffer.slice(-4).forEach(function (check, index) {\n        if (check !== hash[index]) {\n            throw new Error('Invalid checksum');\n        }\n    });\n    if (encoding) {\n        prefix = prefix.toString(encoding);\n        data = data.toString(encoding);\n    }\n    return { prefix: prefix, data: data };\n}\nexports.decode = decode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32checkDecode = exports.c32checkEncode = void 0;\nvar buffer_1 = require(\"buffer/\");\nvar encoding_1 = require(\"./encoding\");\nvar cross_sha256_1 = require(\"cross-sha256\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */\nfunction c32checksum(dataHex) {\n    var dataHash = cross_sha256_1.hashSha256(cross_sha256_1.hashSha256(buffer_1.Buffer.from(dataHex, 'hex')));\n    var checksum = dataHash.slice(0, 4).toString('hex');\n    return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */\nfunction c32checkEncode(version, data) {\n    if (version < 0 || version >= 32) {\n        throw new Error('Invalid version (must be between 0 and 31)');\n    }\n    if (!data.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Invalid data (not a hex string)');\n    }\n    data = data.toLowerCase();\n    if (data.length % 2 !== 0) {\n        data = \"0\" + data;\n    }\n    var versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = \"0\" + versionHex;\n    }\n    var checksumHex = c32checksum(\"\" + versionHex + data);\n    var c32str = encoding_1.c32encode(\"\" + data + checksumHex);\n    return \"\" + encoding_1.c32[version] + c32str;\n}\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */\nfunction c32checkDecode(c32data) {\n    c32data = encoding_1.c32normalize(c32data);\n    var dataHex = encoding_1.c32decode(c32data.slice(1));\n    var versionChar = c32data[0];\n    var version = encoding_1.c32.indexOf(versionChar);\n    var checksum = dataHex.slice(-8);\n    var versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = \"0\" + versionHex;\n    }\n    if (c32checksum(\"\" + versionHex + dataHex.substring(0, dataHex.length - 8)) !== checksum) {\n        throw new Error('Invalid c32check string: checksum mismatch');\n    }\n    return [version, dataHex.substring(0, dataHex.length - 8)];\n}\nexports.c32checkDecode = c32checkDecode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\nvar buffer_1 = require(\"buffer/\");\nexports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\nvar hex = '0123456789abcdef';\n/**\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\n * to be big-endian (and the resulting c32 string will be as well).\n * @param {string} inputHex - the input to encode\n * @param {number} minLength - the minimum length of the c32 string\n * @returns {string} the c32check-encoded representation of the data, as a string\n */\nfunction c32encode(inputHex, minLength) {\n    // must be hex\n    if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Not a hex-encoded string');\n    }\n    if ((inputHex.length) % 2 !== 0) {\n        inputHex = \"0\" + inputHex;\n    }\n    inputHex = inputHex.toLowerCase();\n    var res = [];\n    var carry = 0;\n    for (var i = inputHex.length - 1; i >= 0; i--) {\n        if (carry < 4) {\n            var currentCode = hex.indexOf(inputHex[i]) >> carry;\n            var nextCode = 0;\n            if (i !== 0) {\n                nextCode = hex.indexOf(inputHex[i - 1]);\n            }\n            // carry = 0, nextBits is 1, carry = 1, nextBits is 2\n            var nextBits = 1 + carry;\n            var nextLowBits = (nextCode % (1 << nextBits)) << (5 - nextBits);\n            var curC32Digit = exports.c32[currentCode + nextLowBits];\n            carry = nextBits;\n            res.unshift(curC32Digit);\n        }\n        else {\n            carry = 0;\n        }\n    }\n    var C32leadingZeros = 0;\n    for (var i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            C32leadingZeros++;\n        }\n    }\n    res = res.slice(C32leadingZeros);\n    var zeroPrefix = buffer_1.Buffer.from(inputHex, 'hex').toString().match(/^\\u0000*/);\n    var numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\n    for (var i = 0; i < numLeadingZeroBytesInHex; i++) {\n        res.unshift(exports.c32[0]);\n    }\n    if (minLength) {\n        var count = minLength - res.length;\n        for (var i = 0; i < count; i++) {\n            res.unshift(exports.c32[0]);\n        }\n    }\n    return res.join('');\n}\nexports.c32encode = c32encode;\n/*\n * Normalize a c32 string\n * @param {string} c32input - the c32-encoded input string\n * @returns {string} the canonical representation of the c32 input string\n */\nfunction c32normalize(c32input) {\n    // must be upper-case\n    // replace all O's with 0's\n    // replace all I's and L's with 1's\n    return c32input.toUpperCase()\n        .replace(/O/g, '0')\n        .replace(/L|I/g, '1');\n}\nexports.c32normalize = c32normalize;\n/*\n * Decode a c32 string back into a hex string.  Note that the c32 input\n * string is assumed to be big-endian (and the resulting hex string will\n * be as well).\n * @param {string} c32input - the c32-encoded input to decode\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\n * @returns {string} the hex-encoded representation of the data, as a string\n */\nfunction c32decode(c32input, minLength) {\n    c32input = c32normalize(c32input);\n    // must result in a c32 string\n    if (!c32input.match(\"^[\" + exports.c32 + \"]*$\")) {\n        throw new Error('Not a c32-encoded string');\n    }\n    var zeroPrefix = c32input.match(\"^\" + exports.c32[0] + \"*\");\n    var numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\n    var res = [];\n    var carry = 0;\n    var carryBits = 0;\n    for (var i = c32input.length - 1; i >= 0; i--) {\n        if (carryBits === 4) {\n            res.unshift(hex[carry]);\n            carryBits = 0;\n            carry = 0;\n        }\n        var currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\n        var currentValue = currentCode + carry;\n        var currentHexDigit = hex[currentValue % 16];\n        carryBits += 1;\n        carry = currentValue >> 4;\n        if (carry > 1 << carryBits) {\n            throw new Error('Panic error in decoding.');\n        }\n        res.unshift(currentHexDigit);\n    }\n    // one last carry\n    res.unshift(hex[carry]);\n    if (res.length % 2 === 1) {\n        res.unshift('0');\n    }\n    var hexLeadingZeros = 0;\n    for (var i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            hexLeadingZeros++;\n        }\n    }\n    res = res.slice(hexLeadingZeros - (hexLeadingZeros % 2));\n    var hexStr = res.join('');\n    for (var i = 0; i < numLeadingZeroBytes; i++) {\n        hexStr = \"00\" + hexStr;\n    }\n    if (minLength) {\n        var count = minLength * 2 - hexStr.length;\n        for (var i = 0; i < count; i += 2) {\n            hexStr = \"00\" + hexStr;\n        }\n    }\n    return hexStr;\n}\nexports.c32decode = c32decode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.b58ToC32 = exports.c32ToB58 = exports.versions = exports.c32normalize = exports.c32addressDecode = exports.c32address = exports.c32checkDecode = exports.c32checkEncode = exports.c32decode = exports.c32encode = void 0;\nvar encoding_1 = require(\"./encoding\");\nObject.defineProperty(exports, \"c32encode\", { enumerable: true, get: function () { return encoding_1.c32encode; } });\nObject.defineProperty(exports, \"c32decode\", { enumerable: true, get: function () { return encoding_1.c32decode; } });\nObject.defineProperty(exports, \"c32normalize\", { enumerable: true, get: function () { return encoding_1.c32normalize; } });\nvar checksum_1 = require(\"./checksum\");\nObject.defineProperty(exports, \"c32checkEncode\", { enumerable: true, get: function () { return checksum_1.c32checkEncode; } });\nObject.defineProperty(exports, \"c32checkDecode\", { enumerable: true, get: function () { return checksum_1.c32checkDecode; } });\nvar address_1 = require(\"./address\");\nObject.defineProperty(exports, \"c32address\", { enumerable: true, get: function () { return address_1.c32address; } });\nObject.defineProperty(exports, \"c32addressDecode\", { enumerable: true, get: function () { return address_1.c32addressDecode; } });\nObject.defineProperty(exports, \"c32ToB58\", { enumerable: true, get: function () { return address_1.c32ToB58; } });\nObject.defineProperty(exports, \"b58ToC32\", { enumerable: true, get: function () { return address_1.b58ToC32; } });\nObject.defineProperty(exports, \"versions\", { enumerable: true, get: function () { return address_1.versions; } });\n","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n","(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(typeof self !== 'undefined' ? self : this);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashSha256 = exports.sha256 = exports.sha256nodeCrypto = exports.sha256js = void 0;\nvar buffer_1 = require(\"buffer/\");\n/**\n * From https://github.com/crypto-browserify/sha.js/blob/master/sha256.js\n *\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\nvar sha256js = /** @class */ (function () {\n    function sha256js() {\n        this._blockSize = 64;\n        this._finalSize = 56;\n        this._len = 0;\n        this._w = new Array(64);\n        this._a = 0x6a09e667;\n        this._b = 0xbb67ae85;\n        this._c = 0x3c6ef372;\n        this._d = 0xa54ff53a;\n        this._e = 0x510e527f;\n        this._f = 0x9b05688c;\n        this._g = 0x1f83d9ab;\n        this._h = 0x5be0cd19;\n        this._block = buffer_1.Buffer.alloc(this._blockSize);\n    }\n    sha256js.prototype.update = function (data, encoding) {\n        if (typeof data === 'string') {\n            encoding = encoding || 'utf8';\n            data = buffer_1.Buffer.from(data, encoding);\n        }\n        var block = this._block;\n        var blockSize = this._blockSize;\n        var length = data.length;\n        var accum = this._len;\n        for (var offset = 0; offset < length;) {\n            var assigned = accum % blockSize;\n            var remainder = Math.min(length - offset, blockSize - assigned);\n            for (var i = 0; i < remainder; i++) {\n                block[assigned + i] = data[offset + i];\n            }\n            accum += remainder;\n            offset += remainder;\n            if ((accum % blockSize) === 0) {\n                this._update(block);\n            }\n        }\n        this._len += length;\n        return this;\n    };\n    sha256js.prototype.digest = function (encoding) {\n        var rem = this._len % this._blockSize;\n        this._block[rem] = 0x80;\n        // zero (rem + 1) trailing bits, where (rem + 1) is the smallest\n        // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize\n        this._block.fill(0, rem + 1);\n        if (rem >= this._finalSize) {\n            this._update(this._block);\n            this._block.fill(0);\n        }\n        var bits = this._len * 8;\n        // uint32\n        if (bits <= 0xffffffff) {\n            this._block.writeUInt32BE(bits, this._blockSize - 4);\n            // uint64\n        }\n        else {\n            var lowBits = (bits & 0xffffffff) >>> 0;\n            var highBits = (bits - lowBits) / 0x100000000;\n            this._block.writeUInt32BE(highBits, this._blockSize - 8);\n            this._block.writeUInt32BE(lowBits, this._blockSize - 4);\n        }\n        this._update(this._block);\n        var hash = buffer_1.Buffer.alloc(32);\n        hash.writeInt32BE(this._a, 0);\n        hash.writeInt32BE(this._b, 4);\n        hash.writeInt32BE(this._c, 8);\n        hash.writeInt32BE(this._d, 12);\n        hash.writeInt32BE(this._e, 16);\n        hash.writeInt32BE(this._f, 20);\n        hash.writeInt32BE(this._g, 24);\n        hash.writeInt32BE(this._h, 28);\n        return encoding ? hash.toString(encoding) : hash;\n    };\n    sha256js.prototype.ch = function (x, y, z) {\n        return z ^ (x & (y ^ z));\n    };\n    sha256js.prototype.maj = function (x, y, z) {\n        return (x & y) | (z & (x | y));\n    };\n    sha256js.prototype.sigma0 = function (x) {\n        return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);\n    };\n    sha256js.prototype.sigma1 = function (x) {\n        return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);\n    };\n    sha256js.prototype.gamma0 = function (x) {\n        return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3);\n    };\n    sha256js.prototype.gamma1 = function (x) {\n        return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10);\n    };\n    sha256js.prototype._update = function (M) {\n        var W = this._w;\n        var a = this._a | 0;\n        var b = this._b | 0;\n        var c = this._c | 0;\n        var d = this._d | 0;\n        var e = this._e | 0;\n        var f = this._f | 0;\n        var g = this._g | 0;\n        var h = this._h | 0;\n        var i = 0;\n        for (; i < 16; ++i)\n            W[i] = M.readInt32BE(i * 4);\n        for (; i < 64; ++i)\n            W[i] = (this.gamma1(W[i - 2]) + W[i - 7] + this.gamma0(W[i - 15]) + W[i - 16]) | 0;\n        for (var j = 0; j < 64; ++j) {\n            var T1 = (h + this.sigma1(e) + this.ch(e, f, g) + sha256js.K[j] + W[j]) | 0;\n            var T2 = (this.sigma0(a) + this.maj(a, b, c)) | 0;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) | 0;\n        }\n        this._a = (a + this._a) | 0;\n        this._b = (b + this._b) | 0;\n        this._c = (c + this._c) | 0;\n        this._d = (d + this._d) | 0;\n        this._e = (e + this._e) | 0;\n        this._f = (f + this._f) | 0;\n        this._g = (g + this._g) | 0;\n        this._h = (h + this._h) | 0;\n    };\n    sha256js.K = [\n        0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n        0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n        0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n        0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n        0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n        0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n        0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n        0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n        0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n        0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n        0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n        0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n        0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n        0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n        0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n        0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n    ];\n    return sha256js;\n}());\nexports.sha256js = sha256js;\nvar sha256nodeCrypto = /** @class */ (function () {\n    function sha256nodeCrypto() {\n        if (!sha256nodeCrypto.useCryptoModuleCache || sha256nodeCrypto.nodeCryptoCreateHash === undefined) {\n            sha256nodeCrypto.nodeCryptoCreateHash = require('crypto').createHash;\n        }\n        this.hash = sha256nodeCrypto.nodeCryptoCreateHash('sha256');\n    }\n    sha256nodeCrypto.prototype.update = function (data, encoding) {\n        this.hash.update(data, encoding);\n        return this;\n    };\n    sha256nodeCrypto.prototype.digest = function (encoding) {\n        if (encoding) {\n            return this.hash.digest(encoding);\n        }\n        else {\n            return this.hash.digest();\n        }\n    };\n    sha256nodeCrypto.useCryptoModuleCache = true;\n    return sha256nodeCrypto;\n}());\nexports.sha256nodeCrypto = sha256nodeCrypto;\nvar _nodeCryptoAvailable = undefined;\nfunction isNodeCryptoAvailable() {\n    if (sha256nodeCrypto.useCryptoModuleCache && _nodeCryptoAvailable !== undefined) {\n        return _nodeCryptoAvailable;\n    }\n    var isAvailable = false;\n    try {\n        if (typeof require === 'function') {\n            var cryptoModule = require('crypto');\n            isAvailable = cryptoModule && typeof cryptoModule.createHash === 'function';\n        }\n    }\n    catch (error) {\n        // ignore\n    }\n    _nodeCryptoAvailable = isAvailable;\n    return isAvailable;\n}\nvar sha256 = /** @class */ (function () {\n    function sha256() {\n        if (isNodeCryptoAvailable()) {\n            this.instance = new sha256nodeCrypto();\n        }\n        else {\n            this.instance = new sha256js();\n        }\n    }\n    sha256.prototype.update = function (data, encoding) {\n        this.instance.update(data, encoding);\n        return this;\n    };\n    sha256.prototype.digest = function (encoding) {\n        if (encoding) {\n            return this.instance.digest(encoding);\n        }\n        else {\n            return this.instance.digest();\n        }\n    };\n    return sha256;\n}());\nexports.sha256 = sha256;\n/**\n * Use Nodejs `crypto` module if available, otherwise uses js implementation.\n * @param data Input data to hash.\n */\nfunction hashSha256(data) {\n    return new sha256().update(data).digest();\n}\nexports.hashSha256 = hashSha256;\nexports.default = hashSha256;\n//# sourceMappingURL=index.js.map","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n// The default Buffer size if one is not provided.\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\n// The default string encoding to use for reading/writing strings.\nconst DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\nclass SmartBuffer {\n    /**\n     * Creates a new SmartBuffer instance.\n     *\n     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n     */\n    constructor(options) {\n        this.length = 0;\n        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        if (SmartBuffer.isSmartBufferOptions(options)) {\n            // Checks for encoding\n            if (options.encoding) {\n                utils_1.checkEncoding(options.encoding);\n                this._encoding = options.encoding;\n            }\n            // Checks for initial size length\n            if (options.size) {\n                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n                    this._buff = Buffer.allocUnsafe(options.size);\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n                }\n                // Check for initial Buffer\n            }\n            else if (options.buff) {\n                if (Buffer.isBuffer(options.buff)) {\n                    this._buff = options.buff;\n                    this.length = options.buff.length;\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n                }\n            }\n            else {\n                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n            }\n        }\n        else {\n            // If something was passed but it's not a SmartBufferOptions object\n            if (typeof options !== 'undefined') {\n                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n            }\n            // Otherwise default to sane options\n            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n        }\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n     *\n     * @param size { Number } The size of the internal Buffer.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromSize(size, encoding) {\n        return new this({\n            size: size,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n     *\n     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromBuffer(buff, encoding) {\n        return new this({\n            buff: buff,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n     *\n     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n     */\n    static fromOptions(options) {\n        return new this(options);\n    }\n    /**\n     * Type checking function that determines if an object is a SmartBufferOptions object.\n     */\n    static isSmartBufferOptions(options) {\n        const castOptions = options;\n        return (castOptions &&\n            (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined));\n    }\n    // Signed integers\n    /**\n     * Reads an Int8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n    }\n    /**\n     * Reads an Int16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n    }\n    /**\n     * Reads an Int16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n    }\n    /**\n     * Reads an Int32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n    }\n    /**\n     * Reads an Int32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigInt64BE');\n        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigInt64LE');\n        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\n    }\n    /**\n     * Writes an Int8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt8(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n        return this;\n    }\n    /**\n     * Inserts an Int8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n    }\n    /**\n     * Writes an Int16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an Int16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an Int32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an Int32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigInt64BE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a Int64LE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    // Unsigned Integers\n    /**\n     * Reads an UInt8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n    }\n    /**\n     * Reads an UInt16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n    }\n    /**\n     * Reads an UInt16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n    }\n    /**\n     * Reads an UInt32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n    }\n    /**\n     * Reads an UInt32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigUInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64BE');\n        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigUInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64LE');\n        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\n    }\n    /**\n     * Writes an UInt8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt8(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Inserts an UInt8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Writes an UInt16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an UInt32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigUInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigUInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    // Floating Point\n    /**\n     * Reads an FloatBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readFloatBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n    }\n    /**\n     * Reads an FloatLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readFloatLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n    }\n    /**\n     * Writes a FloatBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertFloatBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Writes a FloatLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertFloatLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    // Double Floating Point\n    /**\n     * Reads an DoublEBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readDoubleBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n    }\n    /**\n     * Reads an DoubleLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readDoubleLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n    }\n    /**\n     * Writes a DoubleBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertDoubleBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Writes a DoubleLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertDoubleLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    // Strings\n    /**\n     * Reads a String from the current read position.\n     *\n     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n     *             the string (Defaults to instance level encoding).\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readString(arg1, encoding) {\n        let lengthVal;\n        // Length provided\n        if (typeof arg1 === 'number') {\n            utils_1.checkLengthValue(arg1);\n            lengthVal = Math.min(arg1, this.length - this._readOffset);\n        }\n        else {\n            encoding = arg1;\n            lengthVal = this.length - this._readOffset;\n        }\n        // Check encoding\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n        this._readOffset += lengthVal;\n        return value;\n    }\n    /**\n     * Inserts a String\n     *\n     * @param value { String } The String value to insert.\n     * @param offset { Number } The offset to insert the string at.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    insertString(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleString(value, true, offset, encoding);\n    }\n    /**\n     * Writes a String\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    writeString(value, arg2, encoding) {\n        return this._handleString(value, false, arg2, encoding);\n    }\n    /**\n     * Reads a null-terminated String from the current read position.\n     *\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readStringNT(encoding) {\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read string value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value.toString(encoding || this._encoding);\n    }\n    /**\n     * Inserts a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    insertStringNT(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertString(value, offset, encoding);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    writeStringNT(value, arg2, encoding) {\n        // Write Values\n        this.writeString(value, arg2, encoding);\n        this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);\n        return this;\n    }\n    // Buffers\n    /**\n     * Reads a Buffer from the internal read position.\n     *\n     * @param length { Number } The length of data to read as a Buffer.\n     *\n     * @return { Buffer }\n     */\n    readBuffer(length) {\n        if (typeof length !== 'undefined') {\n            utils_1.checkLengthValue(length);\n        }\n        const lengthVal = typeof length === 'number' ? length : this.length;\n        const endPoint = Math.min(this.length, this._readOffset + lengthVal);\n        // Read buffer value\n        const value = this._buff.slice(this._readOffset, endPoint);\n        // Increment internal Buffer read offset\n        this._readOffset = endPoint;\n        return value;\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    insertBuffer(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleBuffer(value, true, offset);\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    writeBuffer(value, offset) {\n        return this._handleBuffer(value, false, offset);\n    }\n    /**\n     * Reads a null-terminated Buffer from the current read poisiton.\n     *\n     * @return { Buffer }\n     */\n    readBufferNT() {\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value;\n    }\n    /**\n     * Inserts a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    insertBufferNT(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertBuffer(value, offset);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    writeBufferNT(value, offset) {\n        // Checks for valid numberic value;\n        if (typeof offset !== 'undefined') {\n            utils_1.checkOffsetValue(offset);\n        }\n        // Write Values\n        this.writeBuffer(value, offset);\n        this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n        return this;\n    }\n    /**\n     * Clears the SmartBuffer instance to its original empty state.\n     */\n    clear() {\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        this.length = 0;\n        return this;\n    }\n    /**\n     * Gets the remaining data left to be read from the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    remaining() {\n        return this.length - this._readOffset;\n    }\n    /**\n     * Gets the current read offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    get readOffset() {\n        return this._readOffset;\n    }\n    /**\n     * Sets the read offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */\n    set readOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._readOffset = offset;\n    }\n    /**\n     * Gets the current write offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    get writeOffset() {\n        return this._writeOffset;\n    }\n    /**\n     * Sets the write offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */\n    set writeOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._writeOffset = offset;\n    }\n    /**\n     * Gets the currently set string encoding of the SmartBuffer instance.\n     *\n     * @return { BufferEncoding } The string Buffer encoding currently set.\n     */\n    get encoding() {\n        return this._encoding;\n    }\n    /**\n     * Sets the string encoding of the SmartBuffer instance.\n     *\n     * @param encoding { BufferEncoding } The string Buffer encoding to set.\n     */\n    set encoding(encoding) {\n        utils_1.checkEncoding(encoding);\n        this._encoding = encoding;\n    }\n    /**\n     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n     *\n     * @return { Buffer } The Buffer value.\n     */\n    get internalBuffer() {\n        return this._buff;\n    }\n    /**\n     * Gets the value of the internal managed Buffer (Includes managed data only)\n     *\n     * @param { Buffer }\n     */\n    toBuffer() {\n        return this._buff.slice(0, this.length);\n    }\n    /**\n     * Gets the String value of the internal managed Buffer\n     *\n     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n     */\n    toString(encoding) {\n        const encodingVal = typeof encoding === 'string' ? encoding : this._encoding;\n        // Check for invalid encoding.\n        utils_1.checkEncoding(encodingVal);\n        return this._buff.toString(encodingVal, 0, this.length);\n    }\n    /**\n     * Destroys the SmartBuffer instance.\n     */\n    destroy() {\n        this.clear();\n        return this;\n    }\n    /**\n     * Handles inserting and writing strings.\n     *\n     * @param value { String } The String value to insert.\n     * @param isInsert { Boolean } True if inserting a string, false if writing.\n     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     */\n    _handleString(value, isInsert, arg3, encoding) {\n        let offsetVal = this._writeOffset;\n        let encodingVal = this._encoding;\n        // Check for offset\n        if (typeof arg3 === 'number') {\n            offsetVal = arg3;\n            // Check for encoding\n        }\n        else if (typeof arg3 === 'string') {\n            utils_1.checkEncoding(arg3);\n            encodingVal = arg3;\n        }\n        // Check for encoding (third param)\n        if (typeof encoding === 'string') {\n            utils_1.checkEncoding(encoding);\n            encodingVal = encoding;\n        }\n        // Calculate bytelength of string.\n        const byteLength = Buffer.byteLength(value, encodingVal);\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(byteLength, offsetVal);\n        }\n        else {\n            this._ensureWriteable(byteLength, offsetVal);\n        }\n        // Write value\n        this._buff.write(value, offsetVal, byteLength, encodingVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += byteLength;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof arg3 === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += byteLength;\n            }\n        }\n        return this;\n    }\n    /**\n     * Handles writing or insert of a Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     */\n    _handleBuffer(value, isInsert, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(value.length, offsetVal);\n        }\n        else {\n            this._ensureWriteable(value.length, offsetVal);\n        }\n        // Write buffer value\n        value.copy(this._buff, offsetVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += value.length;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof offset === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += value.length;\n            }\n        }\n        return this;\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to read data.\n     *\n     * @param length { Number } The length of the data that needs to be read.\n     * @param offset { Number } The offset of the data that needs to be read.\n     */\n    ensureReadable(length, offset) {\n        // Offset value defaults to managed read offset.\n        let offsetVal = this._readOffset;\n        // If an offset was provided, use it.\n        if (typeof offset !== 'undefined') {\n            // Checks for valid numberic value;\n            utils_1.checkOffsetValue(offset);\n            // Overide with custom offset.\n            offsetVal = offset;\n        }\n        // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n        if (offsetVal < 0 || offsetVal + length > this.length) {\n            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to insert data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written.\n     */\n    ensureInsertable(dataLength, offset) {\n        // Checks for valid numberic value;\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity.\n        this._ensureCapacity(this.length + dataLength);\n        // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n        if (offset < this.length) {\n            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n        }\n        // Adjust tracked smart buffer length\n        if (offset + dataLength > this.length) {\n            this.length = offset + dataLength;\n        }\n        else {\n            this.length += dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n     */\n    _ensureWriteable(dataLength, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure enough capacity to write data.\n        this._ensureCapacity(offsetVal + dataLength);\n        // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n        if (offsetVal + dataLength > this.length) {\n            this.length = offsetVal + dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n     *\n     * @param minLength { Number } The minimum length of the data needs to be written.\n     */\n    _ensureCapacity(minLength) {\n        const oldLength = this._buff.length;\n        if (minLength > oldLength) {\n            let data = this._buff;\n            let newLength = (oldLength * 3) / 2 + 1;\n            if (newLength < minLength) {\n                newLength = minLength;\n            }\n            this._buff = Buffer.allocUnsafe(newLength);\n            data.copy(this._buff, 0, 0, oldLength);\n        }\n    }\n    /**\n     * Reads a numeric number value using the provided function.\n     *\n     * @typeparam T { number | bigint } The type of the value to be read\n     *\n     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes read.\n     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n     *\n     * @returns { T } the number value\n     */\n    _readNumberValue(func, byteSize, offset) {\n        this.ensureReadable(byteSize, offset);\n        // Call Buffer.readXXXX();\n        const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset);\n        // Adjust internal read offset if an optional read offset was not provided.\n        if (typeof offset === 'undefined') {\n            this._readOffset += byteSize;\n        }\n        return value;\n    }\n    /**\n     * Inserts a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */\n    _insertNumberValue(func, byteSize, value, offset) {\n        // Check for invalid offset values.\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this.ensureInsertable(byteSize, offset);\n        // Call buffer.writeXXXX();\n        func.call(this._buff, value, offset);\n        // Adjusts internally managed write offset.\n        this._writeOffset += byteSize;\n        return this;\n    }\n    /**\n     * Writes a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */\n    _writeNumberValue(func, byteSize, value, offset) {\n        // If an offset was provided, validate it.\n        if (typeof offset === 'number') {\n            // Check if we're writing beyond the bounds of the managed data.\n            if (offset < 0) {\n                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n            }\n            utils_1.checkOffsetValue(offset);\n        }\n        // Default to writeOffset if no offset value was given.\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this._ensureWriteable(byteSize, offsetVal);\n        func.call(this._buff, value, offsetVal);\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\n        if (typeof offset === 'number') {\n            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n        }\n        else {\n            // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n            this._writeOffset += byteSize;\n        }\n        return this;\n    }\n}\nexports.SmartBuffer = SmartBuffer;\n//# sourceMappingURL=smartbuffer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst buffer_1 = require(\"buffer\");\n/**\n * Error strings\n */\nconst ERRORS = {\n    INVALID_ENCODING: 'Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.',\n    INVALID_SMARTBUFFER_SIZE: 'Invalid size provided. Size must be a valid integer greater than zero.',\n    INVALID_SMARTBUFFER_BUFFER: 'Invalid Buffer provided in SmartBufferOptions.',\n    INVALID_SMARTBUFFER_OBJECT: 'Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.',\n    INVALID_OFFSET: 'An invalid offset value was provided.',\n    INVALID_OFFSET_NON_NUMBER: 'An invalid offset value was provided. A numeric value is required.',\n    INVALID_LENGTH: 'An invalid length value was provided.',\n    INVALID_LENGTH_NON_NUMBER: 'An invalid length value was provived. A numeric value is required.',\n    INVALID_TARGET_OFFSET: 'Target offset is beyond the bounds of the internal SmartBuffer data.',\n    INVALID_TARGET_LENGTH: 'Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.',\n    INVALID_READ_BEYOND_BOUNDS: 'Attempted to read beyond the bounds of the managed data.',\n    INVALID_WRITE_BEYOND_BOUNDS: 'Attempted to write beyond the bounds of the managed data.'\n};\nexports.ERRORS = ERRORS;\n/**\n * Checks if a given encoding is a valid Buffer encoding. (Throws an exception if check fails)\n *\n * @param { String } encoding The encoding string to check.\n */\nfunction checkEncoding(encoding) {\n    if (!buffer_1.Buffer.isEncoding(encoding)) {\n        throw new Error(ERRORS.INVALID_ENCODING);\n    }\n}\nexports.checkEncoding = checkEncoding;\n/**\n * Checks if a given number is a finite integer. (Throws an exception if check fails)\n *\n * @param { Number } value The number value to check.\n */\nfunction isFiniteInteger(value) {\n    return typeof value === 'number' && isFinite(value) && isInteger(value);\n}\nexports.isFiniteInteger = isFiniteInteger;\n/**\n * Checks if an offset/length value is valid. (Throws an exception if check fails)\n *\n * @param value The value to check.\n * @param offset True if checking an offset, false if checking a length.\n */\nfunction checkOffsetOrLengthValue(value, offset) {\n    if (typeof value === 'number') {\n        // Check for non finite/non integers\n        if (!isFiniteInteger(value) || value < 0) {\n            throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);\n        }\n    }\n    else {\n        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);\n    }\n}\n/**\n * Checks if a length value is valid. (Throws an exception if check fails)\n *\n * @param { Number } length The value to check.\n */\nfunction checkLengthValue(length) {\n    checkOffsetOrLengthValue(length, false);\n}\nexports.checkLengthValue = checkLengthValue;\n/**\n * Checks if a offset value is valid. (Throws an exception if check fails)\n *\n * @param { Number } offset The value to check.\n */\nfunction checkOffsetValue(offset) {\n    checkOffsetOrLengthValue(offset, true);\n}\nexports.checkOffsetValue = checkOffsetValue;\n/**\n * Checks if a target offset value is out of bounds. (Throws an exception if check fails)\n *\n * @param { Number } offset The offset value to check.\n * @param { SmartBuffer } buff The SmartBuffer instance to check against.\n */\nfunction checkTargetOffset(offset, buff) {\n    if (offset < 0 || offset > buff.length) {\n        throw new Error(ERRORS.INVALID_TARGET_OFFSET);\n    }\n}\nexports.checkTargetOffset = checkTargetOffset;\n/**\n * Determines whether a given number is a integer.\n * @param value The number to check.\n */\nfunction isInteger(value) {\n    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\n/**\n * Throws if Node.js version is too low to support bigint\n */\nfunction bigIntAndBufferInt64Check(bufferMethod) {\n    if (typeof BigInt === 'undefined') {\n        throw new Error('Platform does not support JS BigInt type.');\n    }\n    if (typeof buffer_1.Buffer.prototype[bufferMethod] === 'undefined') {\n        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);\n    }\n}\nexports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;\n//# sourceMappingURL=utils.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","import { Logger } from './logger';\nimport { Buffer as BufferPolyfill } from 'buffer/';\nconst AvailableBufferModule = typeof Buffer !== 'undefined' ? Buffer : BufferPolyfill;\nexport { AvailableBufferModule as Buffer };\nexport const BLOCKSTACK_HANDLER = 'blockstack';\nexport function nextYear() {\n    return new Date(new Date().setFullYear(new Date().getFullYear() + 1));\n}\nexport function nextMonth() {\n    return new Date(new Date().setMonth(new Date().getMonth() + 1));\n}\nexport function nextHour() {\n    return new Date(new Date().setHours(new Date().getHours() + 1));\n}\nexport function megabytesToBytes(megabytes) {\n    if (!Number.isFinite(megabytes)) {\n        return 0;\n    }\n    return Math.floor(megabytes * 1024 * 1024);\n}\nexport function getAesCbcOutputLength(inputByteLength) {\n    const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;\n    return cipherTextLength;\n}\nexport function getBase64OutputLength(inputByteLength) {\n    const encodedLength = Math.ceil(inputByteLength / 3) * 4;\n    return encodedLength;\n}\nexport function updateQueryStringParameter(uri, key, value) {\n    const re = new RegExp(`([?&])${key}=.*?(&|$)`, 'i');\n    const separator = uri.indexOf('?') !== -1 ? '&' : '?';\n    if (uri.match(re)) {\n        return uri.replace(re, `$1${key}=${value}$2`);\n    }\n    else {\n        return `${uri}${separator}${key}=${value}`;\n    }\n}\nexport function isLaterVersion(v1, v2) {\n    if (v1 === undefined || v1 === '') {\n        v1 = '0.0.0';\n    }\n    if (v2 === undefined || v1 === '') {\n        v2 = '0.0.0';\n    }\n    const v1tuple = v1.split('.').map(x => parseInt(x, 10));\n    const v2tuple = v2.split('.').map(x => parseInt(x, 10));\n    for (let index = 0; index < v2.length; index++) {\n        if (index >= v1.length) {\n            v2tuple.push(0);\n        }\n        if (v1tuple[index] < v2tuple[index]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function makeUUID4() {\n    let d = new Date().getTime();\n    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n        d += performance.now();\n    }\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);\n    });\n}\nexport function isSameOriginAbsoluteUrl(uri1, uri2) {\n    try {\n        const parsedUri1 = new URL(uri1);\n        const parsedUri2 = new URL(uri2);\n        const port1 = parseInt(parsedUri1.port || '0', 10) | 0 || (parsedUri1.protocol === 'https:' ? 443 : 80);\n        const port2 = parseInt(parsedUri2.port || '0', 10) | 0 || (parsedUri2.protocol === 'https:' ? 443 : 80);\n        const match = {\n            scheme: parsedUri1.protocol === parsedUri2.protocol,\n            hostname: parsedUri1.hostname === parsedUri2.hostname,\n            port: port1 === port2,\n            absolute: (uri1.includes('http://') || uri1.includes('https://')) &&\n                (uri2.includes('http://') || uri2.includes('https://')),\n        };\n        return match.scheme && match.hostname && match.port && match.absolute;\n    }\n    catch (error) {\n        console.log(error);\n        console.log('Parsing error in same URL origin check');\n        return false;\n    }\n}\nexport function getGlobalScope() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available');\n}\nfunction getAPIUsageErrorMessage(scopeObject, apiName, usageDesc) {\n    if (usageDesc) {\n        return `Use of '${usageDesc}' requires \\`${apiName}\\` which is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n    }\n    else {\n        return `\\`${apiName}\\` is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n    }\n}\nexport function getGlobalObject(name, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {\n    let globalScope = undefined;\n    try {\n        globalScope = getGlobalScope();\n        if (globalScope) {\n            const obj = globalScope[name];\n            if (obj) {\n                return obj;\n            }\n        }\n    }\n    catch (error) {\n        Logger.error(`Error getting object '${name}' from global scope '${globalScope}': ${error}`);\n    }\n    if (throwIfUnavailable) {\n        const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n        Logger.error(errMsg);\n        throw new Error(errMsg);\n    }\n    if (returnEmptyObject) {\n        return {};\n    }\n    return undefined;\n}\nexport function getGlobalObjects(names, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {\n    let globalScope;\n    try {\n        globalScope = getGlobalScope();\n    }\n    catch (error) {\n        Logger.error(`Error getting global scope: ${error}`);\n        if (throwIfUnavailable) {\n            const errMsg = getAPIUsageErrorMessage(globalScope, names[0].toString(), usageDesc);\n            Logger.error(errMsg);\n            throw errMsg;\n        }\n        else if (returnEmptyObject) {\n            globalScope = {};\n        }\n    }\n    const result = {};\n    for (let i = 0; i < names.length; i++) {\n        const name = names[i];\n        try {\n            if (globalScope) {\n                const obj = globalScope[name];\n                if (obj) {\n                    result[name] = obj;\n                }\n                else if (throwIfUnavailable) {\n                    const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n                    Logger.error(errMsg);\n                    throw new Error(errMsg);\n                }\n                else if (returnEmptyObject) {\n                    result[name] = {};\n                }\n            }\n        }\n        catch (error) {\n            if (throwIfUnavailable) {\n                const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n                Logger.error(errMsg);\n                throw new Error(errMsg);\n            }\n        }\n    }\n    return result;\n}\nexport function intToBytes(value, signed, byteLength) {\n    return toBuffer(intToBigInt(value, signed), byteLength);\n}\nexport function intToBigInt(value, signed) {\n    let parsedValue = value;\n    if (typeof parsedValue === 'number') {\n        if (!Number.isInteger(parsedValue)) {\n            throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);\n        }\n        return BigInt(parsedValue);\n    }\n    if (typeof parsedValue === 'string') {\n        if (parsedValue.toLowerCase().startsWith('0x')) {\n            let hex = parsedValue.slice(2);\n            hex = hex.padStart(hex.length + (hex.length % 2), '0');\n            parsedValue = AvailableBufferModule.from(hex, 'hex');\n        }\n        else {\n            try {\n                return BigInt(parsedValue);\n            }\n            catch (error) {\n                if (error instanceof SyntaxError) {\n                    throw new RangeError(`Invalid value. String integer '${parsedValue}' is not finite.`);\n                }\n            }\n        }\n    }\n    if (typeof parsedValue === 'bigint') {\n        return parsedValue;\n    }\n    if (parsedValue instanceof Uint8Array || AvailableBufferModule.isBuffer(parsedValue)) {\n        if (signed) {\n            const bn = fromTwos(BigInt(`0x${bytesToHex(parsedValue)}`), BigInt(parsedValue.byteLength * 8));\n            return BigInt(bn.toString());\n        }\n        else {\n            return BigInt(`0x${bytesToHex(parsedValue)}`);\n        }\n    }\n    if (parsedValue != null &&\n        typeof parsedValue === 'object' &&\n        parsedValue.constructor.name === 'BN') {\n        return BigInt(parsedValue.toString());\n    }\n    throw new TypeError(`Invalid value type. Must be a number, bigint, integer-string, hex-string, or Buffer.`);\n}\nexport function with0x(value) {\n    return !value.startsWith('0x') ? `0x${value}` : value;\n}\nexport function hexToBigInt(hex) {\n    if (typeof hex !== 'string')\n        throw new TypeError(`hexToBigInt: expected string, got ${typeof hex}`);\n    return BigInt(`0x${hex}`);\n}\nexport function intToHex(integer, lengthBytes = 8) {\n    const value = typeof integer === 'bigint' ? integer : intToBigInt(integer, false);\n    return value.toString(16).padStart(lengthBytes * 2, '0');\n}\nexport function hexToInt(hex) {\n    return parseInt(hex, 16);\n}\nexport function toBuffer(value, length = 16) {\n    const hex = intToHex(value, length);\n    return AvailableBufferModule.from(hexToBytes(hex));\n}\nexport function toTwos(value, width) {\n    if (value < -(BigInt(1) << (width - BigInt(1))) ||\n        (BigInt(1) << (width - BigInt(1))) - BigInt(1) < value) {\n        throw `Unable to represent integer in width: ${width}`;\n    }\n    if (value >= BigInt(0)) {\n        return BigInt(value);\n    }\n    return value + (BigInt(1) << width);\n}\nfunction nthBit(value, n) {\n    return value & (BigInt(1) << n);\n}\nexport function fromTwos(value, width) {\n    if (nthBit(value, width - BigInt(1))) {\n        return value - (BigInt(1) << width);\n    }\n    return value;\n}\nconst hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\nexport function bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (const u of uint8a) {\n        hex += hexes[u];\n    }\n    return hex;\n}\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\nexport function concatBytes(...arrays) {\n    if (!arrays.every(a => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\n//# sourceMappingURL=utils.js.map","/**\n * Unsigned 32-bit integer\n */\nenum ChainID {\n  Testnet = 0x80000000,\n  Mainnet = 0x00000001,\n}\n\nconst DEFAULT_CHAIN_ID = ChainID.Mainnet;\nconst MAX_STRING_LENGTH_BYTES = 128;\nconst CLARITY_INT_SIZE = 128;\nconst CLARITY_INT_BYTE_SIZE = 16;\nconst COINBASE_BUFFER_LENGTH_BYTES = 32;\nconst RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;\nconst COMPRESSED_PUBKEY_LENGTH_BYTES = 32;\nconst UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;\nconst MEMO_MAX_LENGTH_BYTES = 34;\nconst DEFAULT_CORE_NODE_API_URL = 'https://stacks-node-api.mainnet.stacks.co';\n\nenum StacksMessageType {\n  Address,\n  Principal,\n  LengthPrefixedString,\n  MemoString,\n  AssetInfo,\n  PostCondition,\n  PublicKey,\n  LengthPrefixedList,\n  Payload,\n  MessageSignature,\n  StructuredDataSignature,\n  TransactionAuthField,\n}\n\nenum PayloadType {\n  TokenTransfer = 0x00,\n  SmartContract = 0x01,\n  ContractCall = 0x02,\n  PoisonMicroblock = 0x03,\n  Coinbase = 0x04,\n}\n\n/**\n * How a transaction should get appended to the Stacks blockchain.\n *\n * In the Stacks blockchain, there are two kinds of blocks: anchored\n * blocks and streaming microblocks. A transactions AnchorMode specifies\n * which kind of block it should be included in.\n *\n * For more information about the kinds of Stacks blocks and the various\n * AnchorModes, check out {@link https://github.com/stacksgov/sips/blob/main/sips/sip-001/sip-001-burn-election.md SIP 001} and\n * {@link https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md SIP 005}\n */\nenum AnchorMode {\n  /** The transaction MUST be included in an anchored block */\n  OnChainOnly = 0x01,\n  /** The transaction MUST be included in a microblock */\n  OffChainOnly = 0x02,\n  /** The leader can choose where to include the transaction (anchored block or microblock)*/\n  Any = 0x03,\n}\n\nenum TransactionVersion {\n  Mainnet = 0x00,\n  Testnet = 0x80,\n}\n\nconst DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;\n\nenum PostConditionMode {\n  Allow = 0x01,\n  Deny = 0x02,\n}\n\nenum PostConditionType {\n  STX = 0x00,\n  Fungible = 0x01,\n  NonFungible = 0x02,\n}\n\nenum AuthType {\n  Standard = 0x04,\n  Sponsored = 0x05,\n}\n\nenum AddressHashMode {\n  // serialization modes for public keys to addresses.\n  // We support four different modes due to legacy compatibility with Stacks v1 addresses:\n  /** SingleSigHashMode - hash160(public-key), same as bitcoin's p2pkh */\n  SerializeP2PKH = 0x00,\n  /** MultiSigHashMode - hash160(multisig-redeem-script), same as bitcoin's multisig p2sh */\n  SerializeP2SH = 0x01,\n  /** SingleSigHashMode - hash160(segwit-program-00(p2pkh)), same as bitcoin's p2sh-p2wpkh */\n  SerializeP2WPKH = 0x02,\n  /** MultiSigHashMode - hash160(segwit-program-00(public-keys)), same as bitcoin's p2sh-p2wsh */\n  SerializeP2WSH = 0x03,\n}\n\ntype SingleSigHashMode = AddressHashMode.SerializeP2PKH | AddressHashMode.SerializeP2WPKH;\ntype MultiSigHashMode = AddressHashMode.SerializeP2SH | AddressHashMode.SerializeP2WSH;\n\nenum AddressVersion {\n  MainnetSingleSig = 22,\n  MainnetMultiSig = 20,\n  TestnetSingleSig = 26,\n  TestnetMultiSig = 21,\n}\n\nenum PubKeyEncoding {\n  Compressed = 0x00,\n  Uncompressed = 0x01,\n}\n\nenum FungibleConditionCode {\n  Equal = 0x01,\n  Greater = 0x02,\n  GreaterEqual = 0x03,\n  Less = 0x04,\n  LessEqual = 0x05,\n}\n\nenum NonFungibleConditionCode {\n  DoesNotOwn = 0x10,\n  Owns = 0x11,\n}\n\nenum PostConditionPrincipalID {\n  Origin = 0x01,\n  Standard = 0x02,\n  Contract = 0x03,\n}\n\nenum AssetType {\n  STX = 0x00,\n  Fungible = 0x01,\n  NonFungible = 0x02,\n}\n\nenum TxRejectedReason {\n  Serialization = 'Serialization',\n  Deserialization = 'Deserialization',\n  SignatureValidation = 'SignatureValidation',\n  FeeTooLow = 'FeeTooLow',\n  BadNonce = 'BadNonce',\n  NotEnoughFunds = 'NotEnoughFunds',\n  NoSuchContract = 'NoSuchContract',\n  NoSuchPublicFunction = 'NoSuchPublicFunction',\n  BadFunctionArgument = 'BadFunctionArgument',\n  ContractAlreadyExists = 'ContractAlreadyExists',\n  PoisonMicroblocksDoNotConflict = 'PoisonMicroblocksDoNotConflict',\n  PoisonMicroblockHasUnknownPubKeyHash = 'PoisonMicroblockHasUnknownPubKeyHash',\n  PoisonMicroblockIsInvalid = 'PoisonMicroblockIsInvalid',\n  BadAddressVersionByte = 'BadAddressVersionByte',\n  NoCoinbaseViaMempool = 'NoCoinbaseViaMempool',\n  ServerFailureNoSuchChainTip = 'ServerFailureNoSuchChainTip',\n  ServerFailureDatabase = 'ServerFailureDatabase',\n  ServerFailureOther = 'ServerFailureOther',\n}\n\nexport {\n  MAX_STRING_LENGTH_BYTES,\n  CLARITY_INT_SIZE,\n  CLARITY_INT_BYTE_SIZE,\n  COINBASE_BUFFER_LENGTH_BYTES,\n  DEFAULT_CHAIN_ID,\n  DEFAULT_TRANSACTION_VERSION,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n  MEMO_MAX_LENGTH_BYTES,\n  DEFAULT_CORE_NODE_API_URL,\n  ChainID,\n  StacksMessageType,\n  PayloadType,\n  AnchorMode,\n  TransactionVersion,\n  PostConditionMode,\n  PostConditionType,\n  PostConditionPrincipalID,\n  AuthType,\n  AddressHashMode,\n  SingleSigHashMode,\n  MultiSigHashMode,\n  AddressVersion,\n  PubKeyEncoding,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  AssetType,\n  TxRejectedReason,\n};\n","export const crypto = {\n    node: undefined,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nimport { crypto } from '@noble/hashes/crypto';\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianess.\n// So, just to be sure not to corrupt anything.\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nexport function bytesToHex(uint8a) {\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('deadbeef')\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte))\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// Currently avoid insertion of polyfills with packers (browserify/webpack/etc)\n// But setTimeout is pretty slow, maybe worth to investigate howto do minimal polyfill here\nexport const nextTick = (() => {\n    const nodeRequire = typeof module !== 'undefined' &&\n        typeof module.require === 'function' &&\n        module.require.bind(module);\n    try {\n        if (nodeRequire) {\n            const { setImmediate } = nodeRequire('timers');\n            return () => new Promise((resolve) => setImmediate(resolve));\n        }\n    }\n    catch (e) { }\n    return () => new Promise((resolve) => setTimeout(resolve, 0));\n})();\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nexport function concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexport function assertNumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexport function assertBool(b) {\n    if (typeof b !== 'boolean') {\n        throw new Error(`Expected boolean, not ${b}`);\n    }\n}\nexport function assertBytes(bytes, ...lengths) {\n    if (bytes instanceof Uint8Array && (!lengths.length || lengths.includes(bytes.length))) {\n        return;\n    }\n    throw new TypeError(`Expected ${lengths} bytes, not ${typeof bytes} with length=${bytes.length}`);\n}\nexport function assertHash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    assertNumber(hash.outputLen);\n    assertNumber(hash.blockLen);\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nexport function checkOpts(def, _opts) {\n    if (_opts !== undefined && (typeof _opts !== 'object' || !isPlainObject(_opts)))\n        throw new TypeError('Options should be object or undefined');\n    const opts = Object.assign(def, _opts);\n    return opts;\n}\nexport function wrapConstructor(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto.web) {\n        return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    }\n    else if (crypto.node) {\n        return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);\n    }\n    else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\n","import { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        const { view, buffer, blockLen, finished } = this;\n        if (finished)\n            throw new Error('digest() was already called');\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        if (!(out instanceof Uint8Array) || out.length < this.outputLen)\n            throw new Error('_Sha2: Invalid output buffer');\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // NOTE: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64bit of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n","import { SHA2 } from './_sha2.js';\nimport { wrapConstructor } from './utils.js';\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);\nconst Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = new Uint32Array(16);\nexport class RIPEMD160 extends SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = wrapConstructor(() => new RIPEMD160());\n","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = wrapConstructor(() => new SHA256());\n","const U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\nexport function fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nexport function split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nexport const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nexport const shrSH = (h, l, s) => h >>> s;\nexport const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nexport const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexport const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nexport const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexport const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nexport const rotr32H = (h, l) => l;\nexport const rotr32L = (h, l) => h;\n// Left rotate for Shift in [1, 32)\nexport const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexport const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nexport const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexport const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nexport function add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nexport const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexport const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexport const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexport const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexport const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexport const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n","import { SHA2 } from './_sha2.js';\nimport * as u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n)));\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = new Uint32Array(80);\nconst SHA512_W_L = new Uint32Array(80);\nexport class SHA512 extends SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nexport const sha512 = wrapConstructor(() => new SHA512());\nexport const sha512_256 = wrapConstructor(() => new SHA512_256());\nexport const sha384 = wrapConstructor(() => new SHA384());\n","/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst POW_2_256 = _2n ** BigInt(256);\nconst CURVE = {\n    a: _0n,\n    b: BigInt(7),\n    P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),\n    n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n};\nexport { CURVE };\nfunction weistrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 ** _2n);\n        const Z2Z2 = mod(Z2 ** _2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 ** _2n);\n        const B = mod(Y1 ** _2n);\n        const C = mod(B ** _2n);\n        const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E ** _2n);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        if (!(other instanceof JacobianPoint))\n            throw new TypeError('JacobianPoint expected');\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 ** _2n);\n        const Z2Z2 = mod(Z2 ** _2n);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H ** _2n);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r ** _2n - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar);\n        const G = JacobianPoint.BASE;\n        const P0 = JacobianPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.ZERO;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weistrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, 33));\n        const y = bytesToNumber(bytes.subarray(33, 65));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === 65 && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        msgHash = ensureBytes(msgHash);\n        const h = truncateHash(msgHash);\n        const { r, s } = normalizeSignature(signature);\n        if (recovery !== 0 && recovery !== 1) {\n            throw new Error('Cannot recover signature: invalid recovery bit');\n        }\n        if (h === _0n)\n            throw new Error('Cannot recover signature: msgHash cannot be 0');\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(r));\n        const { n } = CURVE;\n        const rinv = invert(r, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.y & _1n ? '03' : '02';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weistrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = isUint8a(hex);\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = isUint8a(hex);\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\n    }\n    toDERRawBytes(isCompressed = false) {\n        return hexToBytes(this.toDERHex(isCompressed));\n    }\n    toDERHex(isCompressed = false) {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        if (isCompressed)\n            return sHex;\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const rLen = numberToHexUnpadded(rHex.length / 2);\n        const sLen = numberToHexUnpadded(sHex.length / 2);\n        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every(isUint8a))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction isUint8a(bytes) {\n    return bytes instanceof Uint8Array;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction numTo32bStr(num) {\n    if (num > POW_2_256)\n        throw new Error('Expected number < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    return hexToBytes(numTo32bStr(num));\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    return pow2(t2, _2n);\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst POW_2_128 = _2n ** BigInt(128);\nfunction splitScalarEndo(k) {\n    const { n } = CURVE;\n    const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n    const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n    const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n    const b2 = a1;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg)\n        k1 = n - k1;\n    if (k2neg)\n        k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction truncateHash(hash) {\n    const { n } = CURVE;\n    const byteLength = hash.length;\n    const delta = byteLength * 8 - 256;\n    let h = bytesToNumber(hash);\n    if (delta > 0)\n        h = h >> BigInt(delta);\n    if (h >= n)\n        h -= n;\n    return h;\n}\nclass HmacDrbg {\n    constructor() {\n        this.v = new Uint8Array(32).fill(1);\n        this.k = new Uint8Array(32).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        if (typeof utils.hmacSha256Sync !== 'function')\n            throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\n        const res = utils.hmacSha256Sync(this.k, ...values);\n        if (res instanceof Promise)\n            throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\n        return res;\n    }\n    incr() {\n        if (this.counter >= 1000) {\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        }\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        this.v = await this.hmac(this.v);\n        return this.v;\n    }\n    generateSync() {\n        this.incr();\n        this.v = this.hmacSync(this.v);\n        return this.v;\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n    const k = bytesToNumber(kBytes);\n    if (!isWithinCurveOrder(k))\n        return;\n    const { n } = CURVE;\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(invert(k, n) * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    const sig = new Signature(r, s);\n    const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 64)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (isUint8a(key)) {\n        if (key.length !== 32)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isPub(item) {\n    const arr = isUint8a(item);\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === 33 || len === 65;\n    if (str)\n        return len === 66 || len === 130;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    const hex = numTo32bStr(num);\n    return hexToBytes(hex);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(32);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== 32)\n            throw new Error('sign: Expected 32 bytes of extra data');\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    let { sig, recovery } = recSig;\n    const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    if (canonical && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    await drbg.reseed(seed);\n    while (!(sig = kmdToSig(await drbg.generate(), m, d)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    let sig;\n    const drbg = new HmacDrbg();\n    drbg.reseedSync(seed);\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    if (h === _0n)\n        return false;\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nasync function taggedHash(tag, ...messages) {\n    const tagB = new Uint8Array(tag.split('').map((c) => c.charCodeAt(0)));\n    const tagH = await utils.sha256(tagB);\n    const h = await utils.sha256(concatBytes(tagH, tagH, ...messages));\n    return bytesToNumber(h);\n}\nasync function createChallenge(x, P, message) {\n    const rx = numTo32b(x);\n    const t = await taggedHash('BIP0340/challenge', rx, P.toRawX(), message);\n    return mod(t, CURVE.n);\n}\nfunction hasEvenY(point) {\n    return (point.y & _1n) === _0n;\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nasync function schnorrSign(message, privateKey, auxRand = utils.randomBytes()) {\n    if (message == null)\n        throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n    const { n } = CURVE;\n    const m = ensureBytes(message);\n    const d0 = normalizePrivateKey(privateKey);\n    const rand = ensureBytes(auxRand);\n    if (rand.length !== 32)\n        throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    const P = Point.fromPrivateKey(d0);\n    const d = hasEvenY(P) ? d0 : n - d0;\n    const t0h = await taggedHash('BIP0340/aux', rand);\n    const t = d ^ t0h;\n    const k0h = await taggedHash('BIP0340/nonce', numTo32b(t), P.toRawX(), m);\n    const k0 = mod(k0h, n);\n    if (k0 === _0n)\n        throw new Error('sign: Creation of signature failed. k is zero');\n    const R = Point.fromPrivateKey(k0);\n    const k = hasEvenY(R) ? k0 : n - k0;\n    const e = await createChallenge(R.x, P, m);\n    const sig = new SchnorrSignature(R.x, mod(k + e * d, n)).toRawBytes();\n    const isValid = await schnorrVerify(sig, m, P.toRawX());\n    if (!isValid)\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    let sig;\n    try {\n        sig = raw ? signature : SchnorrSignature.fromHex(signature);\n        if (raw)\n            sig.assertValidity();\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    const m = ensureBytes(message);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const e = await createChallenge(r, P, m);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !hasEvenY(R) || R.x !== r)\n        return false;\n    return true;\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nexport const utils = {\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        const num = mod(bytesToNumber(hash), CURVE.n);\n        if (num === _0n || num === _1n)\n            throw new Error('Invalid private key');\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.hashToPrivateKey(utils.randomBytes(40));\n    },\n    bytesToHex,\n    mod,\n    sha256: async (message) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            return Uint8Array.from(createHash('sha256').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n};\n","import { assertHash, Hash, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nclass HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        assertHash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (!(this.iHash instanceof Hash))\n            throw new TypeError('Expected instance of class which extends utils.Hash');\n        const blockLen = (this.blockLen = this.iHash.blockLen);\n        this.outputLen = this.iHash.outputLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        if (!(out instanceof Uint8Array) || out.length !== this.outputLen)\n            throw new Error('HMAC: Invalid output buffer');\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n","import { hexToInt } from './utils';\nconst COORDINATE_BYTES = 32;\nexport function parseRecoverableSignatureVrs(signature) {\n    if (signature.length < COORDINATE_BYTES * 2 * 2 + 1) {\n        throw new Error('Invalid signature');\n    }\n    const recoveryIdHex = signature.slice(0, 2);\n    const r = signature.slice(2, 2 + COORDINATE_BYTES * 2);\n    const s = signature.slice(2 + COORDINATE_BYTES * 2);\n    return {\n        recoveryId: hexToInt(recoveryIdHex),\n        r,\n        s,\n    };\n}\nexport function signatureVrsToRsv(signature) {\n    return signature.slice(2) + signature.slice(0, 2);\n}\nexport function signatureRsvToVrs(signature) {\n    return signature.slice(-2) + signature.slice(0, -2);\n}\n//# sourceMappingURL=signatures.js.map","export var ChainID;\n(function (ChainID) {\n    ChainID[ChainID[\"Testnet\"] = 2147483648] = \"Testnet\";\n    ChainID[ChainID[\"Mainnet\"] = 1] = \"Mainnet\";\n})(ChainID || (ChainID = {}));\nexport var TransactionVersion;\n(function (TransactionVersion) {\n    TransactionVersion[TransactionVersion[\"Mainnet\"] = 0] = \"Mainnet\";\n    TransactionVersion[TransactionVersion[\"Testnet\"] = 128] = \"Testnet\";\n})(TransactionVersion || (TransactionVersion = {}));\nexport const PRIVATE_KEY_COMPRESSED_LENGTH = 33;\nexport const PRIVATE_KEY_UNCOMPRESSED_LENGTH = 32;\nexport const BLOCKSTACK_DEFAULT_GAIA_HUB_URL = 'https://hub.blockstack.org';\n//# sourceMappingURL=constants.js.map","import {\n  AddressHashMode,\n  AddressVersion,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  StacksMessageType,\n  TransactionVersion,\n} from './constants';\nimport { Buffer } from '@stacks/common';\nimport { c32address } from 'c32check';\n\nexport interface Address {\n  readonly type: StacksMessageType.Address;\n  readonly version: AddressVersion;\n  readonly hash160: string;\n}\n\nexport interface MessageSignature {\n  readonly type: StacksMessageType.MessageSignature;\n  data: string;\n}\n\nexport function createMessageSignature(signature: string): MessageSignature {\n  const length = Buffer.from(signature, 'hex').byteLength;\n  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n    throw Error('Invalid signature');\n  }\n\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: signature,\n  };\n}\n\n/**\n * Translates the tx auth hash mode to the corresponding address version.\n * @see https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#transaction-authorization\n */\nexport function addressHashModeToVersion(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion\n): AddressVersion {\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetSingleSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetSingleSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    case AddressHashMode.SerializeP2SH:\n    case AddressHashMode.SerializeP2WPKH:\n    case AddressHashMode.SerializeP2WSH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetMultiSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetMultiSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    default:\n      throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n  }\n}\n\nexport function addressFromVersionHash(version: AddressVersion, hash: string): Address {\n  return { type: StacksMessageType.Address, version, hash160: hash };\n}\n\nexport function addressToString(address: Address): string {\n  return c32address(address.version, address.hash160).toString();\n}\n","import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n  getPublicKey as nobleGetPublicKey,\n  Point,\n  Signature,\n  signSync,\n  utils,\n} from '@noble/secp256k1';\nimport {\n  Buffer,\n  bytesToHex,\n  hexToBigInt,\n  intToHex,\n  parseRecoverableSignatureVrs,\n  privateKeyToBuffer,\n  PRIVATE_KEY_COMPRESSED_LENGTH,\n  signatureRsvToVrs,\n  signatureVrsToRsv,\n} from '@stacks/common';\nimport { c32address } from 'c32check';\nimport { BufferReader } from './bufferReader';\nimport {\n  addressFromVersionHash,\n  addressHashModeToVersion,\n  addressToString,\n  createMessageSignature,\n  MessageSignature,\n} from './common';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n} from './constants';\nimport { BufferArray, hash160, hashP2PKH } from './utils';\n\n/**\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\n * secp256k1.signSync is used within signWithKey in this file\n * secp256k1.signSync is used to maintain the semantics of signWithKey while migrating from elliptic lib\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\n */\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\nexport interface StacksPublicKey {\n  readonly type: StacksMessageType.PublicKey;\n  readonly data: Buffer;\n}\n\n/** Creates a P2PKH address string from the given private key and tx version. */\nexport function getAddressFromPrivateKey(\n  /** Private key buffer or hex string */\n  privateKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\n\n/** Creates a P2PKH address string from the given public key and tx version. */\nexport function getAddressFromPublicKey(\n  /** Public key buffer or hex string */\n  publicKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));\n  const addrString = addressToString(addr);\n  return addrString;\n}\n\nexport function createStacksPublicKey(key: string): StacksPublicKey {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: Buffer.from(key, 'hex'),\n  };\n}\n\nexport function publicKeyFromSignatureVrs(\n  message: string,\n  messageSignature: MessageSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n): string {\n  const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);\n  const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));\n  const point = Point.fromSignature(message, signature, parsedSignature.recoveryId);\n  const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;\n  return point.toHex(compressed);\n}\n\nexport function publicKeyFromSignatureRsv(\n  message: string,\n  messageSignature: MessageSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n): string {\n  return publicKeyFromSignatureVrs(\n    message,\n    { ...messageSignature, data: signatureRsvToVrs(messageSignature.data) },\n    pubKeyEncoding\n  );\n}\n\n/**\n * @deprecated use {@link publicKeyFromSignatureRsv} (recommended) or {@link publicKeyFromSignatureVrs} instead\n */\nexport const publicKeyFromSignature = publicKeyFromSignatureVrs;\n\nexport function publicKeyFromBuffer(data: Buffer): StacksPublicKey {\n  return { type: StacksMessageType.PublicKey, data };\n}\n\nexport function isCompressed(key: StacksPublicKey): boolean {\n  return !key.data.toString('hex').startsWith('04');\n}\n\nexport function publicKeyToString(key: StacksPublicKey): string {\n  return key.data.toString('hex');\n}\n\nexport function serializePublicKey(key: StacksPublicKey): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(key.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function pubKeyfromPrivKey(privateKey: string | Buffer): StacksPublicKey {\n  const privKey = createStacksPrivateKey(privateKey);\n  const publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);\n  return createStacksPublicKey(bytesToHex(publicKey));\n}\n\nexport function compressPublicKey(publicKey: string | Buffer): StacksPublicKey {\n  const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const compressed = Point.fromHex(hex).toHex(true);\n  return createStacksPublicKey(compressed);\n}\n\nexport function deserializePublicKey(bufferReader: BufferReader): StacksPublicKey {\n  const fieldId = bufferReader.readUInt8();\n  const keyLength =\n    fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBuffer(\n    Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)])\n  );\n}\n\nexport interface StacksPrivateKey {\n  // \"compressed\" private key is a misnomer: https://web.archive.org/web/20220131144208/https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch04.html#comp_priv\n  // it actually means: should public keys be generated as \"compressed\" or \"uncompressed\" from this private key\n  compressed: boolean;\n  data: Buffer;\n}\n\nexport function createStacksPrivateKey(key: string | Buffer): StacksPrivateKey {\n  const data = privateKeyToBuffer(key);\n  const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;\n  return { data, compressed };\n}\n\nexport function makeRandomPrivKey(): StacksPrivateKey {\n  return createStacksPrivateKey(bytesToHex(utils.randomPrivateKey()));\n}\n\n/**\n * @deprecated The Clarity compatible {@link signMessageHashRsv} is preferred, but differs in signature format\n * @returns A recoverable signature (in VRS order)\n */\nexport function signWithKey(privateKey: StacksPrivateKey, messageHash: string): MessageSignature {\n  const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {\n    canonical: true,\n    recovered: true,\n  });\n  if (recoveryId == null) {\n    throw new Error('No signature recoveryId received');\n  }\n  const recoveryIdHex = intToHex(recoveryId, 1);\n  const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex(); // V + RS\n  return createMessageSignature(recoverableSignatureString);\n}\n\n/**\n * Signs a message using a private key. The resulting signature along with the\n * original message can be verified using {@link verifyMessageSignature}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signMessageHashRsv({\n  messageHash,\n  privateKey,\n}: {\n  messageHash: string;\n  privateKey: StacksPrivateKey;\n}): MessageSignature {\n  const messageSignature = signWithKey(privateKey, messageHash);\n  return { ...messageSignature, data: signatureVrsToRsv(messageSignature.data) };\n}\n\n/**\n * @deprecated\n * This method is now exported from `@stacks/common` {@link parseRecoverableSignatureVrs}\n */\nexport const parseRecoverableSignature = parseRecoverableSignatureVrs;\n\nexport function getPublicKey(privateKey: StacksPrivateKey): StacksPublicKey {\n  return pubKeyfromPrivKey(privateKey.data);\n}\n\nexport function privateKeyToString(privateKey: StacksPrivateKey): string {\n  return privateKey.data.toString('hex');\n}\n\nexport function publicKeyToAddress(version: AddressVersion, publicKey: StacksPublicKey): string {\n  return c32address(version, hash160(publicKey.data).toString('hex'));\n}\n","import { Buffer } from './utils';\nexport function privateKeyToBuffer(privateKey) {\n    const privateKeyBuffer = Buffer.isBuffer(privateKey)\n        ? privateKey\n        : Buffer.from(privateKey, 'hex');\n    if (privateKeyBuffer.length != 32 && privateKeyBuffer.length != 33) {\n        throw new Error(`Improperly formatted private-key. Private-key byte length should be 32 or 33. Length provided: ${privateKeyBuffer.length}`);\n    }\n    if (privateKeyBuffer.length == 33 && privateKeyBuffer[32] !== 1) {\n        throw new Error('Improperly formatted private-key. 33 bytes indicate compressed key, but the last byte must be == 01');\n    }\n    return privateKeyBuffer;\n}\n//# sourceMappingURL=keys.js.map","import {\n  FungibleConditionCode,\n  MAX_STRING_LENGTH_BYTES,\n  NonFungibleConditionCode,\n  PostConditionPrincipalID,\n  PostConditionType,\n  StacksMessageType,\n} from './constants';\nimport { c32addressDecode } from 'c32check';\nimport { Address } from './common';\nimport { ClarityValue } from './clarity';\nimport { exceedsMaxLengthBytes } from './utils';\n\nexport interface StandardPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Standard;\n  readonly address: Address;\n}\n\nexport interface ContractPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Contract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\nexport interface LengthPrefixedString {\n  readonly type: StacksMessageType.LengthPrefixedString;\n  readonly content: string;\n  readonly lengthPrefixBytes: number;\n  readonly maxLengthBytes: number;\n}\n\nexport interface AssetInfo {\n  readonly type: StacksMessageType.AssetInfo;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly assetName: LengthPrefixedString;\n}\n\nexport interface STXPostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.STX;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: bigint;\n}\n\nexport interface FungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.Fungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: bigint;\n  readonly assetInfo: AssetInfo;\n}\n\nexport interface NonFungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.NonFungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: NonFungibleConditionCode;\n  /** Structure that identifies the token type. */\n  readonly assetInfo: AssetInfo;\n  /** The Clarity value that names the token instance. */\n  readonly assetName: ClarityValue;\n}\n\nexport function parseAssetInfoString(id: string): AssetInfo {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\n\nexport function createLPString(content: string): LengthPrefixedString;\nexport function createLPString(content: string, lengthPrefixBytes: number): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes: number,\n  maxLengthBytes: number\n): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes?: number,\n  maxLengthBytes?: number\n): LengthPrefixedString {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);\n  }\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength,\n  };\n}\n\nexport function createAssetInfo(\n  addressString: string,\n  contractName: string,\n  assetName: string\n): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName),\n  };\n}\n\nexport function createAddress(c32AddressString: string): Address {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1],\n  };\n}\n\n/**\n * Parses a principal string for either a standard principal or contract principal.\n * @param principalString - String in the format `{address}.{contractName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract\"\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G\"\n */\nexport function parsePrincipalString(\n  principalString: string\n): StandardPrincipal | ContractPrincipal {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\n\nexport function createContractPrincipal(\n  addressString: string,\n  contractName: string\n): ContractPrincipal {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name,\n  };\n}\n\nexport function createStandardPrincipal(addressString: string): StandardPrincipal {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr,\n  };\n}\n\nexport type PostCondition = STXPostCondition | FungiblePostCondition | NonFungiblePostCondition;\n\nexport type PostConditionPrincipal = StandardPrincipal | ContractPrincipal;\n","/**\n * Type IDs corresponding to each of the Clarity value types as described here:\n * {@link https://github.com/blockstack/blockstack-core/blob/sip/sip-005/sip/sip-005-blocks-and-transactions.md#clarity-value-representation}\n */\nexport enum ClarityType {\n  Int = 0x00,\n  UInt = 0x01,\n  Buffer = 0x02,\n  BoolTrue = 0x03,\n  BoolFalse = 0x04,\n  PrincipalStandard = 0x05,\n  PrincipalContract = 0x06,\n  ResponseOk = 0x07,\n  ResponseErr = 0x08,\n  OptionalNone = 0x09,\n  OptionalSome = 0x0a,\n  List = 0x0b,\n  Tuple = 0x0c,\n  StringASCII = 0x0d,\n  StringUTF8 = 0x0e,\n}\n","import { IntegerType, intToBigInt } from '@stacks/common';\nimport { ClarityType } from '../constants';\n\nconst MAX_U128 = BigInt('0xffffffffffffffffffffffffffffffff'); // (2 ** 128 - 1)\nconst MIN_U128 = BigInt(0);\nconst MAX_I128 = BigInt('0x7fffffffffffffffffffffffffffffff'); // (2 ** 127 - 1)\n// no signed (negative) hex support in bigint constructor\nconst MIN_I128 = BigInt('-170141183460469231731687303715884105728'); // (-2 ** 127)\n\ninterface IntCV {\n  readonly type: ClarityType.Int;\n  readonly value: bigint;\n}\n\n/**\n * Converts IntegerType in to IntCV clarity type\n *\n * @param {value} integer value to be converted to IntCV clarity type\n *\n * @returns {IntCV} returns instance of type IntCV\n *\n * @example\n * ```\n *  import { intCV } from '@stacks/transactions';\n *\n *  const value = intCV('100'); // parameter any of type: number | string | bigint | Uint8Array | BN\n *  // { type: 0, value: 100n }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst intCV = (value: IntegerType): IntCV => {\n  const bigInt = intToBigInt(value, true);\n  if (bigInt > MAX_I128) {\n    throw new RangeError(\n      `Cannot construct clarity integer from value greater than ${MAX_I128.toString()}`\n    );\n  } else if (bigInt < MIN_I128) {\n    throw new RangeError(\n      `Cannot construct clarity integer form value less than ${MIN_I128.toString()}`\n    );\n  }\n  return { type: ClarityType.Int, value: bigInt };\n};\n\ninterface UIntCV {\n  readonly type: ClarityType.UInt;\n  readonly value: bigint;\n}\n\n/**\n * Converts IntegerType in to IntCV clarity type\n *\n * @param {value} integer value to be converted to UIntCV clarity type (Only unsigned integer is allowed otherwise throws exception)\n *\n * @returns {UIntCV} returns instance of type UIntCV\n *\n * @example\n * ```\n *  import { uintCV } from '@stacks/transactions';\n *\n *  const value = uintCV('100'); // parameter any of type: number | string | bigint | Uint8Array | BN\n *  // { type: 1, value: 100n }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst uintCV = (value: IntegerType): UIntCV => {\n  const bigInt = intToBigInt(value, false);\n  if (bigInt < MIN_U128) {\n    throw new RangeError('Cannot construct unsigned clarity integer from negative value');\n  } else if (bigInt > MAX_U128) {\n    throw new RangeError(\n      `Cannot construct unsigned clarity integer greater than ${MAX_U128.toString()}`\n    );\n  }\n  return { type: ClarityType.UInt, value: bigInt };\n};\n\nexport { IntCV, UIntCV, intCV, uintCV };\n","import { Buffer } from '@stacks/common';\nimport { ClarityType } from '../constants';\n\ninterface BufferCV {\n  readonly type: ClarityType.Buffer;\n  readonly buffer: Buffer;\n}\n\n/**\n * Converts a buffer to BufferCV clarity type\n *\n * @param {buffer} buffer value to be converted to clarity type\n *\n * @returns {BufferCV} returns instance of type BufferCV\n *\n * @example\n * ```\n *  import { bufferCV } from '@stacks/transactions';\n *\n *  const buffer = Buffer.from('this is a test');\n *  const buf = bufferCV(buffer);\n *  // { type: 2, buffer: <Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74> }\n *  const value = buf.buffer.toString();\n *  // this is a test\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst bufferCV = (buffer: Buffer): BufferCV => {\n  if (buffer.length > 1000000) {\n    throw new Error('Cannot construct clarity buffer that is greater than 1MB');\n  }\n\n  return { type: ClarityType.Buffer, buffer };\n};\n\n/**\n * Converts a string to BufferCV clarity type\n *\n * @param {str} string input to be converted to bufferCV clarity type\n *\n * @returns {BufferCV} returns instance of type BufferCV\n *\n * @example\n * ```\n *  import { bufferCVFromString } from '@stacks/transactions';\n *\n *  const str = 'this is a test';\n *  const buf = bufferCVFromString(str);\n *  // { type: 2, buffer: <Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74> }\n *  const value = buf.buffer.toString();\n *  // this is a test\n *```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst bufferCVFromString = (str: string): BufferCV => bufferCV(Buffer.from(str));\n\nexport { BufferCV, bufferCV, bufferCVFromString };\n","import { ClarityType } from '../constants';\n\ntype BooleanCV = TrueCV | FalseCV;\n\ninterface TrueCV {\n  type: ClarityType.BoolTrue;\n}\n\ninterface FalseCV {\n  type: ClarityType.BoolFalse;\n}\n\n/**\n * Converts true to BooleanCV clarity type\n *\n * @returns {BooleanCV} returns instance of type BooleanCV\n *\n * @example\n * ```\n *  import { trueCV } from '@stacks/transactions';\n *\n *  const trueCV = trueCV();\n *  // { type: 3 }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst trueCV = (): BooleanCV => ({ type: ClarityType.BoolTrue });\n\n/**\n * Converts false to BooleanCV clarity type\n *\n * @returns {BooleanCV} returns instance of type BooleanCV\n *\n * @example\n * ```\n *  import { falseCV } from '@stacks/transactions';\n *\n *  const falseCV = falseCV();\n *  // { type: 4 }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst falseCV = (): BooleanCV => ({ type: ClarityType.BoolFalse });\n\nexport { BooleanCV, TrueCV, FalseCV, trueCV, falseCV };\n","import { Buffer } from '@stacks/common';\nimport { LengthPrefixedString, createAddress, createLPString } from '../../postcondition-types';\nimport { Address, addressToString } from '../../common';\nimport { ClarityType } from '../constants';\n\ntype PrincipalCV = StandardPrincipalCV | ContractPrincipalCV;\n\ninterface StandardPrincipalCV {\n  readonly type: ClarityType.PrincipalStandard;\n  readonly address: Address;\n}\n\ninterface ContractPrincipalCV {\n  readonly type: ClarityType.PrincipalContract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\nfunction principalToString(principal: PrincipalCV): string {\n  if (principal.type === ClarityType.PrincipalStandard) {\n    return addressToString(principal.address);\n  } else if (principal.type === ClarityType.PrincipalContract) {\n    const address = addressToString(principal.address);\n    return `${address}.${principal.contractName.content}`;\n  } else {\n    throw new Error(`Unexpected principal data: ${JSON.stringify(principal)}`);\n  }\n}\n\nfunction principalCV(principal: string): PrincipalCV {\n  if (principal.includes('.')) {\n    const [address, contractName] = principal.split('.');\n    return contractPrincipalCV(address, contractName);\n  } else {\n    return standardPrincipalCV(principal);\n  }\n}\n\n/**\n * Converts stx address in to StandardPrincipalCV clarity type\n *\n * @param {addressString} string value to be converted to StandardPrincipalCV clarity type\n *\n * @returns {StandardPrincipalCV} returns instance of type StandardPrincipalCV\n *\n * @example\n * ```\n *  import { standardPrincipalCV } from '@stacks/transactions';\n *\n *  const addr = standardPrincipalCV('SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B');\n *  // { type: 5, address: { type: 0, version: 22, hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6' } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction standardPrincipalCV(addressString: string): StandardPrincipalCV {\n  const addr = createAddress(addressString);\n  return { type: ClarityType.PrincipalStandard, address: addr };\n}\n\n/**\n * Converts stx address in to StandardPrincipalCV clarity type\n *\n * @param {addressString} string value to be converted to StandardPrincipalCV clarity type\n *\n * @returns {StandardPrincipalCV} returns instance of type StandardPrincipalCV\n *\n * @example\n * ```\n *  import { standardPrincipalCVFromAddress, Address  } from '@stacks/transactions';\n *\n *  const address: Address = {\n *    type: 0,\n *    version: 22,\n *    hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6'\n *  };\n *\n *  const principalCV = standardPrincipalCVFromAddress(address);\n *  // { type: 5, address: { type: 0, version: 22, hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6' } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction standardPrincipalCVFromAddress(address: Address): StandardPrincipalCV {\n  return { type: ClarityType.PrincipalStandard, address };\n}\n\n/**\n * Converts stx address in to ContractPrincipalCV clarity type\n *\n * @param {addressString} string value to be converted to ContractPrincipalCV clarity type\n\n * @param {contractName} string containing contract name\n *\n * @returns {ContractPrincipalCV} returns instance of type ContractPrincipalCV\n *\n * @example\n * ```\n *  import { contractPrincipalCV } from '@stacks/transactions';\n *\n *  const contractAddress = contractPrincipalCV('SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B', 'test');\n *  // { type: 6, address: { type: 0, version: 22, hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6' }, contractName: { type: 2, content: 'test', lengthPrefixBytes: 1, maxLengthBytes: 128 } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction contractPrincipalCV(addressString: string, contractName: string): ContractPrincipalCV {\n  const addr = createAddress(addressString);\n  const lengthPrefixedContractName = createLPString(contractName);\n  return contractPrincipalCVFromAddress(addr, lengthPrefixedContractName);\n}\n\n/**\n * Create ContractPrincipalCV from Address type\n *\n * @param {address} address value to be converted to ContractPrincipalCV clarity type\n *\n * @param {contractName} contract name of type LengthPrefixedString\n *\n * @returns {ContractPrincipalCV} returns instance of type ContractPrincipalCV\n *\n * @example\n * ```\n *  import { contractPrincipalCVFromAddress, createLPString, createAddress } from '@stacks/transactions';\n *\n *  const contractAddressCV = contractPrincipalCVFromAddress(createAddress('SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B'), createLPString('test'));\n *\n *  // { type: 6, address: { type: 0, version: 22, hash160: 'a5d9d331000f5b79578ce56bd157f29a9056f0d6' }, contractName: { type: 2, content: 'test', lengthPrefixBytes: 1, maxLengthBytes: 128 } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction contractPrincipalCVFromAddress(\n  address: Address,\n  contractName: LengthPrefixedString\n): ContractPrincipalCV {\n  if (Buffer.byteLength(contractName.content) >= 128) {\n    throw new Error('Contract name must be less than 128 bytes');\n  }\n  return { type: ClarityType.PrincipalContract, address, contractName };\n}\n\nfunction contractPrincipalCVFromStandard(\n  sp: StandardPrincipalCV,\n  contractName: string\n): ContractPrincipalCV {\n  const lengthPrefixedContractName = createLPString(contractName);\n  return {\n    type: ClarityType.PrincipalContract,\n    address: sp.address,\n    contractName: lengthPrefixedContractName,\n  };\n}\n\nexport {\n  PrincipalCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  principalCV,\n  principalToString,\n  standardPrincipalCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCV,\n  contractPrincipalCVFromAddress,\n  contractPrincipalCVFromStandard,\n};\n","import { ClarityValue } from '../clarityValue';\nimport { ClarityType } from '../constants';\n\ntype ResponseCV = ResponseErrorCV | ResponseOkCV;\n\ninterface ResponseErrorCV<T extends ClarityValue = ClarityValue> {\n  readonly type: ClarityType.ResponseErr;\n  readonly value: T;\n}\n\ninterface ResponseOkCV<T extends ClarityValue = ClarityValue> {\n  readonly type: ClarityType.ResponseOk;\n  readonly value: T;\n}\n\n/**\n * Converts ClarityValue to responseErrorCV\n *\n * @param {value} ClarityValue value to be converted to responseErrorCV clarity type\n *\n * @returns {responseErrorCV} returns instance of type responseErrorCV\n *\n * @example\n * ```\n *  import { responseErrorCV, intCV } from '@stacks/transactions';\n *\n *  const respErrorCV = responseErrorCV(intCV(1));\n *\n *  // { type: 8, value: { type: 0, value: 1n } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction responseErrorCV<T extends ClarityValue = ClarityValue>(value: T): ResponseErrorCV<T> {\n  return { type: ClarityType.ResponseErr, value };\n}\n\n/**\n * Converts ClarityValue to ResponseOkCV\n *\n * @param {value} ClarityValue value to be converted to ResponseOkCV clarity type\n *\n * @returns {ResponseOkCV} returns instance of type ResponseOkCV\n *\n * @example\n * ```\n *  import { responseOkCV, intCV } from '@stacks/transactions';\n *\n *  const respOKCV = responseOkCV(intCV(1));\n *\n *  // { type: 7, value: { type: 0, value: 1n } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction responseOkCV<T extends ClarityValue = ClarityValue>(value: T): ResponseOkCV<T> {\n  return { type: ClarityType.ResponseOk, value };\n}\n\nexport { ResponseCV, ResponseErrorCV, ResponseOkCV, responseErrorCV, responseOkCV };\n","import { ClarityValue } from '../clarityValue';\nimport { ClarityType } from '../constants';\ntype OptionalCV<T extends ClarityValue = ClarityValue> = NoneCV | SomeCV<T>;\n\ninterface NoneCV {\n  readonly type: ClarityType.OptionalNone;\n}\n\ninterface SomeCV<T extends ClarityValue = ClarityValue> {\n  readonly type: ClarityType.OptionalSome;\n  readonly value: T;\n}\n\n/**\n * Create a null clarity type\n **\n * @returns {NoneCV} returns instance of type NoneCV\n *\n * @example\n * ```\n *  import { noneCV } from '@stacks/transactions';\n *\n *  const value = noneCV();\n *  // { type: 9 }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction noneCV(): NoneCV {\n  return { type: ClarityType.OptionalNone };\n}\n\n/**\n * Converts any ClarityValue in to OptionalCV clarity type\n *\n * @param {ClarityValue} value to be converted to OptionalCV clarity type\n *\n * @returns {OptionalCV} returns instance of type OptionalCV\n *\n * @example\n * ```\n *  import { someCV, trueCV } from '@stacks/transactions';\n *\n *  const value = someCV(trueCV());\n *  // { type: 10, value: { type: 3 } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction someCV<T extends ClarityValue = ClarityValue>(value: T): OptionalCV<T> {\n  return { type: ClarityType.OptionalSome, value };\n}\n\nfunction optionalCVOf<T extends ClarityValue = ClarityValue>(value?: T): OptionalCV<T> {\n  if (value) {\n    return someCV(value);\n  } else {\n    return noneCV();\n  }\n}\n\nexport { OptionalCV, NoneCV, SomeCV, noneCV, someCV, optionalCVOf };\n","import { ClarityValue } from '../clarityValue';\nimport { ClarityType } from '../constants';\n\ninterface ListCV<T extends ClarityValue = ClarityValue> {\n  type: ClarityType.List;\n  list: T[];\n}\n\n/**\n * Create list of clarity types\n *\n * @param {ClarityValue>values: T[]} list of  ClarityValues to be converted to ListCV clarity type\n *\n * @returns {ListCV<T>} returns instance of type ListCV<T>\n *\n * @example\n * ```\n *  import { listCV, intCV } from '@stacks/transactions';\n *\n *  const list = listCV([intCV(1), intCV(2), intCV(3), intCV(-4)]);\n *  // { type: 11, list: [ { type: 0, value: 1n }, { type: 0, value: 2n }, { type: 0, value: 3n }, { type: 0, value: -4n } ] }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction listCV<T extends ClarityValue = ClarityValue>(values: T[]): ListCV<T> {\n  return { type: ClarityType.List, list: values };\n}\n\nexport { ListCV, listCV };\n","import { ClarityValue } from '../clarityValue';\nimport { ClarityType } from '../constants';\nimport { isClarityName } from '../../utils';\n\ntype TupleData<T extends ClarityValue = ClarityValue> = { [key: string]: T };\n\ninterface TupleCV<T extends TupleData = TupleData> {\n  type: ClarityType.Tuple;\n  data: T;\n}\n\n/**\n * Create tuple of clarity values\n *\n * @param {tupleData} tuple value to be converted to tuple of clarity types\n *\n * @returns {TupleCV} returns instance of type clarity tuple\n *\n * @example\n * ```\n *  import { tupleCV, trueCV, falseCV } from '@stacks/transactions';\n *\n *  const tuple = tupleCV({\n *    c: trueCV(),\n *    b: falseCV(),\n *    a: trueCV(),\n *  });\n *  // { type: 12, data: { c: { type: 3 }, b: { type: 4 }, a: { type: 3 } } }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nfunction tupleCV<T extends ClarityValue = ClarityValue>(data: TupleData<T>): TupleCV<TupleData<T>> {\n  for (const key in data) {\n    if (!isClarityName(key)) {\n      throw new Error(`\"${key}\" is not a valid Clarity name`);\n    }\n  }\n\n  return { type: ClarityType.Tuple, data };\n}\n\nexport { TupleCV, tupleCV };\n","import { Buffer } from '@stacks/common';\nimport { SmartBuffer, SmartBufferOptions } from 'smart-buffer';\n\nfunction createEnumChecker<T extends string, TEnumValue extends number>(enumVariable: {\n  [key in T]: TEnumValue;\n}): (value: number) => value is TEnumValue {\n  // Create a set of valid enum number values.\n  const enumValues = Object.values<number>(enumVariable).filter(v => typeof v === 'number');\n  const enumValueSet = new Set<number>(enumValues);\n  return (value: number): value is TEnumValue => enumValueSet.has(value);\n}\n\nconst enumCheckFunctions = new Map<object, (value: number) => boolean>();\n\n/**\n * Type guard to check if a given value is a valid enum value.\n * @param enumVariable - Literal `enum` type.\n * @param value - A value to check against the enum's values.\n * @example\n * ```ts\n * enum Color {\n *   Purple = 3,\n *   Orange = 5\n * }\n * const val: number = 3;\n * if (isEnum(Color, val)) {\n *   // `val` is known as enum type `Color`, e.g.:\n *   const colorVal: Color = val;\n * }\n * ```\n */\nexport function isEnum<T extends string, TEnumValue extends number>(\n  enumVariable: { [key in T]: TEnumValue },\n  value: number\n): value is TEnumValue {\n  const checker = enumCheckFunctions.get(enumVariable);\n  if (checker !== undefined) {\n    return checker(value);\n  }\n  const newChecker = createEnumChecker(enumVariable);\n  enumCheckFunctions.set(enumVariable, newChecker);\n  return isEnum(enumVariable, value);\n}\n\nexport class BufferReader {\n  smartBuffer: SmartBuffer;\n\n  static fromBuffer(buffer: Buffer): BufferReader {\n    return new BufferReader({ buff: buffer });\n  }\n\n  constructor(options?: SmartBufferOptions | Buffer) {\n    if (Buffer.isBuffer(options)) {\n      this.smartBuffer = new SmartBuffer({ buff: options });\n    } else {\n      this.smartBuffer = new SmartBuffer(options);\n    }\n  }\n\n  readBuffer(length: number): Buffer {\n    return this.smartBuffer.readBuffer(length);\n  }\n\n  readUInt32BE(offset?: number): number {\n    return this.smartBuffer.readUInt32BE(offset);\n  }\n\n  readUInt8(): number {\n    return this.smartBuffer.readUInt8();\n  }\n\n  readUInt16BE(): number {\n    return this.smartBuffer.readUInt16BE();\n  }\n\n  readBigUIntLE(length: number): bigint {\n    const buffer = Buffer.from(this.smartBuffer.readBuffer(length)).reverse();\n    const hex = buffer.toString();\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUIntBE(length: number): bigint {\n    const buffer = this.smartBuffer.readBuffer(length);\n    const hex = buffer.toString('hex');\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUInt64BE(): bigint {\n    return this.smartBuffer.readBigUInt64BE();\n  }\n\n  readString(arg?: number | BufferEncoding, encoding?: BufferEncoding): string {\n    return this.smartBuffer.readString(arg, encoding);\n  }\n\n  get readOffset(): number {\n    return this.smartBuffer.readOffset;\n  }\n\n  set readOffset(val: number) {\n    this.smartBuffer.readOffset = val;\n  }\n\n  get internalBuffer(): Buffer {\n    return this.smartBuffer.internalBuffer;\n  }\n\n  readUInt8Enum<T extends string, TEnumValue extends number>(\n    enumVariable: { [key in T]: TEnumValue },\n    invalidEnumErrorFormatter: (val: number) => Error\n  ): TEnumValue {\n    const num = this.smartBuffer.readUInt8();\n    if (isEnum(enumVariable, num)) {\n      return num;\n    } else {\n      throw invalidEnumErrorFormatter(num);\n    }\n  }\n}\n","export class SerializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class DeserializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class NotImplementedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class SigningError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\nexport class VerificationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n","import { ClarityType } from '../constants';\n\ninterface StringAsciiCV {\n  readonly type: ClarityType.StringASCII;\n  readonly data: string;\n}\n\ninterface StringUtf8CV {\n  readonly type: ClarityType.StringUTF8;\n  readonly data: string;\n}\n\n/**\n * Converts ClarityValue to stringAsciiCV\n *\n * @param {data} ClarityValue value to be converted to stringAsciiCV clarity type\n *\n * @returns {StringAsciiCV} returns instance of type StringAsciiCV\n *\n * @example\n * ```\n *  import { stringAsciiCV } from '@stacks/transactions';\n *\n *  const stringAscii = stringAsciiCV('test');\n *\n *  // { type: 13, data: 'hello' }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst stringAsciiCV = (data: string): StringAsciiCV => {\n  return { type: ClarityType.StringASCII, data };\n};\n\n/**\n * Converts ClarityValue to stringUtf8CV\n *\n * @param {data} ClarityValue value to be converted to stringUtf8CV clarity type\n *\n * @returns {stringUtf8CV} returns instance of type stringUtf8CV\n *\n * @example\n * ```\n *  import { stringUtf8CV } from '@stacks/transactions';\n *\n *  const stringUTF8 = stringUtf8CV('test');\n *\n *  // { type: 13, data: 'hello' }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nconst stringUtf8CV = (data: string): StringUtf8CV => {\n  return { type: ClarityType.StringUTF8, data };\n};\n\n/**\n *  @ignore\n */\nconst stringCV = (data: string, encoding: 'ascii' | 'utf8'): StringAsciiCV | StringUtf8CV => {\n  switch (encoding) {\n    case 'ascii':\n      return stringAsciiCV(data);\n    case 'utf8':\n      return stringAsciiCV(data);\n  }\n};\n\nexport { StringAsciiCV, StringUtf8CV, stringAsciiCV, stringUtf8CV, stringCV };\n","import { Buffer } from '@stacks/common';\nimport {\n  ClarityType,\n  ClarityValue,\n  intCV,\n  uintCV,\n  bufferCV,\n  trueCV,\n  falseCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCVFromAddress,\n  responseOkCV,\n  responseErrorCV,\n  noneCV,\n  someCV,\n  listCV,\n  tupleCV,\n} from '.';\nimport { BufferReader } from '../bufferReader';\nimport { deserializeAddress, deserializeLPString } from '../types';\nimport { DeserializationError } from '../errors';\nimport { stringAsciiCV, stringUtf8CV } from './types/stringCV';\n\n/**\n * Deserializes clarity value to clarity type\n *\n * @param {value} Buffer | string value to be converted to clarity type\n **\n * @returns {ClarityType} returns the clarity type instance\n *\n * @example\n * ```\n *  import { intCV, serializeCV, deserializeCV } from '@stacks/transactions';\n *\n *  const serialized = serializeCV(intCV(100)); // Similarly works for other clarity types as well like listCV, booleanCV ...\n *\n *  // <Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64>\n *\n *  const deserialized = deserializeCV(serialized);\n *  // { type: 0, value: 100n }\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nexport default function deserializeCV<T extends ClarityValue = ClarityValue>(\n  serializedClarityValue: BufferReader | Buffer | string\n): T {\n  let bufferReader: BufferReader;\n  if (typeof serializedClarityValue === 'string') {\n    const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === '0x';\n    bufferReader = new BufferReader(\n      Buffer.from(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue, 'hex')\n    );\n  } else if (Buffer.isBuffer(serializedClarityValue)) {\n    bufferReader = new BufferReader(serializedClarityValue);\n  } else {\n    bufferReader = serializedClarityValue;\n  }\n  const type = bufferReader.readUInt8Enum(ClarityType, n => {\n    throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);\n  });\n\n  switch (type) {\n    case ClarityType.Int:\n      return intCV(bufferReader.readBuffer(16)) as T;\n\n    case ClarityType.UInt:\n      return uintCV(bufferReader.readBuffer(16)) as T;\n\n    case ClarityType.Buffer:\n      const bufferLength = bufferReader.readUInt32BE();\n      return bufferCV(bufferReader.readBuffer(bufferLength)) as T;\n\n    case ClarityType.BoolTrue:\n      return trueCV() as T;\n\n    case ClarityType.BoolFalse:\n      return falseCV() as T;\n\n    case ClarityType.PrincipalStandard:\n      const sAddress = deserializeAddress(bufferReader);\n      return standardPrincipalCVFromAddress(sAddress) as T;\n\n    case ClarityType.PrincipalContract:\n      const cAddress = deserializeAddress(bufferReader);\n      const contractName = deserializeLPString(bufferReader);\n      return contractPrincipalCVFromAddress(cAddress, contractName) as T;\n\n    case ClarityType.ResponseOk:\n      return responseOkCV(deserializeCV(bufferReader)) as T;\n\n    case ClarityType.ResponseErr:\n      return responseErrorCV(deserializeCV(bufferReader)) as T;\n\n    case ClarityType.OptionalNone:\n      return noneCV() as T;\n\n    case ClarityType.OptionalSome:\n      return someCV(deserializeCV(bufferReader)) as T;\n\n    case ClarityType.List:\n      const listLength = bufferReader.readUInt32BE();\n      const listContents: ClarityValue[] = [];\n      for (let i = 0; i < listLength; i++) {\n        listContents.push(deserializeCV(bufferReader));\n      }\n      return listCV(listContents) as T;\n\n    case ClarityType.Tuple:\n      const tupleLength = bufferReader.readUInt32BE();\n      const tupleContents: { [key: string]: ClarityValue } = {};\n      for (let i = 0; i < tupleLength; i++) {\n        const clarityName = deserializeLPString(bufferReader).content;\n        if (clarityName === undefined) {\n          throw new DeserializationError('\"content\" is undefined');\n        }\n        tupleContents[clarityName] = deserializeCV(bufferReader);\n      }\n      return tupleCV(tupleContents) as T;\n\n    case ClarityType.StringASCII:\n      const asciiStrLen = bufferReader.readUInt32BE();\n      const asciiStr = bufferReader.readBuffer(asciiStrLen).toString('ascii');\n      return stringAsciiCV(asciiStr) as T;\n\n    case ClarityType.StringUTF8:\n      const utf8StrLen = bufferReader.readUInt32BE();\n      const utf8Str = bufferReader.readBuffer(utf8StrLen).toString('utf8');\n      return stringUtf8CV(utf8Str) as T;\n\n    default:\n      throw new DeserializationError(\n        'Unable to deserialize Clarity Value from buffer. Could not find valid Clarity Type.'\n      );\n  }\n}\n","import { Buffer, IntegerType, intToBigInt, intToBytes } from '@stacks/common';\nimport { COINBASE_BUFFER_LENGTH_BYTES, PayloadType, StacksMessageType } from './constants';\n\nimport { BufferArray } from './utils';\n\nimport {\n  MemoString,\n  createMemoString,\n  serializeStacksMessage,\n  deserializeAddress,\n  deserializeLPString,\n  deserializeMemoString,\n  codeBodyString,\n} from './types';\nimport { createAddress, LengthPrefixedString, createLPString } from './postcondition-types';\nimport { Address } from './common';\nimport { ClarityValue, serializeCV, deserializeCV } from './clarity/';\n\nimport { BufferReader } from './bufferReader';\nimport { PrincipalCV, principalCV } from './clarity/types/principalCV';\n\nexport type Payload =\n  | TokenTransferPayload\n  | ContractCallPayload\n  | SmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload;\n\nexport interface TokenTransferPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.TokenTransfer;\n  readonly recipient: PrincipalCV;\n  readonly amount: bigint;\n  readonly memo: MemoString;\n}\n\nexport type PayloadInput =\n  | (TokenTransferPayload | (Omit<TokenTransferPayload, 'amount'> & { amount: IntegerType }))\n  | ContractCallPayload\n  | SmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload;\n\nexport function createTokenTransferPayload(\n  recipient: string | PrincipalCV,\n  amount: IntegerType,\n  memo?: string | MemoString\n): TokenTransferPayload {\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount: intToBigInt(amount, false),\n    memo: memo ?? createMemoString(''),\n  };\n}\n\nexport interface ContractCallPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.ContractCall;\n  readonly contractAddress: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly functionName: LengthPrefixedString;\n  readonly functionArgs: ClarityValue[];\n}\n\nexport function createContractCallPayload(\n  contractAddress: string | Address,\n  contractName: string | LengthPrefixedString,\n  functionName: string | LengthPrefixedString,\n  functionArgs: ClarityValue[]\n): ContractCallPayload {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs,\n  };\n}\n\nexport interface SmartContractPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.SmartContract;\n  readonly contractName: LengthPrefixedString;\n  readonly codeBody: LengthPrefixedString;\n}\n\nexport function createSmartContractPayload(\n  contractName: string | LengthPrefixedString,\n  codeBody: string | LengthPrefixedString\n): SmartContractPayload {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody,\n  };\n}\n\nexport interface PoisonPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.PoisonMicroblock;\n}\n\nexport function createPoisonPayload(): PoisonPayload {\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };\n}\n\nexport interface CoinbasePayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.Coinbase;\n  readonly coinbaseBuffer: Buffer;\n}\n\nexport function createCoinbasePayload(coinbaseBuffer: Buffer): CoinbasePayload {\n  if (coinbaseBuffer.byteLength != COINBASE_BUFFER_LENGTH_BYTES) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BUFFER_LENGTH_BYTES} bytes`);\n  }\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.Coinbase, coinbaseBuffer };\n}\n\nexport function serializePayload(payload: PayloadInput): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(payload.payloadType);\n\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bufferArray.push(serializeCV(payload.recipient));\n      bufferArray.push(intToBytes(payload.amount, false, 8));\n      bufferArray.push(serializeStacksMessage(payload.memo));\n      break;\n    case PayloadType.ContractCall:\n      bufferArray.push(serializeStacksMessage(payload.contractAddress));\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = Buffer.alloc(4);\n      numArgs.writeUInt32BE(payload.functionArgs.length, 0);\n      bufferArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bufferArray.push(serializeCV(arg));\n      });\n      break;\n    case PayloadType.SmartContract:\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      break;\n    case PayloadType.Coinbase:\n      bufferArray.push(payload.coinbaseBuffer);\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePayload(bufferReader: BufferReader): Payload {\n  const payloadType = bufferReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bufferReader) as PrincipalCV;\n      const amount = intToBigInt(bufferReader.readBuffer(8), false);\n      const memo = deserializeMemoString(bufferReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bufferReader);\n      const contractCallName = deserializeLPString(bufferReader);\n      const functionName = deserializeLPString(bufferReader);\n      const functionArgs: ClarityValue[] = [];\n      const numberOfArgs = bufferReader.readUInt32BE();\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bufferReader);\n        functionArgs.push(clarityValue);\n      }\n      return createContractCallPayload(\n        contractAddress,\n        contractCallName,\n        functionName,\n        functionArgs\n      );\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bufferReader);\n      const codeBody = deserializeLPString(bufferReader, 4, 100000);\n      return createSmartContractPayload(smartContractName, codeBody);\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      return createPoisonPayload();\n    case PayloadType.Coinbase:\n      const coinbaseBuffer = bufferReader.readBuffer(COINBASE_BUFFER_LENGTH_BYTES);\n      return createCoinbasePayload(coinbaseBuffer);\n  }\n}\n","import { BufferReader } from './bufferReader';\nimport { DeserializationError } from './errors';\nimport { PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport {\n  compressPublicKey,\n  deserializePublicKey,\n  serializePublicKey,\n  StacksPublicKey,\n} from './keys';\n\nimport { createMessageSignature, MessageSignature } from './common';\n\n// @ts-ignore\nimport { Buffer } from '@stacks/common';\nimport { BufferArray } from './utils';\n\nexport enum AuthFieldType {\n  PublicKeyCompressed = 0x00,\n  PublicKeyUncompressed = 0x01,\n  SignatureCompressed = 0x02,\n  SignatureUncompressed = 0x03,\n}\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;\n\nexport function deserializeMessageSignature(bufferReader: BufferReader): MessageSignature {\n  return createMessageSignature(\n    bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex')\n  );\n}\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport function createTransactionAuthField(\n  pubKeyEncoding: PubKeyEncoding,\n  contents: TransactionAuthFieldContents\n): TransactionAuthField {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents,\n  };\n}\n\nexport function deserializeTransactionAuthField(bufferReader: BufferReader): TransactionAuthField {\n  const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializePublicKey(bufferReader)\n      );\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializePublicKey(bufferReader)\n      );\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializeMessageSignature(bufferReader)\n      );\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializeMessageSignature(bufferReader)\n      );\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\n\nexport function serializeMessageSignature(messageSignature: MessageSignature): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(messageSignature.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function serializeTransactionAuthField(field: TransactionAuthField): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n        bufferArray.push(serializePublicKey(field.contents));\n      } else {\n        bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n        bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n      break;\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n      } else {\n        bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n      }\n      bufferArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n","import { Buffer, hexToInt, intToBytes, intToHex } from '@stacks/common';\nimport {\n  MEMO_MAX_LENGTH_BYTES,\n  AddressHashMode,\n  AddressVersion,\n  TransactionVersion,\n  StacksMessageType,\n  PostConditionPrincipalID,\n  PostConditionType,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n} from './constants';\n\nimport { StacksPublicKey, serializePublicKey, deserializePublicKey, isCompressed } from './keys';\n\nimport {\n  BufferArray,\n  exceedsMaxLengthBytes,\n  hashP2PKH,\n  rightPadHexToLength,\n  hashP2SH,\n  hashP2WSH,\n  hashP2WPKH,\n} from './utils';\n\nimport { BufferReader } from './bufferReader';\nimport {\n  PostCondition,\n  StandardPrincipal,\n  ContractPrincipal,\n  PostConditionPrincipal,\n  LengthPrefixedString,\n  AssetInfo,\n  createLPString,\n} from './postcondition-types';\nimport { Payload, deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport {\n  deserializeTransactionAuthField,\n  deserializeMessageSignature,\n  serializeMessageSignature,\n  serializeTransactionAuthField,\n  TransactionAuthField,\n} from './signature';\nimport {\n  MessageSignature,\n  Address,\n  addressHashModeToVersion,\n  addressFromVersionHash,\n} from './common';\nimport { deserializeCV, serializeCV } from './clarity';\nexport type StacksMessage =\n  | Address\n  | PostConditionPrincipal\n  | LengthPrefixedString\n  | LengthPrefixedList\n  | Payload\n  | MemoString\n  | AssetInfo\n  | PostCondition\n  | StacksPublicKey\n  | TransactionAuthField\n  | MessageSignature;\n\nexport function serializeStacksMessage(message: StacksMessage): Buffer {\n  switch (message.type) {\n    case StacksMessageType.Address:\n      return serializeAddress(message);\n    case StacksMessageType.Principal:\n      return serializePrincipal(message);\n    case StacksMessageType.LengthPrefixedString:\n      return serializeLPString(message);\n    case StacksMessageType.MemoString:\n      return serializeMemoString(message);\n    case StacksMessageType.AssetInfo:\n      return serializeAssetInfo(message);\n    case StacksMessageType.PostCondition:\n      return serializePostCondition(message);\n    case StacksMessageType.PublicKey:\n      return serializePublicKey(message);\n    case StacksMessageType.LengthPrefixedList:\n      return serializeLPList(message);\n    case StacksMessageType.Payload:\n      return serializePayload(message);\n    case StacksMessageType.TransactionAuthField:\n      return serializeTransactionAuthField(message);\n    case StacksMessageType.MessageSignature:\n      return serializeMessageSignature(message);\n  }\n}\n\nexport function deserializeStacksMessage(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  listType?: StacksMessageType\n): StacksMessage {\n  switch (type) {\n    case StacksMessageType.Address:\n      return deserializeAddress(bufferReader);\n    case StacksMessageType.Principal:\n      return deserializePrincipal(bufferReader);\n    case StacksMessageType.LengthPrefixedString:\n      return deserializeLPString(bufferReader);\n    case StacksMessageType.MemoString:\n      return deserializeMemoString(bufferReader);\n    case StacksMessageType.AssetInfo:\n      return deserializeAssetInfo(bufferReader);\n    case StacksMessageType.PostCondition:\n      return deserializePostCondition(bufferReader);\n    case StacksMessageType.PublicKey:\n      return deserializePublicKey(bufferReader);\n    case StacksMessageType.Payload:\n      return deserializePayload(bufferReader);\n    case StacksMessageType.LengthPrefixedList:\n      if (!listType) {\n        throw new DeserializationError('No List Type specified');\n      }\n      return deserializeLPList(bufferReader, listType);\n    case StacksMessageType.MessageSignature:\n      return deserializeMessageSignature(bufferReader);\n    default:\n      throw new Error('Could not recognize StacksMessageType');\n  }\n}\n\nexport function createEmptyAddress(): Address {\n  return {\n    type: StacksMessageType.Address,\n    version: AddressVersion.MainnetSingleSig,\n    hash160: '0'.repeat(40),\n  };\n}\n\nexport function addressFromHashMode(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion,\n  data: string\n): Address {\n  const version = addressHashModeToVersion(hashMode, txVersion);\n  return addressFromVersionHash(version, data);\n}\n\nexport function addressFromPublicKeys(\n  version: AddressVersion,\n  hashMode: AddressHashMode,\n  numSigs: number,\n  publicKeys: StacksPublicKey[]\n): Address {\n  if (publicKeys.length === 0) {\n    throw Error('Invalid number of public keys');\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    if (publicKeys.length !== 1 || numSigs !== 1) {\n      throw Error('Invalid number of public keys or signatures');\n    }\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n    for (let i = 0; i < publicKeys.length; i++) {\n      if (!isCompressed(publicKeys[i])) {\n        throw Error('Public keys must be compressed for segwit');\n      }\n    }\n  }\n\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2WPKH:\n      return addressFromVersionHash(version, hashP2WPKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2SH:\n      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n    case AddressHashMode.SerializeP2WSH:\n      return addressFromVersionHash(\n        version,\n        hashP2WSH(numSigs, publicKeys.map(serializePublicKey))\n      );\n  }\n}\n\nexport function serializeAddress(address: Address): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHex(address.version, 1));\n  bufferArray.appendHexString(address.hash160);\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAddress(bufferReader: BufferReader): Address {\n  const version = hexToInt(bufferReader.readBuffer(1).toString('hex'));\n  const data = bufferReader.readBuffer(20).toString('hex');\n\n  return { type: StacksMessageType.Address, version, hash160: data };\n}\n\nexport function serializePrincipal(principal: PostConditionPrincipal): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(Buffer.from([principal.prefix]));\n  bufferArray.push(serializeAddress(principal.address));\n  if (principal.prefix === PostConditionPrincipalID.Contract) {\n    bufferArray.push(serializeLPString(principal.contractName));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePrincipal(bufferReader: BufferReader): PostConditionPrincipal {\n  const prefix = bufferReader.readUInt8Enum(PostConditionPrincipalID, _ => {\n    throw new DeserializationError('Unexpected Principal payload type: ${n}');\n  });\n  const address = deserializeAddress(bufferReader);\n  if (prefix === PostConditionPrincipalID.Standard) {\n    return { type: StacksMessageType.Principal, prefix, address } as StandardPrincipal;\n  }\n  const contractName = deserializeLPString(bufferReader);\n  return {\n    type: StacksMessageType.Principal,\n    prefix,\n    address,\n    contractName,\n  } as ContractPrincipal;\n}\n\nexport function serializeLPString(lps: LengthPrefixedString) {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(lps.content);\n  const length = contentBuffer.byteLength;\n  bufferArray.appendHexString(intToHex(length, lps.lengthPrefixBytes));\n  bufferArray.push(contentBuffer);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPString(\n  bufferReader: BufferReader,\n  prefixBytes?: number,\n  maxLength?: number\n): LengthPrefixedString {\n  prefixBytes = prefixBytes ? prefixBytes : 1;\n  const length = hexToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));\n  const content = bufferReader.readBuffer(length).toString();\n  return createLPString(content, prefixBytes, maxLength ?? 128);\n}\n\nexport function codeBodyString(content: string): LengthPrefixedString {\n  return createLPString(content, 4, 100000);\n}\n\nexport interface MemoString {\n  readonly type: StacksMessageType.MemoString;\n  readonly content: string;\n}\n\nexport function createMemoString(content: string): MemoString {\n  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES.toString()} bytes`);\n  }\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeMemoString(memoString: MemoString): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(memoString.content);\n  const paddedContent = rightPadHexToLength(\n    contentBuffer.toString('hex'),\n    MEMO_MAX_LENGTH_BYTES * 2\n  );\n  bufferArray.push(Buffer.from(paddedContent, 'hex'));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeMemoString(bufferReader: BufferReader): MemoString {\n  const content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeAssetInfo(info: AssetInfo): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(serializeAddress(info.address));\n  bufferArray.push(serializeLPString(info.contractName));\n  bufferArray.push(serializeLPString(info.assetName));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAssetInfo(bufferReader: BufferReader): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: deserializeAddress(bufferReader),\n    contractName: deserializeLPString(bufferReader),\n    assetName: deserializeLPString(bufferReader),\n  };\n}\n\nexport interface LengthPrefixedList {\n  readonly type: StacksMessageType.LengthPrefixedList;\n  readonly lengthPrefixBytes: number;\n  readonly values: StacksMessage[];\n}\n\nexport function createLPList<T extends StacksMessage>(\n  values: T[],\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  return {\n    type: StacksMessageType.LengthPrefixedList,\n    lengthPrefixBytes: lengthPrefixBytes || 4,\n    values,\n  };\n}\n\nexport function serializeLPList(lpList: LengthPrefixedList): Buffer {\n  const list = lpList.values;\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHex(list.length, lpList.lengthPrefixBytes));\n  for (let index = 0; index < list.length; index++) {\n    bufferArray.push(serializeStacksMessage(list[index]));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPList(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  const length = hexToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));\n  const l: StacksMessage[] = [];\n  for (let index = 0; index < length; index++) {\n    switch (type) {\n      case StacksMessageType.Address:\n        l.push(deserializeAddress(bufferReader));\n        break;\n      case StacksMessageType.LengthPrefixedString:\n        l.push(deserializeLPString(bufferReader));\n        break;\n      case StacksMessageType.MemoString:\n        l.push(deserializeMemoString(bufferReader));\n        break;\n      case StacksMessageType.AssetInfo:\n        l.push(deserializeAssetInfo(bufferReader));\n        break;\n      case StacksMessageType.PostCondition:\n        l.push(deserializePostCondition(bufferReader));\n        break;\n      case StacksMessageType.PublicKey:\n        l.push(deserializePublicKey(bufferReader));\n        break;\n      case StacksMessageType.TransactionAuthField:\n        l.push(deserializeTransactionAuthField(bufferReader));\n        break;\n    }\n  }\n  return createLPList(l, lengthPrefixBytes);\n}\n\nexport function serializePostCondition(postCondition: PostCondition): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(postCondition.conditionType);\n  bufferArray.push(serializePrincipal(postCondition.principal));\n\n  if (\n    postCondition.conditionType === PostConditionType.Fungible ||\n    postCondition.conditionType === PostConditionType.NonFungible\n  ) {\n    bufferArray.push(serializeAssetInfo(postCondition.assetInfo));\n  }\n\n  if (postCondition.conditionType === PostConditionType.NonFungible) {\n    bufferArray.push(serializeCV(postCondition.assetName));\n  }\n\n  bufferArray.appendByte(postCondition.conditionCode);\n\n  if (\n    postCondition.conditionType === PostConditionType.STX ||\n    postCondition.conditionType === PostConditionType.Fungible\n  ) {\n    bufferArray.push(intToBytes(postCondition.amount, false, 8));\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePostCondition(bufferReader: BufferReader): PostCondition {\n  const postConditionType = bufferReader.readUInt8Enum(PostConditionType, n => {\n    throw new DeserializationError(`Could not read ${n} as PostConditionType`);\n  });\n\n  const principal = deserializePrincipal(bufferReader);\n\n  let conditionCode;\n  let assetInfo;\n  let amount: bigint;\n  switch (postConditionType) {\n    case PostConditionType.STX:\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.STX,\n        principal,\n        conditionCode,\n        amount,\n      };\n    case PostConditionType.Fungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.Fungible,\n        principal,\n        conditionCode,\n        amount,\n        assetInfo,\n      };\n    case PostConditionType.NonFungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      const assetName = deserializeCV(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(NonFungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.NonFungible,\n        principal,\n        conditionCode,\n        assetInfo,\n        assetName,\n      };\n  }\n}\n","import { Buffer, toTwos, toBuffer } from '@stacks/common';\nimport { serializeAddress, serializeLPString } from '../types';\nimport { createLPString } from '../postcondition-types';\nimport {\n  BooleanCV,\n  OptionalCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseCV,\n  ListCV,\n  TupleCV,\n  ClarityValue,\n} from '.';\nimport { ClarityType } from './constants';\nimport { BufferArray } from '../utils';\nimport { SerializationError } from '../errors';\nimport { StringAsciiCV, StringUtf8CV } from './types/stringCV';\nimport { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';\n\nfunction bufferWithTypeID(typeId: ClarityType, buffer: Buffer): Buffer {\n  const id = Buffer.from([typeId]);\n  return Buffer.concat([id, buffer]);\n}\n\nfunction serializeBoolCV(value: BooleanCV): Buffer {\n  return Buffer.from([value.type]);\n}\n\nfunction serializeOptionalCV(cv: OptionalCV): Buffer {\n  if (cv.type === ClarityType.OptionalNone) {\n    return Buffer.from([cv.type]);\n  } else {\n    return bufferWithTypeID(cv.type, serializeCV(cv.value));\n  }\n}\n\nfunction serializeBufferCV(cv: BufferCV): Buffer {\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.buffer.length, 0);\n  return bufferWithTypeID(cv.type, Buffer.concat([length, cv.buffer]));\n}\n\nfunction serializeIntCV(cv: IntCV): Buffer {\n  const buffer = toBuffer(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeUIntCV(cv: UIntCV): Buffer {\n  const buffer = toBuffer(cv.value, CLARITY_INT_BYTE_SIZE);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeStandardPrincipalCV(cv: StandardPrincipalCV): Buffer {\n  return bufferWithTypeID(cv.type, serializeAddress(cv.address));\n}\n\nfunction serializeContractPrincipalCV(cv: ContractPrincipalCV): Buffer {\n  return bufferWithTypeID(\n    cv.type,\n    Buffer.concat([serializeAddress(cv.address), serializeLPString(cv.contractName)])\n  );\n}\n\nfunction serializeResponseCV(cv: ResponseCV) {\n  return bufferWithTypeID(cv.type, serializeCV(cv.value));\n}\n\nfunction serializeListCV(cv: ListCV) {\n  const buffers = new BufferArray();\n\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.list.length, 0);\n  buffers.push(length);\n\n  for (const value of cv.list) {\n    const serializedValue = serializeCV(value);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeTupleCV(cv: TupleCV) {\n  const buffers = new BufferArray();\n\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(Object.keys(cv.data).length, 0);\n  buffers.push(length);\n\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => {\n    const bufA = Buffer.from(a);\n    const bufB = Buffer.from(b);\n    return bufA.compare(bufB);\n  });\n\n  for (const key of lexicographicOrder) {\n    const nameWithLength = createLPString(key);\n    buffers.push(serializeLPString(nameWithLength));\n\n    const serializedValue = serializeCV(cv.data[key]);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringCV(cv: StringAsciiCV | StringUtf8CV, encoding: 'ascii' | 'utf8') {\n  const buffers = new BufferArray();\n\n  const str = Buffer.from(cv.data, encoding);\n  const len = Buffer.alloc(4);\n  len.writeUInt32BE(str.length, 0);\n\n  buffers.push(len);\n  buffers.push(str);\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringAsciiCV(cv: StringAsciiCV) {\n  return serializeStringCV(cv, 'ascii');\n}\n\nfunction serializeStringUtf8CV(cv: StringUtf8CV) {\n  return serializeStringCV(cv, 'utf8');\n}\n\n/**\n * Serializes clarity value to buffer\n *\n * @param {value} clarity value to be converted to buffer\n **\n * @returns {Buffer} returns the buffer instance\n *\n * @example\n * ```\n *  import { intCV, serializeCV } from '@stacks/transactions';\n *\n *  const serialized = serializeCV(intCV(100)); // Similarly works for other clarity types as well like listCV, booleanCV ...\n *\n *  // <Buffer 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64>\n * ```\n *\n * @visit\n * {@link https://github.com/hirosystems/stacks.js/blob/master/packages/transactions/tests/clarity.test.ts clarity test cases for more examples}\n */\nexport function serializeCV(value: ClarityValue): Buffer {\n  switch (value.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return serializeBoolCV(value);\n    case ClarityType.OptionalNone:\n    case ClarityType.OptionalSome:\n      return serializeOptionalCV(value);\n    case ClarityType.Buffer:\n      return serializeBufferCV(value);\n    case ClarityType.UInt:\n      return serializeUIntCV(value);\n    case ClarityType.Int:\n      return serializeIntCV(value);\n    case ClarityType.PrincipalStandard:\n      return serializeStandardPrincipalCV(value);\n    case ClarityType.PrincipalContract:\n      return serializeContractPrincipalCV(value);\n    case ClarityType.ResponseOk:\n    case ClarityType.ResponseErr:\n      return serializeResponseCV(value);\n    case ClarityType.List:\n      return serializeListCV(value);\n    case ClarityType.Tuple:\n      return serializeTupleCV(value);\n    case ClarityType.StringASCII:\n      return serializeStringAsciiCV(value);\n    case ClarityType.StringUTF8:\n      return serializeStringUtf8CV(value);\n    default:\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n  }\n}\n","import { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512_256 } from '@noble/hashes/sha512';\nimport { utils } from '@noble/secp256k1';\nimport { Buffer, bytesToHex, with0x } from '@stacks/common';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash.clonedeep';\nimport { ClarityValue, deserializeCV, serializeCV } from './clarity';\n\n/**\n * Use utils.randomBytes to replace randombytes dependency\n * Generates a buffer with random bytes of given length\n * @param {bytesLength} an optional bytes length, default is 32 bytes\n * @return {Buffer} For return type compatibility converting utils.randomBytes return value to buffer\n */\nexport const randomBytes = (bytesLength?: number) => Buffer.from(utils.randomBytes(bytesLength));\n\n/**\n * @deprecated Import from `@stacks/common` instead\n */\nexport { bytesToHex };\n\nexport class BufferArray {\n  _value: Buffer[] = [];\n  get value() {\n    return this._value;\n  }\n  appendHexString(hexString: string) {\n    this.value.push(Buffer.from(hexString, 'hex'));\n  }\n\n  push(buffer: Buffer) {\n    return this._value.push(buffer);\n  }\n  appendByte(octet: number) {\n    if (!Number.isInteger(octet) || octet < 0 || octet > 255) {\n      throw new Error(`Value ${octet} is not a valid byte`);\n    }\n    this.value.push(Buffer.from([octet]));\n  }\n\n  concatBuffer(): Buffer {\n    return Buffer.concat(this.value);\n  }\n}\n\nexport const leftPadHex = (hexString: string): string =>\n  hexString.length % 2 == 0 ? hexString : `0${hexString}`;\n\nexport const leftPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padStart(length, '0');\n\nexport const rightPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padEnd(length, '0');\n\nexport const exceedsMaxLengthBytes = (string: string, maxLengthBytes: number): boolean =>\n  string ? Buffer.from(string).length > maxLengthBytes : false;\n\nexport function cloneDeep<T>(obj: T): T {\n  return lodashCloneDeep(obj);\n}\n\nexport function omit<T, K extends keyof any>(obj: T, prop: K): Omit<T, K> {\n  const clone = cloneDeep(obj);\n  // @ts-expect-error\n  delete clone[prop];\n  return clone;\n}\n\nexport const txidFromData = (data: Buffer): string => {\n  return Buffer.from(sha512_256(data)).toString('hex');\n};\n\nexport const hash160 = (input: Buffer): Buffer => {\n  return Buffer.from(ripemd160(sha256(input)));\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address (p2pkh)\nexport const hashP2PKH = (input: Buffer): string => {\n  return hash160(input).toString('hex');\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address over p2sh (p2h-p2wpkh)\nexport const hashP2WPKH = (input: Buffer): string => {\n  const keyHash = hash160(input);\n\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(0);\n  bufferArray.appendByte(keyHash.length);\n  bufferArray.push(keyHash);\n\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multi-sig address (p2sh)\nexport const hashP2SH = (numSigs: number, pubKeys: Buffer[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const bufferArray = new BufferArray();\n  // OP_n\n  bufferArray.appendByte(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    bufferArray.appendByte(pubKey.length);\n    bufferArray.push(pubKey);\n  });\n  // OP_m\n  bufferArray.appendByte(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  bufferArray.appendByte(174);\n\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multisig address over p2sh (p2sh-p2wsh)\nexport const hashP2WSH = (numSigs: number, pubKeys: Buffer[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2WSH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const scriptArray = new BufferArray();\n  // OP_n\n  scriptArray.appendByte(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    scriptArray.appendByte(pubKey.length);\n    scriptArray.push(pubKey);\n  });\n  // OP_m\n  scriptArray.appendByte(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  scriptArray.appendByte(174);\n\n  const script = scriptArray.concatBuffer();\n  const digest = Buffer.from(sha256(script));\n\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(0);\n  bufferArray.appendByte(digest.length);\n  bufferArray.push(digest);\n\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\n\nexport function isClarityName(name: string) {\n  const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n  return regex.test(name) && name.length < 128;\n}\n\n/**\n * Converts a clarity value to a hex encoded string with `0x` prefix\n * @param {ClarityValue} cv  - the clarity value to convert\n */\nexport function cvToHex(cv: ClarityValue) {\n  const serialized = serializeCV(cv);\n  return `0x${serialized.toString('hex')}`;\n}\n\n/**\n * Converts a hex encoded string to a clarity value\n * @param {string} hex - the hex encoded string with or without `0x` prefix\n */\nexport function hexToCV(hex: string) {\n  return deserializeCV(hex);\n}\n/**\n * Read only function response object\n *\n * @param {Boolean} okay - the status of the response\n * @param {string} result - serialized hex clarity value\n */\n\nexport interface ReadOnlyFunctionSuccessResponse {\n  okay: true;\n  result: string;\n}\n\nexport interface ReadOnlyFunctionErrorResponse {\n  okay: false;\n  cause: string;\n}\n\nexport type ReadOnlyFunctionResponse =\n  | ReadOnlyFunctionSuccessResponse\n  | ReadOnlyFunctionErrorResponse;\n\n/**\n * Converts the response of a read-only function call into its Clarity Value\n * @param param\n */\nexport const parseReadOnlyResponse = (response: ReadOnlyFunctionResponse): ClarityValue => {\n  if (response.okay) {\n    return hexToCV(response.result);\n  } else {\n    throw new Error(response.cause);\n  }\n};\n\nexport const validateStacksAddress = (stacksAddress: string): boolean => {\n  try {\n    c32addressDecode(stacksAddress);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nexport const validateTxId = (txid: string): boolean => {\n  if (txid === 'success') return true; // Bypass fetchMock tests\n  const value = with0x(txid).toLowerCase();\n  if (value.length !== 66) return false;\n  return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;\n};\n","import { Buffer, IntegerType, intToBigInt, intToBytes } from '@stacks/common';\nimport {\n  AddressHashMode,\n  AuthType,\n  MultiSigHashMode,\n  PubKeyEncoding,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  SingleSigHashMode,\n  StacksMessageType,\n} from './constants';\n\nimport { BufferArray, cloneDeep, leftPadHex, txidFromData } from './utils';\nimport {\n  TransactionAuthField,\n  serializeMessageSignature,\n  deserializeMessageSignature,\n} from './signature';\nimport {\n  addressFromPublicKeys,\n  createEmptyAddress,\n  createLPList,\n  deserializeLPList,\n  serializeLPList,\n} from './types';\n\nimport {\n  createStacksPublicKey,\n  getPublicKey,\n  isCompressed,\n  publicKeyFromSignature,\n  signWithKey,\n  StacksPrivateKey,\n  StacksPublicKey,\n} from './keys';\n\nimport { BufferReader } from './bufferReader';\nimport { MessageSignature } from './common';\nimport { DeserializationError, SigningError, VerificationError } from './errors';\n\nexport function emptyMessageSignature(): MessageSignature {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex'),\n  };\n}\n\nexport interface SingleSigSpendingCondition {\n  hashMode: SingleSigHashMode;\n  signer: string;\n  nonce: bigint;\n  fee: bigint;\n  keyEncoding: PubKeyEncoding;\n  signature: MessageSignature;\n}\n\nexport interface SingleSigSpendingConditionOpts\n  extends Omit<SingleSigSpendingCondition, 'nonce' | 'fee'> {\n  nonce: IntegerType;\n  fee: IntegerType;\n}\n\nexport interface MultiSigSpendingCondition {\n  hashMode: MultiSigHashMode;\n  signer: string;\n  nonce: bigint;\n  fee: bigint;\n  fields: TransactionAuthField[];\n  signaturesRequired: number;\n}\n\nexport interface MultiSigSpendingConditionOpts\n  extends Omit<MultiSigSpendingCondition, 'nonce' | 'fee'> {\n  nonce: IntegerType;\n  fee: IntegerType;\n}\n\nexport type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;\n\nexport type SpendingConditionOpts = SingleSigSpendingConditionOpts | MultiSigSpendingConditionOpts;\n\nexport function createSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  pubKey: string,\n  nonce: IntegerType,\n  fee: IntegerType\n): SingleSigSpendingCondition {\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey))\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    keyEncoding,\n    signature: emptyMessageSignature(),\n  };\n}\n\nexport function createMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  numSigs: number,\n  pubKeys: string[],\n  nonce: IntegerType,\n  fee: IntegerType\n): MultiSigSpendingCondition {\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    fields: [],\n    signaturesRequired: numSigs,\n  };\n}\n\nexport function isSingleSig(\n  condition: SpendingConditionOpts\n): condition is SingleSigSpendingConditionOpts {\n  return 'signature' in condition;\n}\n\nfunction clearCondition(condition: SpendingConditionOpts): SpendingCondition {\n  const cloned = cloneDeep(condition);\n  cloned.nonce = 0;\n  cloned.fee = 0;\n\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n\n  return {\n    ...cloned,\n    nonce: BigInt(0),\n    fee: BigInt(0),\n  };\n}\n\nexport function serializeSingleSigSpendingCondition(\n  condition: SingleSigSpendingConditionOpts\n): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n  bufferArray.appendByte(condition.keyEncoding);\n  bufferArray.push(serializeMessageSignature(condition.signature));\n  return bufferArray.concatBuffer();\n}\n\nexport function serializeMultiSigSpendingCondition(\n  condition: MultiSigSpendingConditionOpts\n): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n\n  const fields = createLPList(condition.fields);\n  bufferArray.push(serializeLPList(fields));\n\n  const numSigs = Buffer.alloc(2);\n  numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n  bufferArray.push(numSigs);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  bufferReader: BufferReader\n): SingleSigSpendingCondition {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n\n  const keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, n => {\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n  });\n  if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {\n    throw new DeserializationError(\n      'Failed to parse singlesig spending condition: incomaptible hash mode and key encoding'\n    );\n  }\n  const signature = deserializeMessageSignature(bufferReader);\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature,\n  };\n}\n\nexport function deserializeMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  bufferReader: BufferReader\n): MultiSigSpendingCondition {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n\n  const fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField)\n    .values as TransactionAuthField[];\n\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of fields) {\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        break;\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        numSigs += 1;\n        if (numSigs === 65536)\n          throw new VerificationError(\n            'Failed to parse multisig spending condition: too many signatures'\n          );\n        break;\n    }\n  }\n  const signaturesRequired = bufferReader.readUInt16BE();\n\n  // Partially signed multi-sig tx can be serialized and deserialized without exception (Incorrect number of signatures)\n  // No need to check numSigs !== signaturesRequired to throw Incorrect number of signatures error\n\n  if (haveUncompressed && hashMode === AddressHashMode.SerializeP2SH)\n    throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields,\n    signaturesRequired,\n  };\n}\n\nexport function serializeSpendingCondition(condition: SpendingConditionOpts): Buffer {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  } else {\n    return serializeMultiSigSpendingCondition(condition);\n  }\n}\n\nexport function deserializeSpendingCondition(bufferReader: BufferReader): SpendingCondition {\n  const hashMode = bufferReader.readUInt8Enum(AddressHashMode, n => {\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n  }\n}\n\nexport function makeSigHashPreSign(\n  curSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType\n): string {\n  // new hash combines the previous hash and all the new data this signature will add. This\n  // includes:\n  // * the previous hash\n  // * the auth flag\n  // * the tx fee (big-endian 8-byte number)\n  // * nonce (big-endian 8-byte number)\n  const hashLength = 32 + 1 + 8 + 8;\n\n  const sigHash =\n    curSigHash +\n    Buffer.from([authType]).toString('hex') +\n    intToBytes(fee, false, 8).toString('hex') +\n    intToBytes(nonce, false, 8).toString('hex');\n\n  if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(Buffer.from(sigHash, 'hex'));\n}\n\nfunction makeSigHashPostSign(\n  curSigHash: string,\n  pubKey: StacksPublicKey,\n  signature: MessageSignature\n): string {\n  // new hash combines the previous hash and all the new data this signature will add.  This\n  // includes:\n  // * the public key compression flag\n  // * the signature\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n\n  const pubKeyEncoding = isCompressed(pubKey)\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n\n  const sigHashBuffer = Buffer.from(sigHash, 'hex');\n  if (sigHashBuffer.byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(sigHashBuffer);\n}\n\nexport function nextSignature(\n  curSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType,\n  privateKey: StacksPrivateKey\n): {\n  nextSig: MessageSignature;\n  nextSigHash: string;\n} {\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n\n  const signature = signWithKey(privateKey, sigHashPreSign);\n  const publicKey = getPublicKey(privateKey);\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n\n  return {\n    nextSig: signature,\n    nextSigHash,\n  };\n}\n\nexport function nextVerification(\n  initialSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType,\n  pubKeyEncoding: PubKeyEncoding,\n  signature: MessageSignature\n) {\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n\n  const publicKey = createStacksPublicKey(\n    publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding)\n  );\n\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n\n  return {\n    pubKey: publicKey,\n    nextSigHash,\n  };\n}\n\nfunction newInitialSigHash(): SpendingCondition {\n  const spendingCondition = createSingleSigSpendingCondition(\n    AddressHashMode.SerializeP2PKH,\n    '',\n    0,\n    0\n  );\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\n\nfunction verify(\n  condition: SpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    return verifyMultiSig(condition, initialSigHash, authType);\n  }\n}\n\nfunction verifySingleSig(\n  condition: SingleSigSpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const { pubKey, nextSigHash } = nextVerification(\n    initialSigHash,\n    authType,\n    condition.fee,\n    condition.nonce,\n    condition.keyEncoding,\n    condition.signature\n  );\n\n  // address version arg doesn't matter for signer hash generation\n  const addrBytes = addressFromPublicKeys(0, condition.hashMode, 1, [pubKey]).hash160;\n\n  if (addrBytes !== condition.signer)\n    throw new VerificationError(\n      `Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`\n    );\n\n  return nextSigHash;\n}\n\nfunction verifyMultiSig(\n  condition: MultiSigSpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const publicKeys: StacksPublicKey[] = [];\n  let curSigHash = initialSigHash;\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of condition.fields) {\n    let foundPubKey: StacksPublicKey;\n\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        foundPubKey = field.contents;\n        break;\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        const { pubKey, nextSigHash } = nextVerification(\n          curSigHash,\n          authType,\n          condition.fee,\n          condition.nonce,\n          field.pubKeyEncoding,\n          field.contents\n        );\n        curSigHash = nextSigHash;\n        foundPubKey = pubKey;\n\n        numSigs += 1;\n        if (numSigs === 65536) throw new VerificationError('Too many signatures');\n\n        break;\n    }\n    publicKeys.push(foundPubKey);\n  }\n\n  if (numSigs !== condition.signaturesRequired)\n    throw new VerificationError('Incorrect number of signatures');\n\n  if (haveUncompressed && condition.hashMode === AddressHashMode.SerializeP2SH)\n    throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n\n  const addrBytes = addressFromPublicKeys(\n    0,\n    condition.hashMode,\n    condition.signaturesRequired,\n    publicKeys\n  ).hash160;\n  if (addrBytes !== condition.signer)\n    throw new VerificationError(\n      `Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`\n    );\n\n  return curSigHash;\n}\n\nexport type Authorization = StandardAuthorization | SponsoredAuthorization;\n\nexport interface StandardAuthorization {\n  authType: AuthType.Standard;\n  spendingCondition: SpendingCondition;\n}\n\nexport interface SponsoredAuthorization {\n  authType: AuthType.Sponsored;\n  spendingCondition: SpendingCondition;\n  sponsorSpendingCondition: SpendingCondition;\n}\n\nexport function createStandardAuth(spendingCondition: SpendingCondition): StandardAuthorization {\n  return {\n    authType: AuthType.Standard,\n    spendingCondition,\n  };\n}\n\nexport function createSponsoredAuth(\n  spendingCondition: SpendingCondition,\n  sponsorSpendingCondition?: SpendingCondition\n): Authorization {\n  return {\n    authType: AuthType.Sponsored,\n    spendingCondition,\n    sponsorSpendingCondition: sponsorSpendingCondition\n      ? sponsorSpendingCondition\n      : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0),\n  };\n}\n\nexport function intoInitialSighashAuth(auth: Authorization): Authorization {\n  if (auth.spendingCondition) {\n    switch (auth.authType) {\n      case AuthType.Standard:\n        return createStandardAuth(clearCondition(auth.spendingCondition));\n      case AuthType.Sponsored:\n        return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());\n      default:\n        throw new SigningError('Unexpected authorization type for signing');\n    }\n  }\n\n  throw new Error('Authorization missing SpendingCondition');\n}\n\nexport function verifyOrigin(auth: Authorization, initialSigHash: string): string {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    case AuthType.Sponsored:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    default:\n      throw new SigningError('Invalid origin auth type');\n  }\n}\n\nexport function setFee(auth: Authorization, amount: IntegerType): Authorization {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      const spendingCondition = {\n        ...auth.spendingCondition,\n        fee: intToBigInt(amount, false),\n      };\n      return { ...auth, spendingCondition };\n    case AuthType.Sponsored:\n      const sponsorSpendingCondition = {\n        ...auth.sponsorSpendingCondition,\n        fee: intToBigInt(amount, false),\n      };\n      return { ...auth, sponsorSpendingCondition };\n  }\n}\n\nexport function getFee(auth: Authorization): bigint {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return auth.spendingCondition.fee;\n    case AuthType.Sponsored:\n      return auth.sponsorSpendingCondition.fee;\n  }\n}\n\nexport function setNonce(auth: Authorization, nonce: IntegerType): Authorization {\n  const spendingCondition = {\n    ...auth.spendingCondition,\n    nonce: intToBigInt(nonce, false),\n  };\n\n  return {\n    ...auth,\n    spendingCondition,\n  };\n}\n\nexport function setSponsorNonce(auth: SponsoredAuthorization, nonce: IntegerType): Authorization {\n  const sponsorSpendingCondition = {\n    ...auth.sponsorSpendingCondition,\n    nonce: intToBigInt(nonce, false),\n  };\n\n  return {\n    ...auth,\n    sponsorSpendingCondition,\n  };\n}\n\nexport function setSponsor(\n  auth: SponsoredAuthorization,\n  sponsorSpendingCondition: SpendingConditionOpts\n): Authorization {\n  const sc = {\n    ...sponsorSpendingCondition,\n    nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n    fee: intToBigInt(sponsorSpendingCondition.fee, false),\n  };\n\n  return {\n    ...auth,\n    sponsorSpendingCondition: sc,\n  };\n}\n\nexport function serializeAuthorization(auth: Authorization): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(auth.authType);\n\n  switch (auth.authType) {\n    case AuthType.Standard:\n      bufferArray.push(serializeSpendingCondition(auth.spendingCondition));\n      break;\n    case AuthType.Sponsored:\n      bufferArray.push(serializeSpendingCondition(auth.spendingCondition));\n      bufferArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAuthorization(bufferReader: BufferReader) {\n  const authType = bufferReader.readUInt8Enum(AuthType, n => {\n    throw new DeserializationError(`Could not parse ${n} as AuthType`);\n  });\n\n  let spendingCondition;\n  switch (authType) {\n    case AuthType.Standard:\n      spendingCondition = deserializeSpendingCondition(bufferReader);\n      return createStandardAuth(spendingCondition);\n    case AuthType.Sponsored:\n      spendingCondition = deserializeSpendingCondition(bufferReader);\n      const sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n      return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);\n  }\n}\n","import { Buffer, IntegerType, intToBigInt } from '@stacks/common';\nimport {\n  AnchorMode,\n  AuthType,\n  ChainID,\n  DEFAULT_CHAIN_ID,\n  PayloadType,\n  PostConditionMode,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n} from './constants';\n\nimport {\n  Authorization,\n  deserializeAuthorization,\n  intoInitialSighashAuth,\n  isSingleSig,\n  nextSignature,\n  serializeAuthorization,\n  setFee,\n  setNonce,\n  setSponsor,\n  setSponsorNonce,\n  SpendingConditionOpts,\n  verifyOrigin,\n} from './authorization';\nimport { createTransactionAuthField } from './signature';\n\nimport { BufferArray, cloneDeep, txidFromData } from './utils';\n\nimport { deserializePayload, Payload, PayloadInput, serializePayload } from './payload';\n\nimport { createLPList, deserializeLPList, LengthPrefixedList, serializeLPList } from './types';\n\nimport { isCompressed, StacksPrivateKey, StacksPublicKey } from './keys';\n\nimport { BufferReader } from './bufferReader';\n\nimport { SerializationError, SigningError } from './errors';\n\nexport class StacksTransaction {\n  version: TransactionVersion;\n  chainId: ChainID;\n  auth: Authorization;\n  anchorMode: AnchorMode;\n  payload: Payload;\n  postConditionMode: PostConditionMode;\n  postConditions: LengthPrefixedList;\n\n  constructor(\n    version: TransactionVersion,\n    auth: Authorization,\n    payload: PayloadInput,\n    postConditions?: LengthPrefixedList,\n    postConditionMode?: PostConditionMode,\n    anchorMode?: AnchorMode,\n    chainId?: ChainID\n  ) {\n    this.version = version;\n    this.auth = auth;\n    if ('amount' in payload) {\n      this.payload = {\n        ...payload,\n        amount: intToBigInt(payload.amount, false),\n      };\n    } else {\n      this.payload = payload;\n    }\n    this.chainId = chainId ?? DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;\n    this.postConditions = postConditions ?? createLPList([]);\n\n    if (anchorMode) {\n      this.anchorMode = anchorMode;\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.PoisonMicroblock: {\n          this.anchorMode = AnchorMode.OnChainOnly;\n          break;\n        }\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.TokenTransfer: {\n          this.anchorMode = AnchorMode.Any;\n          break;\n        }\n      }\n    }\n  }\n\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyOrigin(): string {\n    return verifyOrigin(this.auth, this.verifyBegin());\n  }\n\n  signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n\n  signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.authType === AuthType.Sponsored) {\n      return this.signAndAppend(\n        this.auth.sponsorSpendingCondition,\n        sigHash,\n        AuthType.Sponsored,\n        privateKey\n      );\n    } else {\n      throw new Error('\"auth.sponsorSpendingCondition\" is undefined');\n    }\n  }\n\n  appendPubkey(publicKey: StacksPublicKey) {\n    const cond = this.auth.spendingCondition;\n    if (cond && !isSingleSig(cond)) {\n      const compressed = isCompressed(publicKey);\n      cond.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          publicKey\n        )\n      );\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n\n  signAndAppend(\n    condition: SpendingConditionOpts,\n    curSigHash: string,\n    authType: AuthType,\n    privateKey: StacksPrivateKey\n  ): string {\n    const { nextSig, nextSigHash } = nextSignature(\n      curSigHash,\n      authType,\n      condition.fee,\n      condition.nonce,\n      privateKey\n    );\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      const compressed = privateKey.data.toString('hex').endsWith('01');\n      condition.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          nextSig\n        )\n      );\n    }\n\n    return nextSigHash;\n  }\n\n  txid(): string {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n\n  setSponsor(sponsorSpendingCondition: SpendingConditionOpts) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsor(this.auth, sponsorSpendingCondition);\n  }\n\n  /**\n   * Set the total fee to be paid for this transaction\n   *\n   * @param fee - the fee amount in microstacks\n   */\n  setFee(amount: IntegerType) {\n    this.auth = setFee(this.auth, amount);\n  }\n\n  /**\n   * Set the transaction nonce\n   *\n   * @param nonce - the nonce value\n   */\n  setNonce(nonce: IntegerType) {\n    this.auth = setNonce(this.auth, nonce);\n  }\n\n  /**\n   * Set the transaction sponsor nonce\n   *\n   * @param nonce - the sponsor nonce value\n   */\n  setSponsorNonce(nonce: IntegerType) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsorNonce(this.auth, nonce);\n  }\n\n  serialize(): Buffer {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n\n    const bufferArray: BufferArray = new BufferArray();\n\n    bufferArray.appendByte(this.version);\n    const chainIdBuffer = Buffer.alloc(4);\n    chainIdBuffer.writeUInt32BE(this.chainId, 0);\n    bufferArray.push(chainIdBuffer);\n    bufferArray.push(serializeAuthorization(this.auth));\n    bufferArray.appendByte(this.anchorMode);\n    bufferArray.appendByte(this.postConditionMode);\n    bufferArray.push(serializeLPList(this.postConditions));\n    bufferArray.push(serializePayload(this.payload));\n\n    return bufferArray.concatBuffer();\n  }\n}\n\n/**\n * @param data Buffer or hex string\n */\nexport function deserializeTransaction(data: BufferReader | Buffer | string) {\n  let bufferReader: BufferReader;\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bufferReader = new BufferReader(Buffer.from(data.slice(2), 'hex'));\n    } else {\n      bufferReader = new BufferReader(Buffer.from(data, 'hex'));\n    }\n  } else if (Buffer.isBuffer(data)) {\n    bufferReader = new BufferReader(data);\n  } else {\n    bufferReader = data;\n  }\n  const version = bufferReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bufferReader.readUInt32BE();\n  const auth = deserializeAuthorization(bufferReader);\n  const anchorMode = bufferReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bufferReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bufferReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bufferReader);\n\n  return new StacksTransaction(\n    version,\n    auth,\n    payload,\n    postConditions,\n    postConditionMode,\n    anchorMode,\n    chainId\n  );\n}\n","import { IntegerType, intToBigInt } from '@stacks/common';\nimport {\n  PostConditionType,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  StacksMessageType,\n} from './constants';\n\nimport {\n  AssetInfo,\n  PostConditionPrincipal,\n  parseAssetInfoString,\n  parsePrincipalString,\n  STXPostCondition,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n} from './postcondition-types';\n\nimport { ClarityValue } from './clarity';\n\nexport function createSTXPostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.STX,\n    principal,\n    conditionCode,\n    amount: intToBigInt(amount, false),\n  };\n}\n\nexport function createFungiblePostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n  if (typeof assetInfo === 'string') {\n    assetInfo = parseAssetInfoString(assetInfo);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.Fungible,\n    principal,\n    conditionCode,\n    amount: intToBigInt(amount, false),\n    assetInfo,\n  };\n}\n\nexport function createNonFungiblePostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n  if (typeof assetInfo === 'string') {\n    assetInfo = parseAssetInfoString(assetInfo);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.NonFungible,\n    principal,\n    conditionCode,\n    assetInfo,\n    assetName,\n  };\n}\n","import { Buffer } from '@stacks/common';\nimport {\n  BooleanCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseErrorCV,\n  ResponseOkCV,\n  ListCV,\n  TupleCV,\n  StringAsciiCV,\n  StringUtf8CV,\n  NoneCV,\n  SomeCV,\n} from '.';\n\nimport { principalToString } from './types/principalCV';\nimport { ClarityType } from './constants';\n\nexport type ClarityValue =\n  | BooleanCV\n  | BufferCV\n  | IntCV\n  | UIntCV\n  | StandardPrincipalCV\n  | ContractPrincipalCV\n  | ResponseErrorCV\n  | ResponseOkCV\n  | NoneCV\n  | SomeCV\n  | ListCV\n  | TupleCV\n  | StringAsciiCV\n  | StringUtf8CV;\n\nexport function cvToString(val: ClarityValue, encoding: 'tryAscii' | 'hex' = 'hex'): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n    case ClarityType.BoolFalse:\n      return 'false';\n    case ClarityType.Int:\n      return val.value.toString();\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = val.buffer.toString('ascii');\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n      return `0x${val.buffer.toString('hex')}`;\n    case ClarityType.OptionalNone:\n      return 'none';\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\n\n/**\n * @param strictJsonCompat If true then ints and uints are returned as JSON serializable numbers when\n * less than or equal to 53 bit length, otherwise string wrapped integers when larger than 53 bits.\n * If false, they are returned as js native `bigint`s which are _not_ JSON serializable.\n */\nexport function cvToValue(val: ClarityValue, strictJsonCompat: boolean = false): any {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n    case ClarityType.BoolFalse:\n      return false;\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      if (strictJsonCompat) {\n        return val.value.toString();\n      } else {\n        return val.value;\n      }\n    case ClarityType.Buffer:\n      return `0x${val.buffer.toString('hex')}`;\n    case ClarityType.OptionalNone:\n      return null;\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n    case ClarityType.Tuple:\n      const result: { [key: string]: any } = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n    case ClarityType.StringASCII:\n      return val.data;\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\n\nexport function cvToJSON(val: ClarityValue): any {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: false };\n    case ClarityType.ResponseOk:\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: true };\n    default:\n      return { type: getCVTypeString(val), value: cvToValue(val, true) };\n  }\n}\n\nexport function getCVTypeString(val: ClarityValue): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n    case ClarityType.Int:\n      return 'int';\n    case ClarityType.UInt:\n      return 'uint';\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n    case ClarityType.List:\n      return `(list ${val.list.length} ${\n        val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'\n      })`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${getCVTypeString(val.data[key])})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `(string-ascii ${Buffer.from(val.data, 'ascii').length})`;\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${Buffer.from(val.data, 'utf8').length})`;\n  }\n}\n","import 'cross-fetch/polyfill';\nconst defaultFetchOpts = {\n    referrerPolicy: 'origin',\n};\nexport const getFetchOptions = () => {\n    return defaultFetchOpts;\n};\nexport const setFetchOptions = (ops) => {\n    return Object.assign(defaultFetchOpts, ops);\n};\nexport async function fetchWrapper(input, init) {\n    const fetchOpts = {};\n    Object.assign(fetchOpts, init, defaultFetchOpts);\n    const fetchResult = await fetch(input, fetchOpts);\n    return fetchResult;\n}\nexport function hostMatches(host, pattern) {\n    if (typeof pattern === 'string')\n        return pattern === host;\n    return pattern.exec(host);\n}\nexport function createApiKeyMiddleware({ apiKey, host = /(.*)api(.*)\\.stacks\\.co$/i, httpHeader = 'x-api-key', }) {\n    return {\n        pre: context => {\n            const reqUrl = new URL(context.url);\n            if (!hostMatches(reqUrl.host, host))\n                return;\n            const headers = new Headers(context.init.headers);\n            headers.set(httpHeader, apiKey);\n            context.init.headers = headers;\n        },\n    };\n}\nfunction argsForCreateFetchFn(args) {\n    let fetchLib = fetchWrapper;\n    let middlewares = [];\n    if (args.length > 0 && typeof args[0] === 'function') {\n        fetchLib = args.shift();\n    }\n    if (args.length > 0) {\n        middlewares = args;\n    }\n    return { fetchLib, middlewares };\n}\nexport function createFetchFn(...args) {\n    const { fetchLib, middlewares } = argsForCreateFetchFn(args);\n    const fetchFn = async (url, init) => {\n        var _a;\n        let fetchParams = { url, init: init !== null && init !== void 0 ? init : {} };\n        for (const middleware of middlewares) {\n            if (typeof middleware.pre === 'function') {\n                const result = await Promise.resolve(middleware.pre(Object.assign({ fetch: fetchLib }, fetchParams)));\n                fetchParams = result !== null && result !== void 0 ? result : fetchParams;\n            }\n        }\n        let response = await fetchLib(fetchParams.url, fetchParams.init);\n        for (const middleware of middlewares) {\n            if (typeof middleware.post === 'function') {\n                const result = await Promise.resolve(middleware.post({\n                    fetch: fetchLib,\n                    url: fetchParams.url,\n                    init: fetchParams.init,\n                    response: (_a = response === null || response === void 0 ? void 0 : response.clone()) !== null && _a !== void 0 ? _a : response,\n                }));\n                response = result !== null && result !== void 0 ? result : response;\n            }\n        }\n        return response;\n    };\n    return fetchFn;\n}\n//# sourceMappingURL=fetch.js.map","import { TransactionVersion, ChainID } from '@stacks/common';\nimport { createFetchFn } from './fetch';\nexport const HIRO_MAINNET_DEFAULT = 'https://stacks-node-api.mainnet.stacks.co';\nexport const HIRO_TESTNET_DEFAULT = 'https://stacks-node-api.testnet.stacks.co';\nexport const HIRO_MOCKNET_DEFAULT = 'http://localhost:3999';\nexport const StacksNetworks = ['mainnet', 'testnet'];\nexport class StacksNetwork {\n    constructor(networkConfig) {\n        var _a;\n        this.version = TransactionVersion.Mainnet;\n        this.chainId = ChainID.Mainnet;\n        this.bnsLookupUrl = 'https://stacks-node-api.mainnet.stacks.co';\n        this.broadcastEndpoint = '/v2/transactions';\n        this.transferFeeEstimateEndpoint = '/v2/fees/transfer';\n        this.transactionFeeEstimateEndpoint = '/v2/fees/transaction';\n        this.accountEndpoint = '/v2/accounts';\n        this.contractAbiEndpoint = '/v2/contracts/interface';\n        this.readOnlyFunctionCallEndpoint = '/v2/contracts/call-read';\n        this.isMainnet = () => this.version === TransactionVersion.Mainnet;\n        this.getBroadcastApiUrl = () => `${this.coreApiUrl}${this.broadcastEndpoint}`;\n        this.getTransferFeeEstimateApiUrl = () => `${this.coreApiUrl}${this.transferFeeEstimateEndpoint}`;\n        this.getTransactionFeeEstimateApiUrl = () => `${this.coreApiUrl}${this.transactionFeeEstimateEndpoint}`;\n        this.getAccountApiUrl = (address) => `${this.coreApiUrl}${this.accountEndpoint}/${address}?proof=0`;\n        this.getAbiApiUrl = (address, contract) => `${this.coreApiUrl}${this.contractAbiEndpoint}/${address}/${contract}`;\n        this.getReadOnlyFunctionCallApiUrl = (contractAddress, contractName, functionName) => `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}/${contractAddress}/${contractName}/${encodeURIComponent(functionName)}`;\n        this.getInfoUrl = () => `${this.coreApiUrl}/v2/info`;\n        this.getBlockTimeInfoUrl = () => `${this.coreApiUrl}/extended/v1/info/network_block_times`;\n        this.getPoxInfoUrl = () => `${this.coreApiUrl}/v2/pox`;\n        this.getRewardsUrl = (address, options) => {\n            let url = `${this.coreApiUrl}/extended/v1/burnchain/rewards/${address}`;\n            if (options) {\n                url = `${url}?limit=${options.limit}&offset=${options.offset}`;\n            }\n            return url;\n        };\n        this.getRewardsTotalUrl = (address) => `${this.coreApiUrl}/extended/v1/burnchain/rewards/${address}/total`;\n        this.getRewardHoldersUrl = (address, options) => {\n            let url = `${this.coreApiUrl}/extended/v1/burnchain/reward_slot_holders/${address}`;\n            if (options) {\n                url = `${url}?limit=${options.limit}&offset=${options.offset}`;\n            }\n            return url;\n        };\n        this.getStackerInfoUrl = (contractAddress, contractName) => `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}\n    ${contractAddress}/${contractName}/get-stacker-info`;\n        this.coreApiUrl = networkConfig.url;\n        this.fetchFn = (_a = networkConfig.fetchFn) !== null && _a !== void 0 ? _a : createFetchFn();\n    }\n    getNameInfo(fullyQualifiedName) {\n        const nameLookupURL = `${this.bnsLookupUrl}/v1/names/${fullyQualifiedName}`;\n        return this.fetchFn(nameLookupURL)\n            .then(resp => {\n            if (resp.status === 404) {\n                throw new Error('Name not found');\n            }\n            else if (resp.status !== 200) {\n                throw new Error(`Bad response status: ${resp.status}`);\n            }\n            else {\n                return resp.json();\n            }\n        })\n            .then(nameInfo => {\n            if (nameInfo.address) {\n                return Object.assign({}, nameInfo, { address: nameInfo.address });\n            }\n            else {\n                return nameInfo;\n            }\n        });\n    }\n}\nStacksNetwork.fromName = (networkName) => {\n    switch (networkName) {\n        case 'mainnet':\n            return new StacksMainnet();\n        case 'testnet':\n            return new StacksTestnet();\n        default:\n            throw new Error(`Invalid network name provided. Must be one of the following: ${StacksNetworks.join(', ')}`);\n    }\n};\nStacksNetwork.fromNameOrNetwork = (network) => {\n    if (typeof network !== 'string' && 'version' in network) {\n        return network;\n    }\n    return StacksNetwork.fromName(network);\n};\nexport class StacksMainnet extends StacksNetwork {\n    constructor(opts) {\n        var _a;\n        super({\n            url: (_a = opts === null || opts === void 0 ? void 0 : opts.url) !== null && _a !== void 0 ? _a : HIRO_MAINNET_DEFAULT,\n            fetchFn: opts === null || opts === void 0 ? void 0 : opts.fetchFn,\n        });\n        this.version = TransactionVersion.Mainnet;\n        this.chainId = ChainID.Mainnet;\n    }\n}\nexport class StacksTestnet extends StacksNetwork {\n    constructor(opts) {\n        var _a;\n        super({\n            url: (_a = opts === null || opts === void 0 ? void 0 : opts.url) !== null && _a !== void 0 ? _a : HIRO_TESTNET_DEFAULT,\n            fetchFn: opts === null || opts === void 0 ? void 0 : opts.fetchFn,\n        });\n        this.version = TransactionVersion.Testnet;\n        this.chainId = ChainID.Testnet;\n    }\n}\nexport class StacksMocknet extends StacksNetwork {\n    constructor(opts) {\n        var _a;\n        super({\n            url: (_a = opts === null || opts === void 0 ? void 0 : opts.url) !== null && _a !== void 0 ? _a : HIRO_MOCKNET_DEFAULT,\n            fetchFn: opts === null || opts === void 0 ? void 0 : opts.fetchFn,\n        });\n        this.version = TransactionVersion.Testnet;\n        this.chainId = ChainID.Testnet;\n    }\n}\n//# sourceMappingURL=network.js.map","import { Buffer } from '@stacks/common';\nimport { cloneDeep } from './utils';\nimport {\n  ClarityValue,\n  uintCV,\n  intCV,\n  contractPrincipalCV,\n  standardPrincipalCV,\n  noneCV,\n  bufferCV,\n  falseCV,\n  trueCV,\n  ClarityType,\n  getCVTypeString,\n  bufferCVFromString,\n} from './clarity';\nimport { ContractCallPayload } from './payload';\nimport { NotImplementedError } from './errors';\nimport { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';\n\n// From https://github.com/blockstack/stacks-blockchain-sidecar/blob/master/src/event-stream/contract-abi.ts\n\nexport type ClarityAbiTypeBuffer = { buffer: { length: number } };\nexport type ClarityAbiTypeStringAscii = { 'string-ascii': { length: number } };\nexport type ClarityAbiTypeStringUtf8 = { 'string-utf8': { length: number } };\nexport type ClarityAbiTypeResponse = { response: { ok: ClarityAbiType; error: ClarityAbiType } };\nexport type ClarityAbiTypeOptional = { optional: ClarityAbiType };\nexport type ClarityAbiTypeTuple = { tuple: { name: string; type: ClarityAbiType }[] };\nexport type ClarityAbiTypeList = { list: { type: ClarityAbiType; length: number } };\n\nexport type ClarityAbiTypeUInt128 = 'uint128';\nexport type ClarityAbiTypeInt128 = 'int128';\nexport type ClarityAbiTypeBool = 'bool';\nexport type ClarityAbiTypePrincipal = 'principal';\nexport type ClarityAbiTypeTraitReference = 'trait_reference';\nexport type ClarityAbiTypeNone = 'none';\n\nexport type ClarityAbiTypePrimitive =\n  | ClarityAbiTypeUInt128\n  | ClarityAbiTypeInt128\n  | ClarityAbiTypeBool\n  | ClarityAbiTypePrincipal\n  | ClarityAbiTypeTraitReference\n  | ClarityAbiTypeNone;\n\nexport type ClarityAbiType =\n  | ClarityAbiTypePrimitive\n  | ClarityAbiTypeBuffer\n  | ClarityAbiTypeResponse\n  | ClarityAbiTypeOptional\n  | ClarityAbiTypeTuple\n  | ClarityAbiTypeList\n  | ClarityAbiTypeStringAscii\n  | ClarityAbiTypeStringUtf8\n  | ClarityAbiTypeTraitReference;\n\nexport enum ClarityAbiTypeId {\n  ClarityAbiTypeUInt128 = 1,\n  ClarityAbiTypeInt128 = 2,\n  ClarityAbiTypeBool = 3,\n  ClarityAbiTypePrincipal = 4,\n  ClarityAbiTypeNone = 5,\n  ClarityAbiTypeBuffer = 6,\n  ClarityAbiTypeResponse = 7,\n  ClarityAbiTypeOptional = 8,\n  ClarityAbiTypeTuple = 9,\n  ClarityAbiTypeList = 10,\n  ClarityAbiTypeStringAscii = 11,\n  ClarityAbiTypeStringUtf8 = 12,\n  ClarityAbiTypeTraitReference = 13,\n}\n\nexport const isClarityAbiPrimitive = (val: ClarityAbiType): val is ClarityAbiTypePrimitive =>\n  typeof val === 'string';\nexport const isClarityAbiBuffer = (val: ClarityAbiType): val is ClarityAbiTypeBuffer =>\n  (val as ClarityAbiTypeBuffer).buffer !== undefined;\nexport const isClarityAbiStringAscii = (val: ClarityAbiType): val is ClarityAbiTypeStringAscii =>\n  (val as ClarityAbiTypeStringAscii)['string-ascii'] !== undefined;\nexport const isClarityAbiStringUtf8 = (val: ClarityAbiType): val is ClarityAbiTypeStringUtf8 =>\n  (val as ClarityAbiTypeStringUtf8)['string-utf8'] !== undefined;\nexport const isClarityAbiResponse = (val: ClarityAbiType): val is ClarityAbiTypeResponse =>\n  (val as ClarityAbiTypeResponse).response !== undefined;\nexport const isClarityAbiOptional = (val: ClarityAbiType): val is ClarityAbiTypeOptional =>\n  (val as ClarityAbiTypeOptional).optional !== undefined;\nexport const isClarityAbiTuple = (val: ClarityAbiType): val is ClarityAbiTypeTuple =>\n  (val as ClarityAbiTypeTuple).tuple !== undefined;\nexport const isClarityAbiList = (val: ClarityAbiType): val is ClarityAbiTypeList =>\n  (val as ClarityAbiTypeList).list !== undefined;\n\nexport type ClarityAbiTypeUnion =\n  | { id: ClarityAbiTypeId.ClarityAbiTypeUInt128; type: ClarityAbiTypeUInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeInt128; type: ClarityAbiTypeInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBool; type: ClarityAbiTypeBool }\n  | { id: ClarityAbiTypeId.ClarityAbiTypePrincipal; type: ClarityAbiTypePrincipal }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference; type: ClarityAbiTypeTraitReference }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeNone; type: ClarityAbiTypeNone }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBuffer; type: ClarityAbiTypeBuffer }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeResponse; type: ClarityAbiTypeResponse }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeOptional; type: ClarityAbiTypeOptional }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTuple; type: ClarityAbiTypeTuple }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeList; type: ClarityAbiTypeList }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii; type: ClarityAbiTypeStringAscii }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8; type: ClarityAbiTypeStringUtf8 };\n\nexport function getTypeUnion(val: ClarityAbiType): ClarityAbiTypeUnion {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'uint128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };\n    } else if (val === 'int128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };\n    } else if (val === 'bool') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };\n    } else if (val === 'principal') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };\n    } else if (val === 'trait_reference') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };\n    } else if (val === 'none') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };\n    } else {\n      throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);\n    }\n  } else if (isClarityAbiBuffer(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };\n  } else if (isClarityAbiResponse(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };\n  } else if (isClarityAbiOptional(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };\n  } else if (isClarityAbiTuple(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };\n  } else if (isClarityAbiList(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };\n  } else if (isClarityAbiStringAscii(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };\n  } else if (isClarityAbiStringUtf8(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };\n  } else {\n    throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);\n  }\n}\n\nfunction encodeClarityValue(type: ClarityAbiType, val: string): ClarityValue;\nfunction encodeClarityValue(type: ClarityAbiTypeUnion, val: string): ClarityValue;\nfunction encodeClarityValue(\n  input: ClarityAbiTypeUnion | ClarityAbiType,\n  val: string\n): ClarityValue {\n  let union: ClarityAbiTypeUnion;\n  if ((input as ClarityAbiTypeUnion).id !== undefined) {\n    union = input as ClarityAbiTypeUnion;\n  } else {\n    union = getTypeUnion(input as ClarityAbiType);\n  }\n  switch (union.id) {\n    case ClarityAbiTypeId.ClarityAbiTypeUInt128:\n      return uintCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeInt128:\n      return intCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeBool:\n      if (val === 'false' || val === '0') return falseCV();\n      else if (val === 'true' || val === '1') return trueCV();\n      else throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);\n    case ClarityAbiTypeId.ClarityAbiTypePrincipal:\n      if (val.includes('.')) {\n        const [addr, name] = val.split('.');\n        return contractPrincipalCV(addr, name);\n      } else {\n        return standardPrincipalCV(val);\n      }\n    case ClarityAbiTypeId.ClarityAbiTypeTraitReference:\n      const [addr, name] = val.split('.');\n      return contractPrincipalCV(addr, name);\n    case ClarityAbiTypeId.ClarityAbiTypeNone:\n      return noneCV();\n    case ClarityAbiTypeId.ClarityAbiTypeBuffer:\n      return bufferCV(Buffer.from(val, 'utf8'));\n    case ClarityAbiTypeId.ClarityAbiTypeStringAscii:\n      return stringAsciiCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:\n      return stringUtf8CV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeResponse:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeOptional:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeTuple:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeList:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    default:\n      throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);\n  }\n}\nexport { encodeClarityValue };\n\nexport function getTypeString(val: ClarityAbiType): string {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'int128') {\n      return 'int';\n    } else if (val === 'uint128') {\n      return 'uint';\n    }\n    return val;\n  } else if (isClarityAbiBuffer(val)) {\n    return `(buff ${val.buffer.length})`;\n  } else if (isClarityAbiStringAscii(val)) {\n    return `(string-ascii ${val['string-ascii'].length})`;\n  } else if (isClarityAbiStringUtf8(val)) {\n    return `(string-utf8 ${val['string-utf8'].length})`;\n  } else if (isClarityAbiResponse(val)) {\n    return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;\n  } else if (isClarityAbiOptional(val)) {\n    return `(optional ${getTypeString(val.optional)})`;\n  } else if (isClarityAbiTuple(val)) {\n    return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;\n  } else if (isClarityAbiList(val)) {\n    return `(list ${val.list.length} ${getTypeString(val.list.type)})`;\n  } else {\n    throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);\n  }\n}\n\nexport interface ClarityAbiFunction {\n  name: string;\n  access: 'private' | 'public' | 'read_only';\n  args: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  outputs: {\n    type: ClarityAbiType;\n  };\n}\n\nexport function abiFunctionToString(func: ClarityAbiFunction): string {\n  const access = func.access === 'read_only' ? 'read-only' : func.access;\n  return `(define-${access} (${func.name} ${func.args\n    .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)\n    .join(' ')}))`;\n}\n\nexport interface ClarityAbiVariable {\n  name: string;\n  access: 'variable' | 'constant';\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbiMap {\n  name: string;\n  key: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  value: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n}\n\nexport interface ClarityAbiTypeFungibleToken {\n  name: string;\n}\n\nexport interface ClarityAbiTypeNonFungibleToken {\n  name: string;\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbi {\n  functions: ClarityAbiFunction[];\n  variables: ClarityAbiVariable[];\n  maps: ClarityAbiMap[];\n  fungible_tokens: ClarityAbiTypeFungibleToken[];\n  non_fungible_tokens: ClarityAbiTypeNonFungibleToken[];\n}\n\nfunction matchType(cv: ClarityValue, abiType: ClarityAbiType): boolean {\n  const union = getTypeUnion(abiType);\n\n  switch (cv.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;\n    case ClarityType.Int:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;\n    case ClarityType.UInt:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;\n    case ClarityType.Buffer:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&\n        union.type.buffer.length >= cv.buffer.length\n      );\n    case ClarityType.StringASCII:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&\n        union.type['string-ascii'].length >= cv.data.length\n      );\n    case ClarityType.StringUTF8:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&\n        union.type['string-utf8'].length >= cv.data.length\n      );\n    case ClarityType.OptionalNone:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional\n      );\n    case ClarityType.OptionalSome:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&\n        matchType(cv.value, union.type.optional)\n      );\n    case ClarityType.ResponseErr:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.error)\n      );\n    case ClarityType.ResponseOk:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.ok)\n      );\n    case ClarityType.PrincipalContract:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference\n      );\n    case ClarityType.PrincipalStandard:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;\n    case ClarityType.List:\n      return (\n        union.id == ClarityAbiTypeId.ClarityAbiTypeList &&\n        union.type.list.length >= cv.list.length &&\n        cv.list.every(val => matchType(val, union.type.list.type))\n      );\n    case ClarityType.Tuple:\n      if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {\n        const tuple = cloneDeep(cv.data);\n        for (let i = 0; i < union.type.tuple.length; i++) {\n          const abiTupleEntry = union.type.tuple[i];\n          const key = abiTupleEntry.name;\n          const val = tuple[key];\n\n          // if key exists in cv tuple, check if its type matches the abi\n          // return false if key doesn't exist\n          if (val) {\n            if (!matchType(val, abiTupleEntry.type)) {\n              return false;\n            }\n            delete tuple[key];\n          } else {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n}\n\n/**\n * Validates a contract-call payload with a contract ABI\n *\n * @param {ContractCallPayload} payload - a contract-call payload\n * @param {ClarityAbi} abi - a contract ABI\n *\n * @returns {boolean} true if the payloads functionArgs type check against those in the ABI\n */\nexport function validateContractCall(payload: ContractCallPayload, abi: ClarityAbi): boolean {\n  const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);\n  if (filtered.length === 1) {\n    const abiFunc = filtered[0];\n    const abiArgs = abiFunc.args;\n\n    if (payload.functionArgs.length !== abiArgs.length) {\n      throw new Error(\n        `Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`\n      );\n    }\n\n    for (let i = 0; i < payload.functionArgs.length; i++) {\n      const payloadArg = payload.functionArgs[i];\n      const abiArg = abiArgs[i];\n\n      if (!matchType(payloadArg, abiArg.type)) {\n        const argNum = i + 1;\n        throw new Error(\n          `Clarity function \\`${\n            payload.functionName.content\n          }\\` expects argument ${argNum} to be of type ${getTypeString(\n            abiArg.type\n          )}, not ${getCVTypeString(payloadArg)}`\n        );\n      }\n    }\n\n    return true;\n  } else if (filtered.length === 0) {\n    throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);\n  } else {\n    throw new Error(\n      `Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`\n    );\n  }\n}\n\n/**\n * Convert string input to Clarity value based on contract ABI data. Only handles Clarity\n * primitives and buffers. Responses, optionals, tuples and lists are not supported.\n *\n * @param {string} input - string to be parsed into Clarity value\n * @param {ClarityAbiType} type - the contract function argument object\n *\n * @returns {ClarityValue} returns a Clarity value\n */\nexport function parseToCV(input: string, type: ClarityAbiType): ClarityValue {\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(input);\n    } else if (type === 'int128') {\n      return intCV(input);\n    } else if (type === 'bool') {\n      if (input.toLowerCase() === 'true') {\n        return trueCV();\n      } else if (input.toLowerCase() === 'false') {\n        return falseCV();\n      } else {\n        throw new Error(`Invalid bool value: ${input}`);\n      }\n    } else if (type === 'principal') {\n      if (input.includes('.')) {\n        const [address, contractName] = input.split('.');\n        return contractPrincipalCV(address, contractName);\n      } else {\n        return standardPrincipalCV(input);\n      }\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    const inputLength = Buffer.from(input).byteLength;\n    if (inputLength > type.buffer.length) {\n      throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);\n    }\n    return bufferCVFromString(input);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}\n","import { StacksTransaction } from './transaction';\n\nimport { StacksPrivateKey, StacksPublicKey } from './keys';\nimport { isSingleSig, nextVerification, SpendingConditionOpts } from './authorization';\nimport { cloneDeep } from './utils';\nimport { AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\n\nexport class TransactionSigner {\n  transaction: StacksTransaction;\n  sigHash: string;\n  originDone: boolean;\n  checkOversign: boolean;\n  checkOverlap: boolean;\n\n  constructor(transaction: StacksTransaction) {\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n\n    // If multi-sig spending condition exists, iterate over\n    // auth fields and reconstruct sigHash\n    const spendingCondition = transaction.auth.spendingCondition;\n    if (spendingCondition && !isSingleSig(spendingCondition)) {\n      if (\n        spendingCondition.fields.filter(\n          field => field.contents.type === StacksMessageType.MessageSignature\n        ).length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('SpendingCondition has more signatures than are expected');\n      }\n\n      spendingCondition.fields.forEach(field => {\n        if (field.contents.type === StacksMessageType.MessageSignature) {\n          const signature = field.contents;\n          const nextVerify = nextVerification(\n            this.sigHash,\n            transaction.auth.authType,\n            spendingCondition.fee,\n            spendingCondition.nonce,\n            PubKeyEncoding.Compressed, // always compressed for multisig\n            signature\n          );\n          this.sigHash = nextVerify.nextSigHash;\n        }\n      });\n    }\n  }\n\n  static createSponsorSigner(\n    transaction: StacksTransaction,\n    spendingCondition: SpendingConditionOpts\n  ) {\n    if (transaction.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n    }\n\n    const tx: StacksTransaction = cloneDeep(transaction);\n    tx.setSponsor(spendingCondition);\n    const originSigHash = tx.verifyOrigin();\n    const signer = new this(tx);\n    signer.originDone = true;\n    signer.sigHash = originSigHash;\n    signer.checkOversign = true;\n    signer.checkOverlap = true;\n    return signer;\n  }\n\n  signOrigin(privateKey: StacksPrivateKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw new SigningError('Cannot sign origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n      const spendingCondition = this.transaction.auth.spendingCondition;\n      if (\n        this.checkOversign &&\n        spendingCondition.fields.filter(\n          field => field.contents.type === StacksMessageType.MessageSignature\n        ).length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('Origin would have too many signatures');\n      }\n    }\n\n    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n  }\n\n  appendOrigin(publicKey: StacksPublicKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw Error('Cannot append public key to origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new Error('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    this.transaction.appendPubkey(publicKey);\n  }\n\n  signSponsor(privateKey: StacksPrivateKey) {\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.authType !== AuthType.Sponsored) {\n      throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n    }\n\n    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n    this.originDone = true;\n  }\n\n  getTxInComplete(): StacksTransaction {\n    return cloneDeep(this.transaction);\n  }\n\n  resume(transaction: StacksTransaction) {\n    this.transaction = cloneDeep(transaction);\n    this.sigHash = transaction.signBegin();\n  }\n}\n","import { Buffer, IntegerType, intToBigInt } from '@stacks/common';\nimport {\n  StacksNetwork,\n  StacksMainnet,\n  StacksNetworkName,\n  StacksTestnet,\n  FetchFn,\n  createFetchFn,\n} from '@stacks/network';\nimport { c32address } from 'c32check';\nimport {\n  Authorization,\n  createMultiSigSpendingCondition,\n  createSingleSigSpendingCondition,\n  createSponsoredAuth,\n  createStandardAuth,\n  SpendingCondition,\n  MultiSigSpendingCondition,\n} from './authorization';\nimport { ClarityValue, PrincipalCV } from './clarity';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  AnchorMode,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  PayloadType,\n  PostConditionMode,\n  SingleSigHashMode,\n  TransactionVersion,\n  TxRejectedReason,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  StacksMessageType,\n} from './constants';\nimport { ClarityAbi, validateContractCall } from './contract-abi';\nimport {\n  createStacksPrivateKey,\n  createStacksPublicKey,\n  getPublicKey,\n  pubKeyfromPrivKey,\n  publicKeyFromBuffer,\n  publicKeyToAddress,\n  publicKeyToString,\n} from './keys';\nimport {\n  createContractCallPayload,\n  createSmartContractPayload,\n  createTokenTransferPayload,\n  Payload,\n  serializePayload,\n} from './payload';\nimport {\n  createFungiblePostCondition,\n  createNonFungiblePostCondition,\n  createSTXPostCondition,\n} from './postcondition';\nimport {\n  AssetInfo,\n  createContractPrincipal,\n  createStandardPrincipal,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n  PostCondition,\n  STXPostCondition,\n} from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\n\n/**\n * Lookup the nonce for an address from a core node\n *\n * @param {string} address - the c32check address to look up\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to look up address on\n *\n * @return a promise that resolves to an integer\n */\nexport async function getNonce(\n  address: string,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getAccountApiUrl(address);\n\n  const response = await derivedNetwork.fetchFn(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const responseText = await response.text();\n  const result = JSON.parse(responseText) as { nonce: string };\n  return BigInt(result.nonce);\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a token transfer\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateTransfer(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(\n      `Transaction fee estimation only possible with ${\n        PayloadType[PayloadType.TokenTransfer]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\n\ninterface FeeEstimation {\n  fee: number;\n  fee_rate: number;\n}\ninterface FeeEstimateResponse {\n  cost_scalar_change_by_byte: bigint;\n  estimated_cost: {\n    read_count: bigint;\n    read_length: bigint;\n    runtime: bigint;\n    write_count: bigint;\n    write_length: bigint;\n  };\n  estimated_cost_scalar: bigint;\n  estimations: [FeeEstimation, FeeEstimation, FeeEstimation];\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a Stacks transaction\n *\n * @param {StacksTransaction} transaction - the transaction to estimate fees for\n * @param {number} estimatedLen - is an optional argument that provides the endpoint with an\n * estimation of the final length (in bytes) of the transaction, including any post-conditions\n * and signatures\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction fees for\n *\n * @return a promise that resolves to FeeEstimate\n */\nexport async function estimateTransaction(\n  transactionPayload: Payload,\n  estimatedLen?: number,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<[FeeEstimation, FeeEstimation, FeeEstimation]> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      transaction_payload: serializePayload(transactionPayload).toString('hex'),\n      ...(estimatedLen ? { estimated_len: estimatedLen } : {}),\n    }),\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, options);\n\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  const data: FeeEstimateResponse = await response.json();\n  return data.estimations;\n}\n\nexport type SerializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Serialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type DeserializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Deserialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type SignatureValidationRejection = {\n  error: string;\n  reason: TxRejectedReason.SignatureValidation;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type BadNonceRejection = {\n  error: string;\n  reason: TxRejectedReason.BadNonce;\n  reason_data: {\n    expected: number;\n    actual: number;\n    is_origin: boolean;\n    principal: boolean;\n  };\n  txid: string;\n};\n\nexport type FeeTooLowRejection = {\n  error: string;\n  reason: TxRejectedReason.FeeTooLow;\n  reason_data: {\n    expected: number;\n    actual: number;\n  };\n  txid: string;\n};\n\nexport type NotEnoughFundsRejection = {\n  error: string;\n  reason: TxRejectedReason.NotEnoughFunds;\n  reason_data: {\n    expected: string;\n    actual: string;\n  };\n  txid: string;\n};\n\nexport type NoSuchContractRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchContract;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoSuchPublicFunctionRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchPublicFunction;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadFunctionArgumentRejection = {\n  error: string;\n  reason: TxRejectedReason.BadFunctionArgument;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ContractAlreadyExistsRejection = {\n  error: string;\n  reason: TxRejectedReason.ContractAlreadyExists;\n  reason_data: {\n    contract_identifier: string;\n  };\n  txid: string;\n};\n\nexport type PoisonMicroblocksDoNotConflictRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblocksDoNotConflict;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockHasUnknownPubKeyHashRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockHasUnknownPubKeyHash;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockIsInvalidRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockIsInvalid;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadAddressVersionByteRejection = {\n  error: string;\n  reason: TxRejectedReason.BadAddressVersionByte;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoCoinbaseViaMempoolRejection = {\n  error: string;\n  reason: TxRejectedReason.NoCoinbaseViaMempool;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureNoSuchChainTipRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureNoSuchChainTip;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureDatabaseRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureDatabase;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ServerFailureOtherRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureOther;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type TxBroadcastResultOk = {\n  txid: string;\n  error?: undefined;\n  reason?: undefined;\n  reason_data?: undefined;\n};\n\nexport type TxBroadcastResultRejected =\n  | SerializationRejection\n  | DeserializationRejection\n  | SignatureValidationRejection\n  | BadNonceRejection\n  | FeeTooLowRejection\n  | NotEnoughFundsRejection\n  | NoSuchContractRejection\n  | NoSuchPublicFunctionRejection\n  | BadFunctionArgumentRejection\n  | ContractAlreadyExistsRejection\n  | PoisonMicroblocksDoNotConflictRejection\n  | PoisonMicroblockHasUnknownPubKeyHashRejection\n  | PoisonMicroblockIsInvalidRejection\n  | BadAddressVersionByteRejection\n  | NoCoinbaseViaMempoolRejection\n  | ServerFailureNoSuchChainTipRejection\n  | ServerFailureDatabaseRejection\n  | ServerFailureOtherRejection;\n\nexport type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to broadcast\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastTransaction(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork,\n  attachment?: Buffer\n): Promise<TxBroadcastResult> {\n  const rawTx = transaction.serialize();\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getBroadcastApiUrl();\n\n  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);\n}\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {Buffer} rawTx - the raw serialized transaction buffer to broadcast\n * @param {string} url - the broadcast endpoint URL\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastRawTransaction(\n  rawTx: Buffer,\n  url: string,\n  attachment?: Buffer,\n  fetchFn: FetchFn = createFetchFn()\n): Promise<TxBroadcastResult> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\n    body: attachment\n      ? JSON.stringify({\n          tx: rawTx.toString('hex'),\n          attachment: attachment.toString('hex'),\n        })\n      : rawTx,\n  };\n\n  const response = await fetchFn(url, options);\n  if (!response.ok) {\n    try {\n      return (await response.json()) as TxBroadcastResult;\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${(e as Error).message}`);\n    }\n  }\n\n  const text = await response.text();\n  // Replace extra quotes around txid string\n  const txid = text.replace(/[\"]+/g, '');\n  const isValidTxId = validateTxId(txid);\n  if (!isValidTxId) {\n    throw new Error(text);\n  }\n  return {\n    txid,\n  } as TxBroadcastResult;\n}\n\n/**\n * Fetch a contract's ABI\n *\n * @param {string} address - the contracts address\n * @param {string} contractName - the contracts name\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds\n */\nexport async function getAbi(\n  address: string,\n  contractName: string,\n  network: StacksNetworkName | StacksNetwork\n): Promise<ClarityAbi> {\n  const options = {\n    method: 'GET',\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getAbiApiUrl(address, contractName);\n\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return JSON.parse(await response.text()) as ClarityAbi;\n}\n\nfunction deriveNetwork(transaction: StacksTransaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\n\nexport interface MultiSigOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys?: string[];\n}\n\n/**\n * STX token transfer transaction options\n */\nexport interface TokenTransferOptions {\n  /** the address of the recipient of the token transfer */\n  recipient: string | PrincipalCV;\n  /** the amount to be transfered in microstacks */\n  amount: IntegerType;\n  /** the transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorMode;\n  /** an arbitrary string to include in the transaction, must be less than 34 bytes */\n  memo?: string;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedTokenTransferOptions extends TokenTransferOptions {\n  publicKey: string;\n}\n\nexport interface SignedTokenTransferOptions extends TokenTransferOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * Generates an unsigned Stacks token transfer transaction\n *\n * Returns a Stacks token transfer transaction.\n *\n * @param  {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedSTXTokenTransfer(\n  txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    memo: '',\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n\n  let authorization: Authorization | null = null;\n  let spendingCondition: SpendingCondition | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    const txFee = await estimateTransaction(payload, estimatedLen, options.network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a signed Stacks token transfer transaction\n *\n * Returns a signed Stacks token transfer transaction.\n *\n * @param  {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {StacksTransaction}\n */\nexport async function makeSTXTokenTransfer(\n  txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    // txOptions is SignedTokenTransferOptions\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    // txOptions is SignedMultiSigTokenTransferOptions\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Contract deploy transaction options\n */\nexport interface BaseContractDeployOptions {\n  contractName: string;\n  /** the Clarity code to be deployed */\n  codeBody: string;\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface ContractDeployOptions extends BaseContractDeployOptions {\n  /** a hex string of the private key of the transaction sender */\n  senderKey: string;\n}\n\nexport interface UnsignedContractDeployOptions extends BaseContractDeployOptions {\n  /** a hex string of the public key of the transaction sender */\n  publicKey: string;\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract deploy\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractDeploy(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.SmartContract) {\n    throw new Error(\n      `Contract deploy fee estimation only possible with ${\n        PayloadType[PayloadType.SmartContract]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract deploy fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates a Clarity smart contract deploy transaction\n *\n * @param  {ContractDeployOptions} txOptions - an options object for the contract deploy\n *\n * Returns a signed Stacks smart contract deploy transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractDeploy(\n  txOptions: ContractDeployOptions\n): Promise<StacksTransaction> {\n  const privKey = createStacksPrivateKey(txOptions.senderKey);\n  const stacksPublicKey = getPublicKey(privKey);\n  const publicKey = publicKeyToString(stacksPublicKey);\n  const unsignedTxOptions: UnsignedContractDeployOptions = { ...txOptions, publicKey };\n  const transaction: StacksTransaction = await makeUnsignedContractDeploy(unsignedTxOptions);\n\n  if (txOptions.senderKey) {\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n  }\n\n  return transaction;\n}\n\nexport async function makeUnsignedContractDeploy(\n  txOptions: UnsignedContractDeployOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createSmartContractPayload(options.contractName, options.codeBody);\n\n  const addressHashMode = AddressHashMode.SerializeP2PKH;\n  const pubKey = createStacksPublicKey(options.publicKey);\n\n  let authorization: Authorization | null = null;\n\n  const spendingCondition = createSingleSigSpendingCondition(\n    addressHashMode,\n    publicKeyToString(pubKey),\n    options.nonce,\n    options.fee\n  );\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    const txFee = await estimateTransaction(payload, estimatedLen, options.network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Contract function call transaction options\n */\nexport interface ContractCallOptions {\n  /** the Stacks address of the contract */\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  feeEstimateApiUrl?: string;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the Stacks blockchain network that will ultimately be used to broadcast this transaction */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true to validate that the supplied function args match those specified in\n   * the published contract */\n  validateWithAbi?: boolean | ClarityAbi;\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractCallOptions extends ContractCallOptions {\n  publicKey: string;\n}\n\nexport interface SignedContractCallOptions extends ContractCallOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract function call\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractFunctionCall(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(\n      `Contract call fee estimation only possible with ${\n        PayloadType[PayloadType.ContractCall]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract call fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates an unsigned Clarity smart contract function call transaction\n *\n * @param {UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions} txOptions - an options object for the contract call\n *\n * @returns {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedContractCall(\n  txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createContractCallPayload(\n    options.contractAddress,\n    options.contractName,\n    options.functionName,\n    options.functionArgs\n  );\n\n  if (options?.validateWithAbi) {\n    let abi: ClarityAbi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options?.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition: SpendingCondition | null = null;\n  let authorization: Authorization | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    const txFee = await estimateTransaction(payload, estimatedLen, network);\n    transaction.setFee(txFee[1].fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a Clarity smart contract function call transaction\n *\n * @param  {SignedContractCallOptions | SignedMultiSigContractCallOptions} txOptions - an options object for the contract function call\n *\n * Returns a signed Stacks smart contract function call transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractCall(\n  txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Generates a STX post condition with a standard principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens\n */\nexport function makeStandardSTXPostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\n\n/**\n * Generates a STX post condition with a contract principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address of the contract\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens\n *\n * @return {STXPostCondition}\n */\nexport function makeContractSTXPostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount\n  );\n}\n\n/**\n * Generates a fungible token post condition with a standard principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeStandardFungiblePostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a fungible token post condition with a contract principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeContractFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a standard principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param  {ClarityValue} assetName - asset name describing the non-fungible token\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeStandardNonFungiblePostCondition(\n  address: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    assetInfo,\n    assetName\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a contract principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {String} contractName - the name of the contract\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param  {ClarityValue} assetName - asset name describing the non-fungible token\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeContractNonFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    assetInfo,\n    assetName\n  );\n}\n\n/**\n * Read only function options\n *\n * @param  {String} contractAddress - the c32check address of the contract\n * @param  {String} contractName - the contract name\n * @param  {String} functionName - name of the function to be called\n * @param  {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {String} senderAddress - the c32check address of the sender\n */\n\nexport interface ReadOnlyFunctionOptions {\n  contractName: string;\n  contractAddress: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** the network that the contract which contains the function is deployed to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** address of the sender */\n  senderAddress: string;\n}\n\n/**\n * Calls a function as read-only from a contract interface\n * It is not necessary that the function is defined as read-only in the contract\n *\n * @param  {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object\n *\n * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.\n *\n * @return {ClarityValue}\n */\nexport async function callReadOnlyFunction(\n  readOnlyFunctionOptions: ReadOnlyFunctionOptions\n): Promise<ClarityValue> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n\n  const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n\n  const args = functionArgs.map(arg => cvToHex(arg));\n\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args,\n  });\n\n  const response = await network.fetchFn(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\n\n/**\n * Sponsored transaction options\n */\nexport interface SponsorOptionsOpts {\n  /** the origin-signed transaction */\n  transaction: StacksTransaction;\n  /** the sponsor's private key */\n  sponsorPrivateKey: string;\n  /** the transaction fee amount to sponsor */\n  fee?: IntegerType;\n  /** the nonce of the sponsor account */\n  sponsorNonce?: IntegerType;\n  /** the hashmode of the sponsor's address */\n  sponsorAddressHashmode?: AddressHashMode;\n  /** the Stacks blockchain network that this transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n}\n\n/**\n * Constructs and signs a sponsored transaction as the sponsor\n *\n * @param  {SponsorOptionsOpts} sponsorOptions - the sponsor options object\n *\n * Returns a signed sponsored transaction.\n *\n * @return {ClarityValue}\n */\nexport async function sponsorTransaction(\n  sponsorOptions: SponsorOptionsOpts\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: 0 as IntegerType,\n    sponsorNonce: 0 as IntegerType,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH as SingleSigHashMode,\n    network:\n      sponsorOptions.transaction.version === TransactionVersion.Mainnet\n        ? new StacksMainnet()\n        : new StacksTestnet(),\n  };\n\n  const options = Object.assign(defaultOptions, sponsorOptions);\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = 0;\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n      case PayloadType.SmartContract:\n      case PayloadType.ContractCall:\n        const estimatedLen = estimateTransactionByteLength(options.transaction);\n        try {\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]\n            .fee;\n        } catch (e) {\n          throw e;\n        }\n        break;\n      default:\n        throw new Error(\n          `Sponsored transactions not supported for transaction type ${\n            PayloadType[options.transaction.payload.payloadType]\n          }`\n        );\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(\n    options.sponsorAddressHashmode,\n    publicKeyToString(sponsorPubKey),\n    options.sponsorNonce,\n    options.fee\n  );\n\n  options.transaction.setSponsor(sponsorSpendingCondition);\n\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(\n    options.transaction,\n    sponsorSpendingCondition\n  );\n  signer.signSponsor(privKey);\n\n  return signer.transaction;\n}\n\n/**\n * Estimates transaction byte length\n * Context:\n * 1) Multi-sig transaction byte length increases by adding signatures\n *    which causes the incorrect fee estimation because the fee value is set while creating unsigned transaction\n * 2) Single-sig transaction byte length remain same due to empty message signature which allocates the space for signature\n * @param {transaction} - StacksTransaction object to be estimated\n * @return {number} Estimated transaction byte length\n */\nexport function estimateTransactionByteLength(transaction: StacksTransaction): number {\n  const hashMode = transaction.auth.spendingCondition.hashMode;\n  // List of Multi-sig transaction hash modes\n  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\n\n  // Check if its a Multi-sig transaction\n  if (multiSigHashModes.includes(hashMode)) {\n    const multiSigSpendingCondition: MultiSigSpendingCondition = transaction.auth\n      .spendingCondition as MultiSigSpendingCondition;\n\n    // Find number of existing signatures if the transaction is signed or partially signed\n    const existingSignatures = multiSigSpendingCondition.fields.filter(\n      field => field.contents.type === StacksMessageType.MessageSignature\n    ).length; // existingSignatures will be 0 if its a unsigned transaction\n\n    // Estimate total signature bytes size required for this multi-sig transaction\n    // Formula: totalSignatureLength = (signaturesRequired - existingSignatures) * (SIG_LEN_BYTES + 1 byte of type of signature)\n    const totalSignatureLength =\n      (multiSigSpendingCondition.signaturesRequired - existingSignatures) *\n      (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\n\n    return transaction.serialize().byteLength + totalSignatureLength;\n  } else {\n    // Single-sig transaction\n    // Signature space already allocated by empty message signature\n    return transaction.serialize().byteLength;\n  }\n}\n","import { sha256 } from '@noble/hashes/sha256';\nimport { Buffer } from '@stacks/common';\nimport { ClarityType, ClarityValue, serializeCV } from './clarity';\nimport { StacksMessageType } from './constants';\nimport { signMessageHashRsv, StacksPrivateKey } from './keys';\n\n// Refer to SIP018 https://github.com/stacksgov/sips/\nexport const STRUCTURED_DATA_PREFIX = Buffer.from('SIP018', 'ascii');\n\nexport function hashStructuredData(structuredData: ClarityValue): Buffer {\n  return Buffer.from(sha256(serializeCV(structuredData)));\n}\n\nconst hash256BytesLength = 32;\n\nfunction isDomain(value: ClarityValue): boolean {\n  if (value.type !== ClarityType.Tuple) return false;\n  // Check that the tuple has at least 'name', 'version' and 'chain-id'\n  if (!['name', 'version', 'chain-id'].every(key => key in value.data)) return false;\n  // Check each key is of the right type\n  if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII))\n    return false;\n\n  if (value.data['chain-id'].type !== ClarityType.UInt) return false;\n  return true;\n}\n\nexport function encodeStructuredData({\n  message,\n  domain,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n}): Buffer {\n  const structuredDataHash: Buffer = hashStructuredData(message);\n  if (!isDomain(domain)) {\n    throw new Error(\n      \"domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt\"\n    );\n  }\n  const domainHash: Buffer = hashStructuredData(domain);\n\n  return Buffer.concat([STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash]);\n}\n\nexport type DecodedStructuredData = {\n  domainHash: Buffer;\n  messageHash: Buffer;\n};\n\nexport function decodeStructuredDataSignature(signature: string | Buffer): DecodedStructuredData {\n  const encodedMessageBuffer: Buffer = Buffer.from(signature);\n  const domainHash = encodedMessageBuffer.slice(\n    STRUCTURED_DATA_PREFIX.length,\n    STRUCTURED_DATA_PREFIX.length + hash256BytesLength\n  );\n  const messageHash = encodedMessageBuffer.slice(\n    STRUCTURED_DATA_PREFIX.length + hash256BytesLength\n  );\n  return {\n    domainHash,\n    messageHash,\n  };\n}\n\nexport interface StructuredDataSignature {\n  readonly type: StacksMessageType.StructuredDataSignature;\n  data: string;\n}\n\n/**\n * Signs a structured message (ClarityValue) and a domain (ClarityValue) using a private key.\n * The resulting signature along with the original message can be verified using {@link verifyMessageSignature}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signStructuredData({\n  message,\n  domain,\n  privateKey,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n  privateKey: StacksPrivateKey;\n}): StructuredDataSignature {\n  const structuredDataHash: string = Buffer.from(\n    sha256(encodeStructuredData({ message, domain }))\n  ).toString('hex');\n\n  const { data } = signMessageHashRsv({\n    messageHash: structuredDataHash,\n    privateKey,\n  });\n  return {\n    data,\n    type: StacksMessageType.StructuredDataSignature,\n  };\n}\n"],"names":["root","factory","exports","module","define","amd","this","byteLength","b64","lens","getLens","validLen","placeHoldersLen","toByteArray","tmp","i","arr","Arr","_byteLength","curByte","len","revLookup","charCodeAt","fromByteArray","uint8","length","extraBytes","parts","maxChunkLength","len2","push","encodeChunk","lookup","join","Uint8Array","Array","code","Error","indexOf","start","end","num","output","base64","ieee754","customInspectSymbol","Symbol","Buffer","SlowBuffer","alloc","INSPECT_MAX_BYTES","K_MAX_LENGTH","createBuffer","RangeError","buf","Object","setPrototypeOf","prototype","arg","encodingOrOffset","TypeError","allocUnsafe","from","value","string","encoding","isEncoding","actual","write","slice","fromString","ArrayBuffer","isView","arrayView","isInstance","copy","fromArrayBuffer","buffer","byteOffset","fromArrayLike","fromArrayView","SharedArrayBuffer","valueOf","b","obj","isBuffer","checked","undefined","numberIsNaN","type","isArray","data","fromObject","toPrimitive","assertSize","size","array","toString","mustMatch","arguments","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","m","bidirectionalIndexOf","val","dir","arrayIndexOf","call","lastIndexOf","indexSize","arrLength","valLength","String","read","readUInt16BE","foundIndex","found","j","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","asciiToBytes","base64Write","ucs2Write","units","c","hi","lo","utf16leToBytes","Math","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","decodeCodePointsArray","kMaxLength","TYPED_ARRAY_SUPPORT","proto","foo","e","typedArraySupport","console","error","defineProperty","enumerable","get","poolSize","fill","allocUnsafeSlow","_isBuffer","compare","a","x","y","concat","list","pos","set","swap16","swap32","swap64","toLocaleString","equals","inspect","max","replace","trim","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","hexSliceLookupTable","bytes","checkOffset","ext","checkInt","wrtBigUInt64LE","checkIntBI","BigInt","wrtBigUInt64BE","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","subarray","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","defineBigIntMethod","validateNumber","first","last","boundsError","readBigUInt64BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","errors","E","sym","getMessage","Base","constructor","super","writable","configurable","name","stack","message","addNumericalSeparator","range","ERR_OUT_OF_RANGE","checkBounds","ERR_INVALID_ARG_TYPE","floor","ERR_BUFFER_OUT_OF_BOUNDS","input","msg","received","isInteger","abs","INVALID_BASE64_RE","Infinity","leadSurrogate","split","base64clean","src","dst","alphabet","table","i16","fn","BufferBigIntNotDefined","c32ToB58","b58ToC32","c32addressDecode","c32address","versions","checksum_1","base58check","mainnet","p2pkh","p2sh","testnet","ADDR_BITCOIN_TO_STACKS","ADDR_STACKS_TO_BITCOIN","version","hash160hex","match","c32checkEncode","c32addr","c32checkDecode","b58check","stacksVersion","addrInfo","decode","hash160String","addrVersion","prefix","c32string","bitcoinVersion","encode","buffer_1","cross_sha256_1","basex","ALPHABET","hash","hashSha256","forEach","check","index","encoding_1","c32checksum","dataHex","versionHex","checksumHex","c32str","c32encode","c32","c32data","c32normalize","c32decode","versionChar","checksum","substring","hex","c32input","toUpperCase","inputHex","minLength","carry","currentCode","nextCode","nextBits","nextLowBits","curC32Digit","unshift","C32leadingZeros","zeroPrefix","numLeadingZeroBytesInHex","count","numLeadingZeroBytes","carryBits","currentValue","currentHexDigit","hexLeadingZeros","hexStr","address_1","_Buffer","BASE_MAP","charAt","xc","BASE","LEADER","FACTOR","log","iFACTOR","decodeUnsafe","source","psz","zeroes","b256","it3","it4","vch","pbegin","pend","b58","it1","it2","repeat","self","support","Blob","viewClasses","isArrayBufferView","normalizeName","test","normalizeValue","iteratorFor","items","iterator","next","shift","done","Headers","headers","map","append","header","getOwnPropertyNames","consumed","body","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","onload","result","onerror","readBlobAsArrayBuffer","blob","FileReader","promise","readAsArrayBuffer","bufferClone","view","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","FormData","_bodyFormData","URLSearchParams","DataView","_bodyArrayBuffer","rejected","arrayBuffer","then","text","readAsText","chars","readArrayBufferAsText","formData","json","JSON","parse","oldValue","has","hasOwnProperty","callback","thisArg","keys","values","entries","methods","Request","options","method","upcased","url","credentials","mode","signal","referrer","form","decodeURIComponent","Response","bodyInit","status","ok","statusText","clone","response","redirectStatuses","redirect","location","DOMException","err","create","fetch","init","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","rawHeaders","getAllResponseHeaders","line","key","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","addEventListener","onreadystatechange","readyState","removeEventListener","send","polyfill","sha256","sha256nodeCrypto","sha256js","_blockSize","_finalSize","_len","_w","_a","_b","_c","_d","_e","_f","_g","_h","_block","update","block","blockSize","accum","assigned","remainder","_update","digest","rem","bits","lowBits","highBits","ch","z","maj","sigma0","sigma1","gamma0","gamma1","M","W","d","f","g","h","T1","K","T2","useCryptoModuleCache","nodeCryptoCreateHash","_nodeCryptoAvailable","isAvailable","cryptoModule","createHash","isNodeCryptoAvailable","instance","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","s","NaN","rt","isNaN","LN2","HASH_UNDEFINED","MAX_SAFE_INTEGER","argsTag","boolTag","dateTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reFlags","reIsHostCtor","reIsUint","cloneableTags","freeGlobal","freeSelf","Function","freeExports","nodeType","freeModule","moduleExports","addMapEntry","pair","addSetEntry","add","arrayReduce","iteratee","accumulator","initAccum","isHostObject","mapToArray","overArg","func","transform","setToArray","uid","arrayProto","funcProto","objectProto","coreJsData","maskSrcKey","exec","IE_PROTO","funcToString","objectToString","reIsNative","RegExp","getPrototype","getPrototypeOf","objectCreate","propertyIsEnumerable","splice","nativeGetSymbols","getOwnPropertySymbols","nativeIsBuffer","nativeKeys","getNative","Map","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","Hash","clear","entry","ListCache","MapCache","Stack","__data__","assignValue","object","objValue","eq","assocIndexOf","baseClone","isDeep","isFull","customizer","isObject","isArr","initCloneArray","copyArray","tag","getTag","isFunc","cloneBuffer","isPrototype","initCloneObject","copyObject","getSymbols","copySymbols","baseAssign","cloneFunc","symbol","Ctor","cloneArrayBuffer","dataView","cloneDataView","typedArray","cloneTypedArray","cloneMap","regexp","lastIndex","cloneRegExp","cloneSet","initCloneByTag","stacked","props","keysFunc","symbolsFunc","arrayPush","baseGetAllKeys","getAllKeys","arrayEach","subValue","newValue","getMapData","getValue","isFunction","baseIsNative","pop","cache","pairs","LARGE_ARRAY_SIZE","isIndex","other","ctorString","isArrayLike","isLength","inherited","isObjectLike","isArrayLikeObject","isArguments","baseTimes","skipIndexes","arrayLikeKeys","baseKeys","copyProps","SafeBuffer","utils_1","SmartBuffer","_encoding","_writeOffset","_readOffset","isSmartBufferOptions","checkEncoding","isFiniteInteger","ERRORS","INVALID_SMARTBUFFER_SIZE","_buff","buff","INVALID_SMARTBUFFER_BUFFER","INVALID_SMARTBUFFER_OBJECT","static","castOptions","_readNumberValue","bigIntAndBufferInt64Check","_writeNumberValue","insertInt8","_insertNumberValue","insertInt16BE","insertInt16LE","insertInt32BE","insertInt32LE","insertBigInt64BE","insertBigInt64LE","insertUInt8","insertUInt16BE","insertUInt16LE","insertUInt32BE","insertUInt32LE","insertBigUInt64BE","insertBigUInt64LE","insertFloatBE","insertFloatLE","insertDoubleBE","insertDoubleLE","readString","arg1","lengthVal","checkLengthValue","insertString","checkOffsetValue","_handleString","writeString","arg2","readStringNT","nullPos","insertStringNT","writeStringNT","writeOffset","readBuffer","endPoint","insertBuffer","_handleBuffer","writeBuffer","readBufferNT","insertBufferNT","writeBufferNT","readOffset","checkTargetOffset","internalBuffer","toBuffer","encodingVal","destroy","isInsert","arg3","offsetVal","ensureInsertable","_ensureWriteable","ensureReadable","INVALID_READ_BEYOND_BOUNDS","dataLength","_ensureCapacity","oldLength","newLength","byteSize","INVALID_WRITE_BEYOND_BOUNDS","INVALID_ENCODING","INVALID_OFFSET","INVALID_OFFSET_NON_NUMBER","INVALID_LENGTH","INVALID_LENGTH_NON_NUMBER","INVALID_TARGET_OFFSET","INVALID_TARGET_LENGTH","checkOffsetOrLengthValue","bufferMethod","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","id","loaded","__webpack_modules__","getter","__esModule","definition","o","globalThis","window","prop","r","toStringTag","nmd","paths","children","AvailableBufferModule","intToBytes","signed","intToBigInt","parsedValue","startsWith","padStart","SyntaxError","bn","width","nthBit","fromTwos","bytesToHex","with0x","hexToBigInt","intToHex","integer","lengthBytes","hexToInt","hexByte","byte","hexToBytes","hexes","_","uint8a","u","DEFAULT_CHAIN_ID","MAX_STRING_LENGTH_BYTES","CLARITY_INT_SIZE","CLARITY_INT_BYTE_SIZE","COINBASE_BUFFER_LENGTH_BYTES","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","COMPRESSED_PUBKEY_LENGTH_BYTES","UNCOMPRESSED_PUBKEY_LENGTH_BYTES","MEMO_MAX_LENGTH_BYTES","DEFAULT_CORE_NODE_API_URL","StacksMessageType","PayloadType","AnchorMode","DEFAULT_TRANSACTION_VERSION","PostConditionMode","PostConditionType","AuthType","AddressHashMode","AddressVersion","PubKeyEncoding","FungibleConditionCode","NonFungibleConditionCode","PostConditionPrincipalID","AssetType","TxRejectedReason","crypto","createView","rotr","word","Uint32Array","TextEncoder","assertNumber","isSafeInteger","v","nodeRequire","require","bind","setImmediate","_cloneInto","wrapConstructor","hashConstructor","hashC","outputLen","blockLen","SHA2","padOffset","finished","destroyed","take","process","roundClean","digestInto","setBigUint64","_32n","_u32_max","wh","wl","l","setUint32","oview","to","Rho","Id","Pi","idxL","idxR","k","shifts","shiftsL","idx","shiftsR","Kl","Kr","rotl","group","BUF","RIPEMD160","h0","h1","h2","h3","h4","getUint32","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","tr","ripemd160","Maj","SHA256_K","IV","SHA256_W","SHA256","A","B","C","D","F","G","H","W15","W2","s0","s1","U32_MASK64","fromBig","le","shrSH","shrSL","rotrSH","rotrSL","rotrBH","rotrBL","Ah","Al","Bh","Bl","add3L","Cl","add3H","low","Ch","add4L","Dl","add4H","Dh","add5L","El","add5H","Eh","SHA512_Kh","SHA512_Kl","lst","SHA512_W_H","SHA512_W_L","SHA512","Fh","Fl","Gh","Gl","Hh","Hl","W15h","W15l","s0h","s0l","W2h","W2l","s1h","s1l","SUMl","SUMh","sigma1h","sigma1l","CHIh","T1ll","T1h","T1l","sigma0h","sigma0l","MAJh","MAJl","All","SHA512_256","SHA384","sha512_256","_0n","_1n","_2n","_3n","_8n","POW_2_256","CURVE","P","Gx","Gy","beta","weistrass","x2","mod","x3","USE_ENDOMORPHISM","JacobianPoint","p","Point","points","toInv","nums","scratch","inverted","invert","reduce","acc","reduceRight","invertBatch","toAffine","toAffineBatch","fromAffine","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","negate","double","X3","Y3","Z3","ZERO","HH","HHH","V","subtract","multiplyUnsafe","scalar","normalizeScalar","P0","k1neg","k1","k2neg","k2","splitScalarEndo","k1p","k2p","precomputeWindow","windows","base","wNAF","affinePoint","_WINDOW_SIZE","precomputes","pointPrecomputes","normalizeZ","windowSize","mask","maxNumber","shiftBy","wbits","pr","cached","multiply","point","fake","f2p","f1p","invZ","iz1","iz2","iz3","ax","ay","_setWindowSize","delete","isShort","bytesToNumber","isValidFieldElement","_6n","_11n","_22n","_23n","_44n","_88n","b2","b3","b6","pow2","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","sqrtMod","isYOdd","assertValidity","ensureBytes","fromCompressedHex","fromUncompressedHex","privateKey","normalizePrivateKey","msgHash","signature","recovery","delta","truncateHash","Signature","fromDER","fromCompact","normalizeSignature","R","fromHex","numTo32bStr","rinv","u1","u2","Q","multiplyAndAddUnsafe","toRawBytes","isCompressed","toHex","toHexX","toRawX","left","aP","bQ","sum","sliceDER","parseDERInt","isUint8a","hexToNumber","sBytes","rBytesLeft","parseDERSignature","isWithinCurveOrder","hasHighS","HALF","normalizeS","toDERRawBytes","toDERHex","sHex","numberToHexUnpadded","rHex","rLen","sLen","toCompactRawBytes","toCompactHex","arrays","every","pad","power","number","modulo","q","divNearest","POW_2_128","a1","b1","a2","c1","c2","HmacDrbg","counter","hmac","utils","hmacSha256","hmacSync","hmacSha256Sync","incr","async","seed","reseedSync","generateSync","kmdToSig","kBytes","sig","bits2int","bits2octets","z1","z2","int2octets","node","web","isValidPrivateKey","hashToPrivateKey","numTo32b","randomBytes","bytesLength","getRandomValues","randomPrivateKey","subtle","messages","ckey","importKey","sign","createHmac","sha256Sync","precompute","HMAC","_key","assertHash","iHash","oHash","parseRecoverableSignatureVrs","COORDINATE_BYTES","recoveryIdHex","recoveryId","TransactionVersion","ChainID","createMessageSignature","MessageSignature","addressHashModeToVersion","hashMode","txVersion","SerializeP2PKH","MainnetSingleSig","TestnetSingleSig","stringify","SerializeP2SH","SerializeP2WPKH","SerializeP2WSH","MainnetMultiSig","TestnetMultiSig","addressFromVersionHash","Address","hash160","addressToString","address","getAddressFromPrivateKey","transactionVersion","getAddressFromPublicKey","pubKeyfromPrivKey","publicKey","hashP2PKH","createStacksPublicKey","PublicKey","publicKeyFromSignatureVrs","messageSignature","pubKeyEncoding","Compressed","parsedSignature","fromSignature","compressed","publicKeyFromSignatureRsv","msgs","publicKeyFromSignature","publicKeyFromBuffer","publicKeyToString","serializePublicKey","bufferArray","BufferArray","concatBuffer","privKey","createStacksPrivateKey","fromPrivateKey","compressPublicKey","deserializePublicKey","bufferReader","fieldId","keyLength","privateKeyBuffer","privateKeyToBuffer","makeRandomPrivKey","signWithKey","messageHash","rawSignature","opts","extraEntropy","seedArgs","initSigArgs","drbg","recSig","canonical","der","recovered","assign","hashed","finalizeSig","signSync","signMessageHashRsv","parseRecoverableSignature","privateKeyToString","publicKeyToAddress","parseAssetInfoString","assetAddress","assetContractName","assetTokenName","createAssetInfo","createLPString","content","lengthPrefixBytes","maxLengthBytes","prefixLength","maxLength","exceedsMaxLengthBytes","LengthPrefixedString","addressString","contractName","assetName","AssetInfo","createAddress","c32AddressString","addressData","parsePrincipalString","principalString","createContractPrincipal","createStandardPrincipal","addr","Principal","Contract","Standard","ClarityType","MAX_U128","MIN_U128","MAX_I128","MIN_I128","intCV","bigInt","Int","uintCV","UInt","bufferCV","bufferCVFromString","trueCV","BoolTrue","falseCV","BoolFalse","principalToString","principal","PrincipalStandard","PrincipalContract","principalCV","contractPrincipalCV","standardPrincipalCV","standardPrincipalCVFromAddress","contractPrincipalCVFromAddress","contractPrincipalCVFromStandard","sp","lengthPrefixedContractName","responseErrorCV","ResponseErr","responseOkCV","ResponseOk","noneCV","OptionalNone","someCV","OptionalSome","listCV","List","tupleCV","isClarityName","Tuple","enumCheckFunctions","isEnum","enumVariable","checker","newChecker","enumValues","filter","enumValueSet","createEnumChecker","BufferReader","smartBuffer","readBigUIntLE","reverse","readBigUIntBE","readUInt8Enum","invalidEnumErrorFormatter","SerializationError","captureStackTrace","DeserializationError","NotImplementedError","SigningError","VerificationError","stringAsciiCV","StringASCII","stringUtf8CV","StringUTF8","deserializeCV","serializedClarityValue","hasHexPrefix","bufferLength","deserializeAddress","deserializeLPString","listLength","listContents","tupleLength","tupleContents","clarityName","asciiStrLen","asciiStr","utf8StrLen","utf8Str","createTokenTransferPayload","recipient","amount","memo","createMemoString","Payload","payloadType","TokenTransfer","createContractCallPayload","contractAddress","functionName","functionArgs","ContractCall","createSmartContractPayload","codeBody","codeBodyString","SmartContract","serializePayload","payload","appendByte","serializeCV","serializeStacksMessage","numArgs","PoisonMicroblock","Coinbase","coinbaseBuffer","deserializePayload","deserializeMemoString","contractCallName","numberOfArgs","clarityValue","createCoinbasePayload","AuthFieldType","deserializeMessageSignature","createTransactionAuthField","contents","TransactionAuthField","deserializeTransactionAuthField","authFieldType","Uncompressed","serializeMessageSignature","appendHexString","serializeTransactionAuthField","field","serializeAddress","serializePrincipal","serializeLPString","MemoString","serializeMemoString","serializeAssetInfo","PostCondition","serializePostCondition","LengthPrefixedList","serializeLPList","deserializeStacksMessage","listType","deserializePrincipal","deserializeAssetInfo","deserializePostCondition","deserializeLPList","createEmptyAddress","addressFromHashMode","addressFromPublicKeys","numSigs","publicKeys","hashP2WPKH","hashP2SH","hashP2WSH","lps","contentBuffer","prefixBytes","memoString","paddedContent","rightPadHexToLength","info","createLPList","lpList","postCondition","conditionType","Fungible","NonFungible","assetInfo","conditionCode","STX","postConditionType","bufferWithTypeID","typeId","serializeStringCV","cv","buffers","serializeBoolCV","serializeBufferCV","serializeUIntCV","toTwos","serializeIntCV","serializeStandardPrincipalCV","serializeContractPrincipalCV","serializeResponseCV","serializedValue","serializeListCV","lexicographicOrder","sort","bufA","bufB","nameWithLength","serializeTupleCV","serializeStringAsciiCV","serializeStringUtf8CV","_value","hexString","octet","leftPadHex","leftPadHexToLength","padEnd","cloneDeep","omit","txidFromData","keyHash","redeemScript","pubKeys","pubKey","scriptArray","script","cvToHex","hexToCV","parseReadOnlyResponse","okay","cause","validateStacksAddress","stacksAddress","validateTxId","txid","emptyMessageSignature","createSingleSigSpendingCondition","nonce","fee","signer","keyEncoding","createMultiSigSpendingCondition","fields","signaturesRequired","isSingleSig","condition","clearCondition","cloned","serializeSingleSigSpendingCondition","serializeMultiSigSpendingCondition","deserializeSingleSigSpendingCondition","deserializeMultiSigSpendingCondition","haveUncompressed","serializeSpendingCondition","deserializeSpendingCondition","makeSigHashPreSign","curSigHash","authType","sigHash","makeSigHashPostSign","hashLength","sigHashBuffer","nextSignature","sigHashPreSign","nextSig","nextSigHash","nextVerification","initialSigHash","createStandardAuth","spendingCondition","createSponsoredAuth","sponsorSpendingCondition","Sponsored","intoInitialSighashAuth","auth","newInitialSigHash","verifyOrigin","addrBytes","verifySingleSig","foundPubKey","verifyMultiSig","setFee","getFee","setNonce","setSponsorNonce","setSponsor","sc","serializeAuthorization","deserializeAuthorization","StacksTransaction","postConditions","postConditionMode","anchorMode","chainId","Deny","OnChainOnly","Any","signBegin","tx","verifyBegin","signNextOrigin","signAndAppend","signNextSponsor","appendPubkey","cond","endsWith","serialized","serialize","chainIdBuffer","deserializeTransaction","createSTXPostCondition","createFungiblePostCondition","createNonFungiblePostCondition","cvToString","cvToValue","strictJsonCompat","cvToJSON","getCVTypeString","success","defaultFetchOpts","referrerPolicy","fetchWrapper","fetchOpts","createFetchFn","args","fetchLib","middlewares","argsForCreateFetchFn","fetchParams","middleware","pre","post","StacksNetworks","StacksNetwork","networkConfig","bnsLookupUrl","broadcastEndpoint","transferFeeEstimateEndpoint","transactionFeeEstimateEndpoint","accountEndpoint","contractAbiEndpoint","readOnlyFunctionCallEndpoint","isMainnet","getBroadcastApiUrl","coreApiUrl","getTransferFeeEstimateApiUrl","getTransactionFeeEstimateApiUrl","getAccountApiUrl","getAbiApiUrl","contract","getReadOnlyFunctionCallApiUrl","encodeURIComponent","getInfoUrl","getBlockTimeInfoUrl","getPoxInfoUrl","getRewardsUrl","getRewardsTotalUrl","getRewardHoldersUrl","getStackerInfoUrl","fetchFn","getNameInfo","fullyQualifiedName","nameLookupURL","resp","nameInfo","fromName","networkName","StacksMainnet","StacksTestnet","fromNameOrNetwork","network","ClarityAbiTypeId","isClarityAbiPrimitive","isClarityAbiBuffer","isClarityAbiStringAscii","isClarityAbiStringUtf8","isClarityAbiResponse","isClarityAbiOptional","optional","isClarityAbiTuple","tuple","isClarityAbiList","getTypeUnion","encodeClarityValue","union","getTypeString","t","abiFunctionToString","access","matchType","abiType","abiTupleEntry","validateContractCall","abi","filtered","functions","abiArgs","payloadArg","abiArg","argNum","parseToCV","typeString","TransactionSigner","transaction","originDone","checkOversign","checkOverlap","nextVerify","originSigHash","signOrigin","nextSighash","appendOrigin","signSponsor","getTxInComplete","resume","getNonce","derivedNetwork","estimateTransfer","deriveNetwork","Accept","feeRateResult","txBytes","estimateTransaction","transactionPayload","estimatedLen","transaction_payload","estimated_len","estimations","broadcastTransaction","attachment","rawTx","broadcastRawTransaction","getAbi","catch","makeUnsignedSTXTokenTransfer","txOptions","defaultOptions","sponsored","authorization","numSignatures","lpPostConditions","estimateTransactionByteLength","txFee","addressVersion","senderAddress","txNonce","makeSTXTokenTransfer","senderKey","signerKeys","pk","estimateContractDeploy","makeContractDeploy","unsignedTxOptions","makeUnsignedContractDeploy","addressHashMode","estimateContractFunctionCall","makeUnsignedContractCall","validateWithAbi","makeContractCall","makeStandardSTXPostCondition","makeContractSTXPostCondition","makeStandardFungiblePostCondition","makeContractFungiblePostCondition","makeStandardNonFungiblePostCondition","makeContractNonFungiblePostCondition","callReadOnlyFunction","readOnlyFunctionOptions","sender","responseJson","sponsorTransaction","sponsorOptions","sponsorNonce","sponsorAddressHashmode","sponsorPubKey","sponsorPrivateKey","createSponsorSigner","multiSigSpendingCondition","existingSignatures","totalSignatureLength","STRUCTURED_DATA_PREFIX","hashStructuredData","structuredData","encodeStructuredData","domain","structuredDataHash","domainHash","decodeStructuredDataSignature","encodedMessageBuffer","signStructuredData","StructuredDataSignature"],"sourceRoot":""}