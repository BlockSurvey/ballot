"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BufferReader = exports.isEnum = void 0;
const common_1 = require("@stacks/common");
const smart_buffer_1 = require("smart-buffer");
function createEnumChecker(enumVariable) {
    const enumValues = Object.values(enumVariable).filter(v => typeof v === 'number');
    const enumValueSet = new Set(enumValues);
    return (value) => enumValueSet.has(value);
}
const enumCheckFunctions = new Map();
function isEnum(enumVariable, value) {
    const checker = enumCheckFunctions.get(enumVariable);
    if (checker !== undefined) {
        return checker(value);
    }
    const newChecker = createEnumChecker(enumVariable);
    enumCheckFunctions.set(enumVariable, newChecker);
    return isEnum(enumVariable, value);
}
exports.isEnum = isEnum;
class BufferReader {
    constructor(options) {
        if (common_1.Buffer.isBuffer(options)) {
            this.smartBuffer = new smart_buffer_1.SmartBuffer({ buff: options });
        }
        else {
            this.smartBuffer = new smart_buffer_1.SmartBuffer(options);
        }
    }
    static fromBuffer(buffer) {
        return new BufferReader({ buff: buffer });
    }
    readBuffer(length) {
        return this.smartBuffer.readBuffer(length);
    }
    readUInt32BE(offset) {
        return this.smartBuffer.readUInt32BE(offset);
    }
    readUInt8() {
        return this.smartBuffer.readUInt8();
    }
    readUInt16BE() {
        return this.smartBuffer.readUInt16BE();
    }
    readBigUIntLE(length) {
        const buffer = common_1.Buffer.from(this.smartBuffer.readBuffer(length)).reverse();
        const hex = buffer.toString();
        const num = BigInt(`0x${hex}`);
        return num;
    }
    readBigUIntBE(length) {
        const buffer = this.smartBuffer.readBuffer(length);
        const hex = buffer.toString('hex');
        const num = BigInt(`0x${hex}`);
        return num;
    }
    readBigUInt64BE() {
        return this.smartBuffer.readBigUInt64BE();
    }
    readString(arg, encoding) {
        return this.smartBuffer.readString(arg, encoding);
    }
    get readOffset() {
        return this.smartBuffer.readOffset;
    }
    set readOffset(val) {
        this.smartBuffer.readOffset = val;
    }
    get internalBuffer() {
        return this.smartBuffer.internalBuffer;
    }
    readUInt8Enum(enumVariable, invalidEnumErrorFormatter) {
        const num = this.smartBuffer.readUInt8();
        if (isEnum(enumVariable, num)) {
            return num;
        }
        else {
            throw invalidEnumErrorFormatter(num);
        }
    }
}
exports.BufferReader = BufferReader;
//# sourceMappingURL=bufferReader.js.map