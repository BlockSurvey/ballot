import { sha256 } from '@noble/hashes/sha256';
import { Buffer } from '@stacks/common';
import { ClarityType, serializeCV } from './clarity';
import { StacksMessageType } from './constants';
import { signMessageHashRsv } from './keys';
export const STRUCTURED_DATA_PREFIX = Buffer.from('SIP018', 'ascii');
export function hashStructuredData(structuredData) {
    return Buffer.from(sha256(serializeCV(structuredData)));
}
const hash256BytesLength = 32;
function isDomain(value) {
    if (value.type !== ClarityType.Tuple)
        return false;
    if (!['name', 'version', 'chain-id'].every(key => key in value.data))
        return false;
    if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII))
        return false;
    if (value.data['chain-id'].type !== ClarityType.UInt)
        return false;
    return true;
}
export function encodeStructuredData({ message, domain, }) {
    const structuredDataHash = hashStructuredData(message);
    if (!isDomain(domain)) {
        throw new Error("domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt");
    }
    const domainHash = hashStructuredData(domain);
    return Buffer.concat([STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash]);
}
export function decodeStructuredDataSignature(signature) {
    const encodedMessageBuffer = Buffer.from(signature);
    const domainHash = encodedMessageBuffer.slice(STRUCTURED_DATA_PREFIX.length, STRUCTURED_DATA_PREFIX.length + hash256BytesLength);
    const messageHash = encodedMessageBuffer.slice(STRUCTURED_DATA_PREFIX.length + hash256BytesLength);
    return {
        domainHash,
        messageHash,
    };
}
export function signStructuredData({ message, domain, privateKey, }) {
    const structuredDataHash = Buffer.from(sha256(encodeStructuredData({ message, domain }))).toString('hex');
    const { data } = signMessageHashRsv({
        messageHash: structuredDataHash,
        privateKey,
    });
    return {
        data,
        type: StacksMessageType.StructuredDataSignature,
    };
}
//# sourceMappingURL=structuredDataSignature.js.map