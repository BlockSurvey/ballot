import { extends as _extends, asyncToGenerator as _asyncToGenerator, objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose } from '../_virtual/_rollupPluginBabelHelpers.js';
import _regeneratorRuntime from 'regenerator-runtime';
import { createUnsecuredToken, TokenSigner } from 'jsontokens';
import { getStacksProvider } from '../utils.esm.js';
import { ChainID } from '@stacks/transactions';
import { StacksTestnet } from '@stacks/network';
import { getUserSession, hasAppPrivateKey, getKeys } from '../transactions/index.esm.js';

var _excluded = ["userSession"];

function getStxAddress(options) {
  var _userSession$loadUser, _chainIdToKey;

  var userSession = options.userSession,
      network = options.network;
  if (!userSession || !network) return void 0;
  var stxAddresses = userSession == null ? void 0 : (_userSession$loadUser = userSession.loadUserData().profile) == null ? void 0 : _userSession$loadUser.stxAddress;
  var chainIdToKey = (_chainIdToKey = {}, _chainIdToKey[ChainID.Mainnet] = "mainnet", _chainIdToKey[ChainID.Testnet] = "testnet", _chainIdToKey);
  var address = stxAddresses == null ? void 0 : stxAddresses[chainIdToKey[network.chainId]];
  return address;
}

function signPayload(_x, _x2) {
  return _signPayload.apply(this, arguments);
}

function _signPayload() {
  _signPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(payload, privateKey) {
    var tokenSigner;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            tokenSigner = new TokenSigner("ES256k", privateKey);
            return _context2.abrupt("return", tokenSigner.signAsync(_extends({}, payload)));

          case 2:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _signPayload.apply(this, arguments);
}

function getDefaultSignatureRequestOptions(options) {
  var network = options.network || new StacksTestnet();
  var userSession = getUserSession(options.userSession);

  var defaults = _extends({}, options, {
    network: network,
    userSession: userSession
  });

  return _extends({
    stxAddress: getStxAddress(defaults)
  }, defaults);
}

function openSignaturePopup(_x3) {
  return _openSignaturePopup.apply(this, arguments);
}

function _openSignaturePopup() {
  _openSignaturePopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref) {
    var token, options, provider, signatureResponse;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            token = _ref.token, options = _ref.options;
            provider = getStacksProvider();

            if (provider) {
              _context3.next = 4;
              break;
            }

            throw new Error("Hiro Wallet not installed.");

          case 4:
            _context3.prev = 4;
            _context3.next = 7;
            return provider.signatureRequest(token);

          case 7:
            signatureResponse = _context3.sent;
            options.onFinish == null ? void 0 : options.onFinish(signatureResponse);
            _context3.next = 15;
            break;

          case 11:
            _context3.prev = 11;
            _context3.t0 = _context3["catch"](4);
            console.error("[Connect] Error during signature request", _context3.t0);
            options.onCancel == null ? void 0 : options.onCancel();

          case 15:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[4, 11]]);
  }));
  return _openSignaturePopup.apply(this, arguments);
}

var signMessage = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {
    var userSession, _options, _getKeys, privateKey, publicKey, payload2, payload;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded);

            if (!hasAppPrivateKey(userSession)) {
              _context.next = 5;
              break;
            }

            _getKeys = getKeys(userSession), privateKey = _getKeys.privateKey, publicKey = _getKeys.publicKey;
            payload2 = _extends({}, _options, {
              publicKey: publicKey
            });
            return _context.abrupt("return", signPayload(payload2, privateKey));

          case 5:
            payload = _extends({}, _options);
            return _context.abrupt("return", createUnsecuredToken(payload));

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function signMessage(_x4) {
    return _ref2.apply(this, arguments);
  };
}();

function generateTokenAndOpenPopup(_x5, _x6) {
  return _generateTokenAndOpenPopup.apply(this, arguments);
}

function _generateTokenAndOpenPopup() {
  _generateTokenAndOpenPopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(options, makeTokenFn) {
    var token;
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return makeTokenFn(_extends({}, getDefaultSignatureRequestOptions(options), options));

          case 2:
            token = _context4.sent;
            return _context4.abrupt("return", openSignaturePopup({
              token: token,
              options: options
            }));

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _generateTokenAndOpenPopup.apply(this, arguments);
}

function openSignatureRequestPopup(options) {
  return generateTokenAndOpenPopup(options, signMessage);
}

export { getDefaultSignatureRequestOptions, openSignatureRequestPopup, signMessage };
//# sourceMappingURL=index.esm.js.map
