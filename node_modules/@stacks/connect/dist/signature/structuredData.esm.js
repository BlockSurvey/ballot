import { asyncToGenerator as _asyncToGenerator, extends as _extends, objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose } from '../_virtual/_rollupPluginBabelHelpers.js';
import _regeneratorRuntime from 'regenerator-runtime';
import { createUnsecuredToken, TokenSigner } from 'jsontokens';
import { getStacksProvider } from '../utils.esm.js';
import { serializeCV } from '@stacks/transactions';
import { hasAppPrivateKey, getKeys } from '../transactions/index.esm.js';
import { getDefaultSignatureRequestOptions } from './index.esm.js';

var _excluded = ["userSession"];

function generateTokenAndOpenPopup(_x, _x2) {
  return _generateTokenAndOpenPopup.apply(this, arguments);
}

function _generateTokenAndOpenPopup() {
  _generateTokenAndOpenPopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options, makeTokenFn) {
    var token;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return makeTokenFn(_extends({}, getDefaultSignatureRequestOptions(options), options));

          case 2:
            token = _context.sent;
            return _context.abrupt("return", openStructuredDataSignaturePopup({
              token: token,
              options: options
            }));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _generateTokenAndOpenPopup.apply(this, arguments);
}

function signPayload(_x3, _x4) {
  return _signPayload.apply(this, arguments);
}

function _signPayload() {
  _signPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(payload, privateKey) {
    var tokenSigner;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            tokenSigner = new TokenSigner("ES256k", privateKey);
            return _context2.abrupt("return", tokenSigner.signAsync(_extends({}, payload, {
              message: serializeCV(payload.message).toString("hex"),
              domain: serializeCV(payload.domain).toString("hex")
            })));

          case 2:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _signPayload.apply(this, arguments);
}

function signStructuredMessage(_x5) {
  return _signStructuredMessage.apply(this, arguments);
}

function _signStructuredMessage() {
  _signStructuredMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(options) {
    var userSession, _options, _getKeys, privateKey, publicKey, payload;

    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded);

            if (!hasAppPrivateKey(userSession)) {
              _context3.next = 5;
              break;
            }

            _getKeys = getKeys(userSession), privateKey = _getKeys.privateKey, publicKey = _getKeys.publicKey;
            payload = _extends({}, _options, {
              publicKey: publicKey
            });
            return _context3.abrupt("return", signPayload(payload, privateKey));

          case 5:
            return _context3.abrupt("return", createUnsecuredToken(options));

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _signStructuredMessage.apply(this, arguments);
}

function openStructuredDataSignaturePopup(_x6) {
  return _openStructuredDataSignaturePopup.apply(this, arguments);
}

function _openStructuredDataSignaturePopup() {
  _openStructuredDataSignaturePopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref) {
    var token, options, provider, signatureResponse;
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            token = _ref.token, options = _ref.options;
            provider = getStacksProvider();

            if (provider) {
              _context4.next = 4;
              break;
            }

            throw new Error("Hiro Wallet not installed.");

          case 4:
            _context4.prev = 4;
            _context4.next = 7;
            return provider.structuredDataSignatureRequest(token);

          case 7:
            signatureResponse = _context4.sent;
            options.onFinish == null ? void 0 : options.onFinish(signatureResponse);
            _context4.next = 15;
            break;

          case 11:
            _context4.prev = 11;
            _context4.t0 = _context4["catch"](4);
            console.error("[Connect] Error during signature request", _context4.t0);
            options.onCancel == null ? void 0 : options.onCancel();

          case 15:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[4, 11]]);
  }));
  return _openStructuredDataSignaturePopup.apply(this, arguments);
}

function openStructuredDataSignatureRequestPopup(options) {
  return generateTokenAndOpenPopup(options, signStructuredMessage);
}

export { openStructuredDataSignatureRequestPopup, signStructuredMessage };
//# sourceMappingURL=structuredData.esm.js.map
