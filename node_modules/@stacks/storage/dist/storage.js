"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserAppFileUrl = exports.Storage = void 0;
const auth_1 = require("@stacks/auth");
const common_1 = require("@stacks/common");
const encryption_1 = require("@stacks/encryption");
const network_1 = require("@stacks/network");
const fileContentLoader_1 = require("./fileContentLoader");
const hub_1 = require("./hub");
const SIGNATURE_FILE_SUFFIX = '.sig';
class Storage {
    constructor(options) {
        this.userSession = options.userSession;
    }
    async getFile(path, options) {
        const defaults = {
            decrypt: true,
            verify: false,
            app: (0, common_1.getGlobalObject)('location', { returnEmptyObject: true }).origin,
        };
        const opt = Object.assign({}, defaults, options);
        if (opt.verify && !opt.decrypt) {
            return this.getFileSignedUnencrypted(path, opt);
        }
        const storedContents = await this.getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt);
        if (storedContents === null) {
            return storedContents;
        }
        else if (opt.decrypt && !opt.verify) {
            if (typeof storedContents !== 'string') {
                throw new Error('Expected to get back a string for the cipherText');
            }
            if (typeof opt.decrypt === 'string') {
                const decryptOpt = { privateKey: opt.decrypt };
                return this.userSession.decryptContent(storedContents, decryptOpt);
            }
            else {
                return this.userSession.decryptContent(storedContents);
            }
        }
        else if (opt.decrypt && opt.verify) {
            if (typeof storedContents !== 'string') {
                throw new Error('Expected to get back a string for the cipherText');
            }
            let decryptionKey;
            if (typeof opt.decrypt === 'string') {
                decryptionKey = opt.decrypt;
            }
            return this.handleSignedEncryptedContents(path, storedContents, opt.app, decryptionKey, opt.username, opt.zoneFileLookupURL);
        }
        else if (!opt.verify && !opt.decrypt) {
            return storedContents;
        }
        else {
            throw new Error('Should be unreachable.');
        }
    }
    async getUserAppFileUrl(path, username, appOrigin, zoneFileLookupURL) {
        const profile = await (0, auth_1.lookupProfile)({ username, zoneFileLookupURL });
        let bucketUrl;
        if (profile.hasOwnProperty('apps')) {
            if (profile.apps.hasOwnProperty(appOrigin)) {
                const url = profile.apps[appOrigin];
                const bucket = url.replace(/\/?(\?|#|$)/, '/$1');
                bucketUrl = `${bucket}${path}`;
            }
        }
        return bucketUrl;
    }
    async getGaiaAddress(app, username, zoneFileLookupURL) {
        const opts = normalizeOptions(this.userSession, { app, username, zoneFileLookupURL });
        let fileUrl;
        if (username) {
            fileUrl = await this.getUserAppFileUrl('/', opts.username, opts.app, opts.zoneFileLookupURL);
        }
        else {
            const gaiaHubConfig = await this.getOrSetLocalGaiaHubConnection();
            fileUrl = await (0, hub_1.getFullReadUrl)('/', gaiaHubConfig);
        }
        const matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);
        if (!matches) {
            throw new Error('Failed to parse gaia address');
        }
        return matches[matches.length - 1];
    }
    async getFileUrl(path, options) {
        const opts = normalizeOptions(this.userSession, options);
        let readUrl;
        if (opts.username) {
            readUrl = await this.getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL);
        }
        else {
            const gaiaHubConfig = await this.getOrSetLocalGaiaHubConnection();
            readUrl = await (0, hub_1.getFullReadUrl)(path, gaiaHubConfig);
        }
        if (!readUrl) {
            throw new Error('Missing readURL');
        }
        else {
            return readUrl;
        }
    }
    async getFileContents(path, app, username, zoneFileLookupURL, forceText, fetchFn = (0, network_1.createFetchFn)()) {
        const opts = { app, username, zoneFileLookupURL };
        const readUrl = await this.getFileUrl(path, opts);
        const response = await fetchFn(readUrl);
        if (!response.ok) {
            throw await (0, hub_1.getBlockstackErrorFromResponse)(response, `getFile ${path} failed.`, null);
        }
        let contentType = response.headers.get('Content-Type');
        if (typeof contentType === 'string') {
            contentType = contentType.toLowerCase();
        }
        const etag = response.headers.get('ETag');
        if (etag) {
            const sessionData = this.userSession.store.getSessionData();
            sessionData.etags[path] = etag;
            this.userSession.store.setSessionData(sessionData);
        }
        if (forceText ||
            contentType === null ||
            contentType.startsWith('text') ||
            contentType.startsWith('application/json')) {
            return response.text();
        }
        else {
            return response.arrayBuffer();
        }
    }
    async getFileSignedUnencrypted(path, opt) {
        const sigPath = `${path}${SIGNATURE_FILE_SUFFIX}`;
        try {
            const [fileContents, signatureContents, gaiaAddress] = await Promise.all([
                this.getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, false),
                this.getFileContents(sigPath, opt.app, opt.username, opt.zoneFileLookupURL, true),
                this.getGaiaAddress(opt.app, opt.username, opt.zoneFileLookupURL),
            ]);
            if (!fileContents) {
                return fileContents;
            }
            if (!gaiaAddress) {
                throw new common_1.SignatureVerificationError(`Failed to get gaia address for verification of: ${path}`);
            }
            if (!signatureContents || typeof signatureContents !== 'string') {
                throw new common_1.SignatureVerificationError('Failed to obtain signature for file: ' +
                    `${path} -- looked in ${path}${SIGNATURE_FILE_SUFFIX}`);
            }
            let signature;
            let publicKey;
            try {
                const sigObject = JSON.parse(signatureContents);
                signature = sigObject.signature;
                publicKey = sigObject.publicKey;
            }
            catch (err) {
                if (err instanceof SyntaxError) {
                    throw new Error('Failed to parse signature content JSON ' +
                        `(path: ${path}${SIGNATURE_FILE_SUFFIX})` +
                        ' The content may be corrupted.');
                }
                else {
                    throw err;
                }
            }
            const signerAddress = (0, encryption_1.publicKeyToAddress)(publicKey);
            if (gaiaAddress !== signerAddress) {
                throw new common_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't` +
                    ` match gaia address (${gaiaAddress})`);
            }
            else if (!(0, encryption_1.verifyECDSA)(fileContents, publicKey, signature)) {
                throw new common_1.SignatureVerificationError('Contents do not match ECDSA signature: ' +
                    `path: ${path}, signature: ${path}${SIGNATURE_FILE_SUFFIX}`);
            }
            else {
                return fileContents;
            }
        }
        catch (err) {
            if (err instanceof common_1.DoesNotExist && err.message.indexOf(sigPath) >= 0) {
                throw new common_1.SignatureVerificationError('Failed to obtain signature for file: ' +
                    `${path} -- looked in ${path}${SIGNATURE_FILE_SUFFIX}`);
            }
            else {
                throw err;
            }
        }
    }
    async handleSignedEncryptedContents(path, storedContents, app, privateKey, username, zoneFileLookupURL) {
        const appPrivateKey = privateKey || this.userSession.loadUserData().appPrivateKey;
        const appPublicKey = (0, encryption_1.getPublicKeyFromPrivate)(appPrivateKey);
        let address;
        if (username) {
            address = await this.getGaiaAddress(app, username, zoneFileLookupURL);
        }
        else {
            address = (0, encryption_1.publicKeyToAddress)(appPublicKey);
        }
        if (!address) {
            throw new common_1.SignatureVerificationError(`Failed to get gaia address for verification of: ${path}`);
        }
        let sigObject;
        try {
            sigObject = JSON.parse(storedContents);
        }
        catch (err) {
            if (err instanceof SyntaxError) {
                throw new Error('Failed to parse encrypted, signed content JSON. The content may not ' +
                    'be encrypted. If using getFile, try passing' +
                    ' { verify: false, decrypt: false }.');
            }
            else {
                throw err;
            }
        }
        const signature = sigObject.signature;
        const signerPublicKey = sigObject.publicKey;
        const cipherText = sigObject.cipherText;
        const signerAddress = (0, encryption_1.publicKeyToAddress)(signerPublicKey);
        if (!signerPublicKey || !cipherText || !signature) {
            throw new common_1.SignatureVerificationError('Failed to get signature verification data from file:' + ` ${path}`);
        }
        else if (signerAddress !== address) {
            throw new common_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't` + ` match gaia address (${address})`);
        }
        else if (!(0, encryption_1.verifyECDSA)(cipherText, signerPublicKey, signature)) {
            throw new common_1.SignatureVerificationError('Contents do not match ECDSA signature in file:' + ` ${path}`);
        }
        else if (typeof privateKey === 'string') {
            const decryptOpt = { privateKey };
            return this.userSession.decryptContent(cipherText, decryptOpt);
        }
        else {
            return this.userSession.decryptContent(cipherText);
        }
    }
    async putFile(path, content, options) {
        var _a, _b;
        const defaults = {
            encrypt: true,
            sign: false,
            cipherTextEncoding: 'hex',
            dangerouslyIgnoreEtag: false,
        };
        const opt = Object.assign({}, defaults, options);
        const gaiaHubConfig = await this.getOrSetLocalGaiaHubConnection();
        const maxUploadBytes = (0, common_1.megabytesToBytes)(gaiaHubConfig.max_file_upload_size_megabytes);
        const hasMaxUpload = maxUploadBytes > 0;
        const contentLoader = new fileContentLoader_1.FileContentLoader(content, opt.contentType);
        let contentType = contentLoader.contentType;
        if (!opt.encrypt && hasMaxUpload && contentLoader.contentByteLength > maxUploadBytes) {
            const sizeErrMsg = `The max file upload size for this hub is ${maxUploadBytes} bytes, the given content is ${contentLoader.contentByteLength} bytes`;
            const sizeErr = new common_1.PayloadTooLargeError(sizeErrMsg, null, maxUploadBytes);
            console.error(sizeErr);
            throw sizeErr;
        }
        if (opt.encrypt && hasMaxUpload) {
            const encryptedSize = (0, encryption_1.eciesGetJsonStringLength)({
                contentLength: contentLoader.contentByteLength,
                wasString: contentLoader.wasString,
                sign: !!opt.sign,
                cipherTextEncoding: opt.cipherTextEncoding,
            });
            if (encryptedSize > maxUploadBytes) {
                const sizeErrMsg = `The max file upload size for this hub is ${maxUploadBytes} bytes, the given content is ${encryptedSize} bytes after encryption`;
                const sizeErr = new common_1.PayloadTooLargeError(sizeErrMsg, null, maxUploadBytes);
                console.error(sizeErr);
                throw sizeErr;
            }
        }
        let etag;
        let newFile = true;
        const sessionData = this.userSession.store.getSessionData();
        if (!opt.dangerouslyIgnoreEtag) {
            if ((_a = sessionData.etags) === null || _a === void 0 ? void 0 : _a[path]) {
                newFile = false;
                etag = (_b = sessionData.etags) === null || _b === void 0 ? void 0 : _b[path];
            }
        }
        let uploadFn;
        if (!opt.encrypt && opt.sign) {
            const contentData = await contentLoader.load();
            let privateKey;
            if (typeof opt.sign === 'string') {
                privateKey = opt.sign;
            }
            else {
                privateKey = this.userSession.loadUserData().appPrivateKey;
            }
            const signatureObject = (0, encryption_1.signECDSA)(privateKey, contentData);
            const signatureContent = JSON.stringify(signatureObject);
            uploadFn = async (hubConfig) => {
                const writeResponse = (await Promise.all([
                    (0, hub_1.uploadToGaiaHub)(path, contentData, hubConfig, contentType, newFile, etag, opt.dangerouslyIgnoreEtag),
                    (0, hub_1.uploadToGaiaHub)(`${path}${SIGNATURE_FILE_SUFFIX}`, signatureContent, hubConfig, 'application/json'),
                ]))[0];
                if (!opt.dangerouslyIgnoreEtag && writeResponse.etag) {
                    sessionData.etags[path] = writeResponse.etag;
                    this.userSession.store.setSessionData(sessionData);
                }
                return writeResponse.publicURL;
            };
        }
        else {
            let contentForUpload;
            if (!opt.encrypt && !opt.sign) {
                contentForUpload = contentLoader.content;
            }
            else {
                let publicKey;
                if (typeof opt.encrypt === 'string') {
                    publicKey = opt.encrypt;
                }
                else if (typeof opt.sign === 'string') {
                    publicKey = (0, encryption_1.getPublicKeyFromPrivate)(opt.sign);
                }
                else {
                    publicKey = (0, encryption_1.getPublicKeyFromPrivate)(this.userSession.loadUserData().appPrivateKey);
                }
                const contentData = await contentLoader.load();
                contentForUpload = await this.userSession.encryptContent(contentData, {
                    publicKey,
                    wasString: contentLoader.wasString,
                    cipherTextEncoding: opt.cipherTextEncoding,
                    sign: opt.sign,
                });
                contentType = 'application/json';
            }
            uploadFn = async (hubConfig) => {
                const writeResponse = await (0, hub_1.uploadToGaiaHub)(path, contentForUpload, hubConfig, contentType, newFile, etag, opt.dangerouslyIgnoreEtag);
                if (writeResponse.etag) {
                    sessionData.etags[path] = writeResponse.etag;
                    this.userSession.store.setSessionData(sessionData);
                }
                return writeResponse.publicURL;
            };
        }
        try {
            return await uploadFn(gaiaHubConfig);
        }
        catch (error) {
            if (isRecoverableGaiaError(error)) {
                console.error(error);
                console.error('Possible recoverable error during Gaia upload, retrying...');
                const freshHubConfig = await this.setLocalGaiaHubConnection();
                return await uploadFn(freshHubConfig);
            }
            else {
                throw error;
            }
        }
    }
    async deleteFile(path, options) {
        const gaiaHubConfig = await this.getOrSetLocalGaiaHubConnection();
        const opts = Object.assign({}, options);
        if (opts.wasSigned) {
            try {
                await (0, hub_1.deleteFromGaiaHub)(path, gaiaHubConfig);
                await (0, hub_1.deleteFromGaiaHub)(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);
                const sessionData = this.userSession.store.getSessionData();
                delete sessionData.etags[path];
                this.userSession.store.setSessionData(sessionData);
            }
            catch (error) {
                const freshHubConfig = await this.setLocalGaiaHubConnection();
                await (0, hub_1.deleteFromGaiaHub)(path, freshHubConfig);
                await (0, hub_1.deleteFromGaiaHub)(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);
                const sessionData = this.userSession.store.getSessionData();
                delete sessionData.etags[path];
                this.userSession.store.setSessionData(sessionData);
            }
        }
        else {
            try {
                await (0, hub_1.deleteFromGaiaHub)(path, gaiaHubConfig);
                const sessionData = this.userSession.store.getSessionData();
                delete sessionData.etags[path];
                this.userSession.store.setSessionData(sessionData);
            }
            catch (error) {
                const freshHubConfig = await this.setLocalGaiaHubConnection();
                await (0, hub_1.deleteFromGaiaHub)(path, freshHubConfig);
                const sessionData = this.userSession.store.getSessionData();
                delete sessionData.etags[path];
                this.userSession.store.setSessionData(sessionData);
            }
        }
    }
    getAppBucketUrl(gaiaHubUrl, appPrivateKey) {
        return (0, hub_1.getBucketUrl)(gaiaHubUrl, appPrivateKey);
    }
    async listFilesLoop(hubConfig, page, callCount, fileCount, callback, fetchFn = (0, network_1.createFetchFn)()) {
        if (callCount > 65536) {
            throw new Error('Too many entries to list');
        }
        hubConfig = hubConfig || (await this.getOrSetLocalGaiaHubConnection());
        let response;
        try {
            const pageRequest = JSON.stringify({ page });
            const fetchOptions = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': `${pageRequest.length}`,
                    Authorization: `bearer ${hubConfig.token}`,
                },
                body: pageRequest,
            };
            response = await fetchFn(`${hubConfig.server}/list-files/${hubConfig.address}`, fetchOptions);
            if (!response.ok) {
                throw await (0, hub_1.getBlockstackErrorFromResponse)(response, 'ListFiles failed.', hubConfig);
            }
        }
        catch (error) {
            if (callCount === 0) {
                const freshHubConfig = await this.setLocalGaiaHubConnection();
                return this.listFilesLoop(freshHubConfig, page, callCount + 1, 0, callback);
            }
            throw error;
        }
        const responseText = await response.text();
        const responseJSON = JSON.parse(responseText);
        const entries = responseJSON.entries;
        const nextPage = responseJSON.page;
        if (entries === null || entries === undefined) {
            throw new Error('Bad listFiles response: no entries');
        }
        let entriesLength = 0;
        for (let i = 0; i < entries.length; i++) {
            if (entries[i] !== null) {
                entriesLength++;
                const rc = callback(entries[i]);
                if (!rc) {
                    return fileCount + i;
                }
            }
        }
        if (nextPage && entries.length > 0) {
            return this.listFilesLoop(hubConfig, nextPage, callCount + 1, fileCount + entriesLength, callback);
        }
        else {
            return fileCount + entriesLength;
        }
    }
    listFiles(callback) {
        return this.listFilesLoop(null, null, 0, 0, callback);
    }
    async getOrSetLocalGaiaHubConnection() {
        const sessionData = this.userSession.store.getSessionData();
        const userData = sessionData.userData;
        if (!userData) {
            throw new common_1.InvalidStateError('Missing userData');
        }
        const hubConfig = userData.gaiaHubConfig;
        if (hubConfig) {
            return Promise.resolve(hubConfig);
        }
        return this.setLocalGaiaHubConnection();
    }
    async setLocalGaiaHubConnection() {
        const userData = this.userSession.loadUserData();
        if (!userData) {
            throw new common_1.InvalidStateError('Missing userData');
        }
        if (!userData.hubUrl) {
            userData.hubUrl = common_1.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;
        }
        const gaiaConfig = await (0, hub_1.connectToGaiaHub)(userData.hubUrl, userData.appPrivateKey, userData.gaiaAssociationToken);
        userData.gaiaHubConfig = gaiaConfig;
        const sessionData = this.userSession.store.getSessionData();
        sessionData.userData.gaiaHubConfig = gaiaConfig;
        this.userSession.store.setSessionData(sessionData);
        return gaiaConfig;
    }
}
exports.Storage = Storage;
function getUserAppFileUrl(options) {
    return new Storage({}).getUserAppFileUrl(options.path, options.username, options.appOrigin, options.zoneFileLookupURL);
}
exports.getUserAppFileUrl = getUserAppFileUrl;
function normalizeOptions(userSession, options) {
    var _a;
    const opts = Object.assign({}, options);
    if (opts.username) {
        if (!opts.app) {
            if (!userSession.appConfig) {
                throw new common_1.InvalidStateError('Missing AppConfig');
            }
            opts.app = userSession.appConfig.appDomain;
        }
        if (!opts.zoneFileLookupURL) {
            if (!userSession.appConfig) {
                throw new common_1.InvalidStateError('Missing AppConfig');
            }
            if (!userSession.store) {
                throw new common_1.InvalidStateError('Missing store UserSession');
            }
            const sessionData = userSession.store.getSessionData();
            const configuredCoreNode = ((_a = sessionData.userData) === null || _a === void 0 ? void 0 : _a.coreNode) || userSession.appConfig.coreNode;
            if (configuredCoreNode) {
                opts.zoneFileLookupURL = `${configuredCoreNode}${auth_1.NAME_LOOKUP_PATH}`;
            }
        }
    }
    return opts;
}
function isRecoverableGaiaError(error) {
    if (!error || !error.hubError || !error.hubError.statusCode) {
        return false;
    }
    const statusCode = error.hubError.statusCode;
    if (statusCode === 401) {
        return true;
    }
    if (statusCode === 409) {
        return true;
    }
    if (statusCode >= 500 && statusCode <= 599) {
        return true;
    }
    return false;
}
//# sourceMappingURL=storage.js.map