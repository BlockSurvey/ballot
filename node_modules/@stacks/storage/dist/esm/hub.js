import { BadPathError, Buffer, ConflictError, DoesNotExist, Logger, megabytesToBytes, NotEnoughProofError, PayloadTooLargeError, PreconditionFailedError, ValidationError, } from '@stacks/common';
import { compressPrivateKey, ecSign, getPublicKeyFromPrivate, hashSha256Sync, publicKeyToAddress, randomBytes, Signature, } from '@stacks/encryption';
import { createFetchFn } from '@stacks/network';
import { TokenSigner } from 'jsontokens';
export const BLOCKSTACK_GAIA_HUB_LABEL = 'blockstack-gaia-hub-config';
export async function uploadToGaiaHub(filename, contents, hubConfig, contentType = 'application/octet-stream', newFile = true, etag, dangerouslyIgnoreEtag, fetchFn = createFetchFn()) {
    Logger.debug(`uploadToGaiaHub: uploading ${filename} to ${hubConfig.server}`);
    const headers = {
        'Content-Type': contentType,
        Authorization: `bearer ${hubConfig.token}`,
    };
    if (!dangerouslyIgnoreEtag) {
        if (newFile) {
            headers['If-None-Match'] = '*';
        }
        else if (etag) {
            headers['If-Match'] = etag;
        }
    }
    const response = await fetchFn(`${hubConfig.server}/store/${hubConfig.address}/${filename}`, {
        method: 'POST',
        headers,
        body: contents,
    });
    if (!response.ok) {
        throw await getBlockstackErrorFromResponse(response, 'Error when uploading to Gaia hub.', hubConfig);
    }
    const responseText = await response.text();
    return JSON.parse(responseText);
}
export async function deleteFromGaiaHub(filename, hubConfig, fetchFn = createFetchFn()) {
    Logger.debug(`deleteFromGaiaHub: deleting ${filename} from ${hubConfig.server}`);
    const response = await fetchFn(`${hubConfig.server}/delete/${hubConfig.address}/${filename}`, {
        method: 'DELETE',
        headers: {
            Authorization: `bearer ${hubConfig.token}`,
        },
    });
    if (!response.ok) {
        throw await getBlockstackErrorFromResponse(response, 'Error deleting file from Gaia hub.', hubConfig);
    }
}
export function getFullReadUrl(filename, hubConfig) {
    return Promise.resolve(`${hubConfig.url_prefix}${hubConfig.address}/${filename}`);
}
function makeLegacyAuthToken(challengeText, signerKeyHex) {
    let parsedChallenge;
    try {
        parsedChallenge = JSON.parse(challengeText);
    }
    catch (err) {
        throw new Error('Failed in parsing legacy challenge text from the gaia hub.');
    }
    if (parsedChallenge[0] === 'gaiahub' && parsedChallenge[3] === 'blockstack_storage_please_sign') {
        const digest = hashSha256Sync(Buffer.from(challengeText));
        const signatureBuffer = ecSign(digest, compressPrivateKey(signerKeyHex));
        const signature = Signature.fromCompact(signatureBuffer.toString('hex')).toDERHex();
        const publickey = getPublicKeyFromPrivate(signerKeyHex);
        const token = Buffer.from(JSON.stringify({ publickey, signature })).toString('base64');
        return token;
    }
    else {
        throw new Error('Failed to connect to legacy gaia hub. If you operate this hub, please update.');
    }
}
function makeV1GaiaAuthToken(hubInfo, signerKeyHex, hubUrl, associationToken) {
    const challengeText = hubInfo.challenge_text;
    const handlesV1Auth = hubInfo.latest_auth_version && parseInt(hubInfo.latest_auth_version.slice(1), 10) >= 1;
    const iss = getPublicKeyFromPrivate(signerKeyHex);
    if (!handlesV1Auth) {
        return makeLegacyAuthToken(challengeText, signerKeyHex);
    }
    const salt = randomBytes(16).toString('hex');
    const payload = {
        gaiaChallenge: challengeText,
        hubUrl,
        iss,
        salt,
        associationToken: associationToken,
    };
    const token = new TokenSigner('ES256K', signerKeyHex).sign(payload);
    return `v1:${token}`;
}
export async function connectToGaiaHub(gaiaHubUrl, challengeSignerHex, associationToken, fetchFn = createFetchFn()) {
    Logger.debug(`connectToGaiaHub: ${gaiaHubUrl}/hub_info`);
    const response = await fetchFn(`${gaiaHubUrl}/hub_info`);
    const hubInfo = await response.json();
    const readURL = hubInfo.read_url_prefix;
    const token = makeV1GaiaAuthToken(hubInfo, challengeSignerHex, gaiaHubUrl, associationToken);
    const address = publicKeyToAddress(getPublicKeyFromPrivate(challengeSignerHex));
    return {
        url_prefix: readURL,
        max_file_upload_size_megabytes: hubInfo.max_file_upload_size_megabytes,
        address,
        token,
        server: gaiaHubUrl,
    };
}
export async function getBucketUrl(gaiaHubUrl, appPrivateKey, fetchFn = createFetchFn()) {
    const response = await fetchFn(`${gaiaHubUrl}/hub_info`);
    const responseText = await response.text();
    const responseJSON = JSON.parse(responseText);
    const readURL = responseJSON.read_url_prefix;
    const address = publicKeyToAddress(getPublicKeyFromPrivate(appPrivateKey));
    const bucketUrl = `${readURL}${address}/`;
    return bucketUrl;
}
async function getGaiaErrorResponse(response) {
    let responseMsg = '';
    let responseJson;
    try {
        responseMsg = await response.text();
        try {
            responseJson = JSON.parse(responseMsg);
        }
        catch (error) {
        }
    }
    catch (error) {
        Logger.debug(`Error getting bad http response text: ${error}`);
    }
    const status = response.status;
    const statusText = response.statusText;
    const body = responseJson || responseMsg;
    return { status, statusText, body };
}
export async function getBlockstackErrorFromResponse(response, errorMsg, hubConfig) {
    if (response.ok) {
        throw new Error('Cannot get a BlockstackError from a valid response.');
    }
    const gaiaResponse = await getGaiaErrorResponse(response);
    if (gaiaResponse.status === 401) {
        return new ValidationError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 402) {
        return new NotEnoughProofError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 403) {
        return new BadPathError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 404) {
        throw new DoesNotExist(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 409) {
        return new ConflictError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 412) {
        return new PreconditionFailedError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 413) {
        const maxBytes = hubConfig && hubConfig.max_file_upload_size_megabytes
            ? megabytesToBytes(hubConfig.max_file_upload_size_megabytes)
            : 0;
        return new PayloadTooLargeError(errorMsg, gaiaResponse, maxBytes);
    }
    else {
        return new Error(errorMsg);
    }
}
//# sourceMappingURL=hub.js.map