"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBlockstackErrorFromResponse = exports.getBucketUrl = exports.connectToGaiaHub = exports.getFullReadUrl = exports.deleteFromGaiaHub = exports.uploadToGaiaHub = exports.BLOCKSTACK_GAIA_HUB_LABEL = void 0;
const common_1 = require("@stacks/common");
const encryption_1 = require("@stacks/encryption");
const network_1 = require("@stacks/network");
const jsontokens_1 = require("jsontokens");
exports.BLOCKSTACK_GAIA_HUB_LABEL = 'blockstack-gaia-hub-config';
async function uploadToGaiaHub(filename, contents, hubConfig, contentType = 'application/octet-stream', newFile = true, etag, dangerouslyIgnoreEtag, fetchFn = (0, network_1.createFetchFn)()) {
    common_1.Logger.debug(`uploadToGaiaHub: uploading ${filename} to ${hubConfig.server}`);
    const headers = {
        'Content-Type': contentType,
        Authorization: `bearer ${hubConfig.token}`,
    };
    if (!dangerouslyIgnoreEtag) {
        if (newFile) {
            headers['If-None-Match'] = '*';
        }
        else if (etag) {
            headers['If-Match'] = etag;
        }
    }
    const response = await fetchFn(`${hubConfig.server}/store/${hubConfig.address}/${filename}`, {
        method: 'POST',
        headers,
        body: contents,
    });
    if (!response.ok) {
        throw await getBlockstackErrorFromResponse(response, 'Error when uploading to Gaia hub.', hubConfig);
    }
    const responseText = await response.text();
    return JSON.parse(responseText);
}
exports.uploadToGaiaHub = uploadToGaiaHub;
async function deleteFromGaiaHub(filename, hubConfig, fetchFn = (0, network_1.createFetchFn)()) {
    common_1.Logger.debug(`deleteFromGaiaHub: deleting ${filename} from ${hubConfig.server}`);
    const response = await fetchFn(`${hubConfig.server}/delete/${hubConfig.address}/${filename}`, {
        method: 'DELETE',
        headers: {
            Authorization: `bearer ${hubConfig.token}`,
        },
    });
    if (!response.ok) {
        throw await getBlockstackErrorFromResponse(response, 'Error deleting file from Gaia hub.', hubConfig);
    }
}
exports.deleteFromGaiaHub = deleteFromGaiaHub;
function getFullReadUrl(filename, hubConfig) {
    return Promise.resolve(`${hubConfig.url_prefix}${hubConfig.address}/${filename}`);
}
exports.getFullReadUrl = getFullReadUrl;
function makeLegacyAuthToken(challengeText, signerKeyHex) {
    let parsedChallenge;
    try {
        parsedChallenge = JSON.parse(challengeText);
    }
    catch (err) {
        throw new Error('Failed in parsing legacy challenge text from the gaia hub.');
    }
    if (parsedChallenge[0] === 'gaiahub' && parsedChallenge[3] === 'blockstack_storage_please_sign') {
        const digest = (0, encryption_1.hashSha256Sync)(common_1.Buffer.from(challengeText));
        const signatureBuffer = (0, encryption_1.ecSign)(digest, (0, encryption_1.compressPrivateKey)(signerKeyHex));
        const signature = encryption_1.Signature.fromCompact(signatureBuffer.toString('hex')).toDERHex();
        const publickey = (0, encryption_1.getPublicKeyFromPrivate)(signerKeyHex);
        const token = common_1.Buffer.from(JSON.stringify({ publickey, signature })).toString('base64');
        return token;
    }
    else {
        throw new Error('Failed to connect to legacy gaia hub. If you operate this hub, please update.');
    }
}
function makeV1GaiaAuthToken(hubInfo, signerKeyHex, hubUrl, associationToken) {
    const challengeText = hubInfo.challenge_text;
    const handlesV1Auth = hubInfo.latest_auth_version && parseInt(hubInfo.latest_auth_version.slice(1), 10) >= 1;
    const iss = (0, encryption_1.getPublicKeyFromPrivate)(signerKeyHex);
    if (!handlesV1Auth) {
        return makeLegacyAuthToken(challengeText, signerKeyHex);
    }
    const salt = (0, encryption_1.randomBytes)(16).toString('hex');
    const payload = {
        gaiaChallenge: challengeText,
        hubUrl,
        iss,
        salt,
        associationToken: associationToken,
    };
    const token = new jsontokens_1.TokenSigner('ES256K', signerKeyHex).sign(payload);
    return `v1:${token}`;
}
async function connectToGaiaHub(gaiaHubUrl, challengeSignerHex, associationToken, fetchFn = (0, network_1.createFetchFn)()) {
    common_1.Logger.debug(`connectToGaiaHub: ${gaiaHubUrl}/hub_info`);
    const response = await fetchFn(`${gaiaHubUrl}/hub_info`);
    const hubInfo = await response.json();
    const readURL = hubInfo.read_url_prefix;
    const token = makeV1GaiaAuthToken(hubInfo, challengeSignerHex, gaiaHubUrl, associationToken);
    const address = (0, encryption_1.publicKeyToAddress)((0, encryption_1.getPublicKeyFromPrivate)(challengeSignerHex));
    return {
        url_prefix: readURL,
        max_file_upload_size_megabytes: hubInfo.max_file_upload_size_megabytes,
        address,
        token,
        server: gaiaHubUrl,
    };
}
exports.connectToGaiaHub = connectToGaiaHub;
async function getBucketUrl(gaiaHubUrl, appPrivateKey, fetchFn = (0, network_1.createFetchFn)()) {
    const response = await fetchFn(`${gaiaHubUrl}/hub_info`);
    const responseText = await response.text();
    const responseJSON = JSON.parse(responseText);
    const readURL = responseJSON.read_url_prefix;
    const address = (0, encryption_1.publicKeyToAddress)((0, encryption_1.getPublicKeyFromPrivate)(appPrivateKey));
    const bucketUrl = `${readURL}${address}/`;
    return bucketUrl;
}
exports.getBucketUrl = getBucketUrl;
async function getGaiaErrorResponse(response) {
    let responseMsg = '';
    let responseJson;
    try {
        responseMsg = await response.text();
        try {
            responseJson = JSON.parse(responseMsg);
        }
        catch (error) {
        }
    }
    catch (error) {
        common_1.Logger.debug(`Error getting bad http response text: ${error}`);
    }
    const status = response.status;
    const statusText = response.statusText;
    const body = responseJson || responseMsg;
    return { status, statusText, body };
}
async function getBlockstackErrorFromResponse(response, errorMsg, hubConfig) {
    if (response.ok) {
        throw new Error('Cannot get a BlockstackError from a valid response.');
    }
    const gaiaResponse = await getGaiaErrorResponse(response);
    if (gaiaResponse.status === 401) {
        return new common_1.ValidationError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 402) {
        return new common_1.NotEnoughProofError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 403) {
        return new common_1.BadPathError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 404) {
        throw new common_1.DoesNotExist(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 409) {
        return new common_1.ConflictError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 412) {
        return new common_1.PreconditionFailedError(errorMsg, gaiaResponse);
    }
    else if (gaiaResponse.status === 413) {
        const maxBytes = hubConfig && hubConfig.max_file_upload_size_megabytes
            ? (0, common_1.megabytesToBytes)(hubConfig.max_file_upload_size_megabytes)
            : 0;
        return new common_1.PayloadTooLargeError(errorMsg, gaiaResponse, maxBytes);
    }
    else {
        return new Error(errorMsg);
    }
}
exports.getBlockstackErrorFromResponse = getBlockstackErrorFromResponse;
//# sourceMappingURL=hub.js.map