"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileContentLoader = void 0;
const common_1 = require("@stacks/common");
class FileContentLoader {
    constructor(content, contentType) {
        this.wasString = typeof content === 'string';
        this.content = FileContentLoader.normalizeContentDataType(content, contentType);
        this.contentType = contentType || this.detectContentType();
        this.contentByteLength = this.detectContentLength();
    }
    static normalizeContentDataType(content, contentType) {
        try {
            if (typeof content === 'string') {
                const charset = (contentType || '').toLowerCase().replace('-', '');
                if (charset.includes('charset') &&
                    !charset.includes('charset=utf8') &&
                    !charset.includes('charset=ascii')) {
                    throw new Error(`Unable to determine byte length with charset: ${contentType}`);
                }
                if (typeof TextEncoder !== 'undefined') {
                    const encodedString = new TextEncoder().encode(content);
                    return common_1.Buffer.from(encodedString.buffer);
                }
                return common_1.Buffer.from(content);
            }
            else if (common_1.Buffer.isBuffer(content)) {
                return content;
            }
            else if (ArrayBuffer.isView(content)) {
                return common_1.Buffer.from(content.buffer, content.byteOffset, content.byteLength);
            }
            else if (typeof Blob !== 'undefined' && content instanceof Blob) {
                return content;
            }
            else if (typeof ArrayBuffer !== 'undefined' && content instanceof ArrayBuffer) {
                return common_1.Buffer.from(content);
            }
            else if (Array.isArray(content)) {
                if (content.length > 0 &&
                    (!Number.isInteger(content[0]) || content[0] < 0 || content[0] > 255)) {
                    throw new Error(`Unexpected array values provided as file data: value "${content[0]}" at index 0 is not an octet number. ${this.supportedTypesMsg}`);
                }
                return common_1.Buffer.from(content);
            }
            else {
                const typeName = Object.prototype.toString.call(content);
                throw new Error(`Unexpected type provided as file data: ${typeName}. ${this.supportedTypesMsg}`);
            }
        }
        catch (error) {
            console.error(error);
            throw new Error(`Error processing data: ${error}`);
        }
    }
    detectContentType() {
        if (this.wasString) {
            return 'text/plain; charset=utf-8';
        }
        else if (typeof Blob !== 'undefined' && this.content instanceof Blob && this.content.type) {
            return this.content.type;
        }
        else {
            return 'application/octet-stream';
        }
    }
    detectContentLength() {
        if (ArrayBuffer.isView(this.content) || common_1.Buffer.isBuffer(this.content)) {
            return this.content.byteLength;
        }
        else if (typeof Blob !== 'undefined' && this.content instanceof Blob) {
            return this.content.size;
        }
        const typeName = Object.prototype.toString.call(this.content);
        const error = new Error(`Unexpected type "${typeName}" while detecting content length`);
        console.error(error);
        throw error;
    }
    async loadContent() {
        try {
            if (common_1.Buffer.isBuffer(this.content)) {
                return this.content;
            }
            else if (ArrayBuffer.isView(this.content)) {
                return common_1.Buffer.from(this.content.buffer, this.content.byteOffset, this.content.byteLength);
            }
            else if (typeof Blob !== 'undefined' && this.content instanceof Blob) {
                const reader = new FileReader();
                const readPromise = new Promise((resolve, reject) => {
                    reader.onerror = err => {
                        reject(err);
                    };
                    reader.onload = () => {
                        const arrayBuffer = reader.result;
                        resolve(common_1.Buffer.from(arrayBuffer));
                    };
                    reader.readAsArrayBuffer(this.content);
                });
                const result = await readPromise;
                return result;
            }
            else {
                const typeName = Object.prototype.toString.call(this.content);
                throw new Error(`Unexpected type ${typeName}`);
            }
        }
        catch (error) {
            console.error(error);
            const loadContentError = new Error(`Error loading content: ${error}`);
            console.error(loadContentError);
            throw loadContentError;
        }
    }
    load() {
        if (this.loadedData === undefined) {
            this.loadedData = this.loadContent();
        }
        return this.loadedData;
    }
}
exports.FileContentLoader = FileContentLoader;
FileContentLoader.supportedTypesMsg = 'Supported types are: `string` (to be UTF8 encoded), ' +
    '`Buffer`, `Blob`, `File`, `ArrayBuffer`, `UInt8Array` or any other typed array buffer. ';
//# sourceMappingURL=fileContentLoader.js.map