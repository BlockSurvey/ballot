{"version":3,"file":"zone-file.cjs.production.min.js","sources":["../src/makeZoneFile.ts","../src/zoneFileTemplate.ts","../src/parseZoneFile.ts","../src/zoneFile.ts"],"sourcesContent":["import {\n  AType,\n  CNAMEType,\n  MXType,\n  NSType,\n  SoaType,\n  SPFType,\n  SRVType,\n  TXTType,\n  URIType,\n  ZoneFileObject,\n} from './zoneFile';\n\nimport { getZoneFileTemplate } from './zoneFileTemplate';\n\nexport function makeZoneFile(jsonZoneFile: ZoneFileObject, template: string = getZoneFileTemplate()) {\n  template = processOrigin(jsonZoneFile['$origin'], template);\n  template = processTTL(jsonZoneFile['$ttl'], template);\n  template = processSOA(jsonZoneFile['soa'], template);\n  template = processNS(jsonZoneFile['ns'], template);\n  template = processA(jsonZoneFile['a'], template);\n  template = processAAAA(jsonZoneFile['aaaa'], template);\n  template = processCNAME(jsonZoneFile['cname'], template);\n  template = processMX(jsonZoneFile['mx'], template);\n  template = processPTR(jsonZoneFile['ptr'], template);\n  template = processTXT(jsonZoneFile['txt'], template);\n  template = processSRV(jsonZoneFile['srv'], template);\n  template = processSPF(jsonZoneFile['spf'], template);\n  template = processURI(jsonZoneFile['uri'], template);\n  template = processValues(jsonZoneFile, template);\n  return template.replace(/\\n{2,}/gim, '\\n\\n');\n}\n\nfunction processOrigin(data: string | undefined, template: string) {\n  let ret = '';\n  if (typeof data !== 'undefined') {\n    ret += '$ORIGIN ' + data;\n  }\n  return template.replace('{$origin}', ret);\n}\n\nfunction processTTL(data: number | undefined, template: string) {\n  let ret = '';\n  if (typeof data !== 'undefined') {\n    ret += '$TTL ' + data;\n  }\n  return template.replace('{$ttl}', ret);\n}\n\nfunction processSOA(data: SoaType | undefined, template: string) {\n  let ret = template;\n  if (typeof data !== 'undefined') {\n    data.name = data.name || '@';\n    data.ttl = data.ttl || '';\n    for (const key in data) {\n      const value = (data as Record<string, string>)[key];\n      ret = ret.replace('{' + key + '}', value + '\\t');\n    }\n  }\n  return ret;\n}\n\nfunction processNS(data: NSType[] | undefined, template: string) {\n  let ret = '';\n  if (data) {\n    for (const record of data) {\n      ret += (record.name || '@') + '\\t';\n      if (record.ttl) ret += record.ttl + '\\t';\n      ret += 'IN\\tNS\\t' + record.host + '\\n';\n    }\n  }\n  return template.replace('{ns}', ret);\n}\n\nfunction processA(data: AType[] | undefined, template: string) {\n  let ret = '';\n  if (data) {\n    for (const record of data) {\n      ret += (record.name || '@') + '\\t';\n      if (record.ttl) ret += record.ttl + '\\t';\n      ret += 'IN\\tA\\t' + record.ip + '\\n';\n    }\n  }\n  return template.replace('{a}', ret);\n}\n\nfunction processAAAA(data: AType[] | undefined, template: string) {\n  let ret = '';\n  if (data) {\n    for (const record of data) {\n      ret += (record.name || '@') + '\\t';\n      if (record.ttl) ret += record.ttl + '\\t';\n      ret += 'IN\\tAAAA\\t' + record.ip + '\\n';\n    }\n  }\n  return template.replace('{aaaa}', ret);\n}\n\nfunction processCNAME(data: CNAMEType[] | undefined, template: string) {\n  let ret = '';\n  if (data) {\n    for (const record of data) {\n      ret += (record.name || '@') + '\\t';\n      if (record.ttl) ret += record.ttl + '\\t';\n      ret += 'IN\\tCNAME\\t' + record.alias + '\\n';\n    }\n  }\n  return template.replace('{cname}', ret);\n}\n\nfunction processMX(data: MXType[] | undefined, template: string) {\n  let ret = '';\n  if (data) {\n    for (const record of data) {\n      ret += (record.name || '@') + '\\t';\n      if (record.ttl) ret += record.ttl + '\\t';\n      ret += 'IN\\tMX\\t' + record.preference + '\\t' + record.host + '\\n';\n    }\n  }\n  return template.replace('{mx}', ret);\n}\n\nfunction processPTR(data: NSType[] | undefined, template: string) {\n  let ret = '';\n  if (data) {\n    for (const record of data) {\n      ret += (record.name || '@') + '\\t';\n      if (record.ttl) ret += record.ttl + '\\t';\n      ret += 'IN\\tPTR\\t' + record.host + '\\n';\n    }\n  }\n  return template.replace('{ptr}', ret);\n}\n\nfunction processTXT(data: TXTType[] | undefined, template: string) {\n  let ret = '';\n  if (data) {\n    for (const record of data) {\n      ret += (record.name || '@') + '\\t';\n      if (record.ttl) ret += record.ttl + '\\t';\n      ret += 'IN\\tTXT\\t';\n      const txtData = record.txt;\n      if (typeof txtData === 'string') {\n        ret += '\"' + txtData + '\"';\n      } else if (txtData instanceof Array) {\n        ret += txtData\n          .map(function(datum) {\n            return '\"' + datum + '\"';\n          })\n          .join(' ');\n      }\n      ret += '\\n';\n    }\n  }\n  return template.replace('{txt}', ret);\n}\n\nfunction processSRV(data: SRVType[] | undefined, template: string) {\n  let ret = '';\n  if (data) {\n    for (const record of data) {\n      ret += (record.name || '@') + '\\t';\n      if (record.ttl) ret += record.ttl + '\\t';\n      ret += 'IN\\tSRV\\t' + record.priority + '\\t';\n      ret += record.weight + '\\t';\n      ret += record.port + '\\t';\n      ret += record.target + '\\n';\n    }\n  }\n  return template.replace('{srv}', ret);\n}\n\nfunction processSPF(data: SPFType[] | undefined, template: string) {\n  let ret = '';\n  if (data) {\n    for (const record of data) {\n      ret += (record.name || '@') + '\\t';\n      if (record.ttl) ret += record.ttl + '\\t';\n      ret += 'IN\\tSPF\\t' + record.data + '\\n';\n    }\n  }\n  return template.replace('{spf}', ret);\n}\n\nfunction processURI(data: URIType[] | undefined, template: string) {\n  let ret = '';\n  if (data) {\n    for (const record of data) {\n      ret += (record.name || '@') + '\\t';\n      if (record.ttl) ret += record.ttl + '\\t';\n      ret += 'IN\\tURI\\t' + record.priority + '\\t';\n      ret += record.weight + '\\t';\n      ret += '\"' + record.target + '\"\\n';\n    }\n  }\n  return template.replace('{uri}', ret);\n}\n\nfunction processValues(jsonZoneFile: ZoneFileObject, template: string) {\n  template = template.replace(\n    '{zone}',\n    jsonZoneFile['$origin'] || (jsonZoneFile['soa'] ? jsonZoneFile['soa']['name'] : false) || ''\n  );\n  template = template.replace('{datetime}', new Date().toISOString());\n  const time = Math.round(Date.now() / 1000);\n  return template.replace('{time}', `${time}`);\n}\n","export function getZoneFileTemplate() {\n  return '{$origin}\\n\\\n{$ttl}\\n\\\n\\n\\\n; SOA Record\\n\\\n{name} {ttl}    IN  SOA {mname}{rname}(\\n\\\n{serial} ;serial\\n\\\n{refresh} ;refresh\\n\\\n{retry} ;retry\\n\\\n{expire} ;expire\\n\\\n{minimum} ;minimum ttl\\n\\\n)\\n\\\n\\n\\\n; NS Records\\n\\\n{ns}\\n\\\n\\n\\\n; MX Records\\n\\\n{mx}\\n\\\n\\n\\\n; A Records\\n\\\n{a}\\n\\\n\\n\\\n; AAAA Records\\n\\\n{aaaa}\\n\\\n\\n\\\n; CNAME Records\\n\\\n{cname}\\n\\\n\\n\\\n; PTR Records\\n\\\n{ptr}\\n\\\n\\n\\\n; TXT Records\\n\\\n{txt}\\n\\\n\\n\\\n; SRV Records\\n\\\n{srv}\\n\\\n\\n\\\n; SPF Records\\n\\\n{spf}\\n\\\n\\n\\\n; URI Records\\n\\\n{uri}\\n\\\n';\n}\n","import {\n  NSType,\n  AType,\n  CNAMEType,\n  MXType,\n  TXTType,\n  SRVType,\n  SPFType,\n  URIType,\n  ZoneFileObject,\n  SoaType,\n} from './zoneFile';\n\nexport function parseZoneFile(text: string) {\n  text = removeComments(text);\n  text = flatten(text);\n  return parseRRs(text);\n}\n\nfunction removeComments(text: string) {\n  const re = /(^|[^\\\\]);.*/g;\n  return text.replace(re, function(_m, g1) {\n    return g1 ? g1 : ''; // if g1 is set/matched, re-insert it, else remove\n  });\n}\n\nfunction flatten(text: string) {\n  const captured = [];\n  const re = /\\([\\s\\S]*?\\)/gim;\n  let match = re.exec(text);\n  while (match !== null) {\n    const replacement = match[0].replace(/\\s+/gm, ' ');\n    captured.push({ match, replacement });\n    // captured Text, index, input\n    match = re.exec(text);\n  }\n  const arrText = text.split('');\n  for (const cur of captured) {\n    const { match, replacement } = cur;\n    arrText.splice(match.index, match[0].length, replacement);\n  }\n  return arrText.join('').replace(/\\(|\\)/gim, ' ');\n}\n\nfunction parseRRs(text: string) {\n  const ret: ZoneFileObject = {};\n  const rrs = text.split('\\n');\n  for (const rr of rrs) {\n    if (!rr || !rr.trim()) {\n      continue;\n    }\n    const uRR = rr.toUpperCase();\n    if (/\\s+TXT\\s+/.test(uRR)) {\n      ret.txt = ret.txt || [];\n      ret.txt.push(parseTXT(rr));\n    } else if (uRR.indexOf('$ORIGIN') === 0) {\n      ret.$origin = rr.split(/\\s+/g)[1];\n    } else if (uRR.indexOf('$TTL') === 0) {\n      ret.$ttl = parseInt(rr.split(/\\s+/g)[1], 10);\n    } else if (/\\s+SOA\\s+/.test(uRR)) {\n      ret.soa = parseSOA(rr);\n    } else if (/\\s+NS\\s+/.test(uRR)) {\n      ret.ns = ret.ns || [];\n      ret.ns.push(parseNS(rr));\n    } else if (/\\s+A\\s+/.test(uRR)) {\n      ret.a = ret.a || [];\n      ret.a.push(parseA(rr, ret.a));\n    } else if (/\\s+AAAA\\s+/.test(uRR)) {\n      ret.aaaa = ret.aaaa || [];\n      ret.aaaa.push(parseAAAA(rr));\n    } else if (/\\s+CNAME\\s+/.test(uRR)) {\n      ret.cname = ret.cname || [];\n      ret.cname.push(parseCNAME(rr));\n    } else if (/\\s+MX\\s+/.test(uRR)) {\n      ret.mx = ret.mx || [];\n      ret.mx.push(parseMX(rr));\n    } else if (/\\s+PTR\\s+/.test(uRR)) {\n      ret.ptr = ret.ptr || [];\n      ret.ptr.push(parsePTR(rr, ret.ptr, ret.$origin));\n    } else if (/\\s+SRV\\s+/.test(uRR)) {\n      ret.srv = ret.srv || [];\n      ret.srv.push(parseSRV(rr));\n    } else if (/\\s+SPF\\s+/.test(uRR)) {\n      ret.spf = ret.spf || [];\n      ret.spf.push(parseSPF(rr));\n    } else if (/\\s+URI\\s+/.test(uRR)) {\n      ret.uri = ret.uri || [];\n      ret.uri.push(parseURI(rr));\n    }\n  }\n  return ret;\n}\n\nfunction parseSOA(rr: string) {\n  const soa: SoaType = {};\n  const rrTokens = rr.trim().split(/\\s+/g);\n  const l = rrTokens.length;\n  soa.name = rrTokens[0];\n  soa.minimum = parseInt(rrTokens[l - 1], 10);\n  soa.expire = parseInt(rrTokens[l - 2], 10);\n  soa.retry = parseInt(rrTokens[l - 3], 10);\n  soa.refresh = parseInt(rrTokens[l - 4], 10);\n  soa.serial = parseInt(rrTokens[l - 5], 10);\n  soa.rname = rrTokens[l - 6];\n  soa.mname = rrTokens[l - 7];\n  if (!isNaN((rrTokens[1] as unknown) as number)) soa.ttl = parseInt(rrTokens[1], 10);\n  return soa;\n}\n\nfunction parseNS(rr: string) {\n  const rrTokens = rr.trim().split(/\\s+/g);\n  const l = rrTokens.length;\n  const result: NSType = {\n    name: rrTokens[0],\n    host: rrTokens[l - 1],\n  };\n\n  if (!isNaN((rrTokens[1] as unknown) as number)) result.ttl = parseInt(rrTokens[1], 10);\n  return result;\n}\n\nfunction parseA(rr: string, recordsSoFar: AType[]) {\n  const rrTokens = rr.trim().split(/\\s+/g);\n  const urrTokens = rr\n    .trim()\n    .toUpperCase()\n    .split(/\\s+/g);\n  const l = rrTokens.length;\n  const result: AType = {\n    name: rrTokens[0],\n    ip: rrTokens[l - 1],\n  };\n\n  if (urrTokens.lastIndexOf('A') === 0) {\n    if (recordsSoFar.length) {\n      result.name = recordsSoFar[recordsSoFar.length - 1].name;\n    } else {\n      result.name = '@';\n    }\n  }\n\n  if (!isNaN((rrTokens[1] as unknown) as number)) result.ttl = parseInt(rrTokens[1], 10);\n  return result;\n}\n\nfunction parseAAAA(rr: string) {\n  const rrTokens = rr.trim().split(/\\s+/g);\n  const l = rrTokens.length;\n  const result: AType = {\n    name: rrTokens[0],\n    ip: rrTokens[l - 1],\n  };\n\n  if (!isNaN((rrTokens[1] as unknown) as number)) result.ttl = parseInt(rrTokens[1], 10);\n  return result;\n}\n\nfunction parseCNAME(rr: string) {\n  const rrTokens = rr.trim().split(/\\s+/g);\n  const l = rrTokens.length;\n  const result: CNAMEType = {\n    name: rrTokens[0],\n    alias: rrTokens[l - 1],\n  };\n\n  if (!isNaN((rrTokens[1] as unknown) as number)) result.ttl = parseInt(rrTokens[1], 10);\n  return result;\n}\n\nfunction parseMX(rr: string) {\n  const rrTokens = rr.trim().split(/\\s+/g);\n  const l = rrTokens.length;\n  const result: MXType = {\n    name: rrTokens[0],\n    preference: parseInt(rrTokens[l - 2], 10),\n    host: rrTokens[l - 1],\n  };\n\n  if (!isNaN((rrTokens[1] as unknown) as number)) result.ttl = parseInt(rrTokens[1], 10);\n  return result;\n}\n\nfunction parseTXT(rr: string) {\n  const rrTokens = rr.trim().match(/[^\\s\"']+|\"[^\"]*\"|'[^']*'/g);\n  if (!rrTokens) throw new Error('Failure to tokenize TXT record');\n  const l = rrTokens.length;\n  const indexTXT = rrTokens.indexOf('TXT');\n\n  function stripText(txt: string) {\n    if (txt.indexOf('\"') > -1) {\n      txt = txt.split('\"')[1];\n    }\n    return txt;\n  }\n\n  let tokenTxt: string | string[];\n  if (l - indexTXT - 1 > 1) {\n    tokenTxt = [...rrTokens.slice(indexTXT + 1).map(stripText)];\n  } else {\n    tokenTxt = stripText(rrTokens[l - 1]);\n  }\n\n  const result: TXTType = {\n    name: rrTokens[0],\n    txt: tokenTxt,\n  };\n\n  if (!isNaN((rrTokens[1] as unknown) as number)) result.ttl = parseInt(rrTokens[1], 10);\n  return result;\n}\n\nfunction parsePTR(rr: string, recordsSoFar: NSType[], currentOrigin: string | undefined) {\n  const rrTokens = rr.trim().split(/\\s+/g);\n  const urrTokens = rr\n    .trim()\n    .toUpperCase()\n    .split(/\\s+/g);\n\n  if (urrTokens.lastIndexOf('PTR') === 0 && recordsSoFar[recordsSoFar.length - 1]) {\n    rrTokens.unshift(recordsSoFar[recordsSoFar.length - 1].name as string);\n  }\n\n  const l = rrTokens.length;\n  const result: NSType = {\n    name: rrTokens[0],\n    fullname: rrTokens[0] + '.' + currentOrigin,\n    host: rrTokens[l - 1],\n  };\n\n  if (!isNaN((rrTokens[1] as unknown) as number)) result.ttl = parseInt(rrTokens[1], 10);\n  return result;\n}\n\nfunction parseSRV(rr: string) {\n  const rrTokens = rr.trim().split(/\\s+/g);\n  const l = rrTokens.length;\n  const result: SRVType = {\n    name: rrTokens[0],\n    target: rrTokens[l - 1],\n    priority: parseInt(rrTokens[l - 4], 10),\n    weight: parseInt(rrTokens[l - 3], 10),\n    port: parseInt(rrTokens[l - 2], 10),\n  };\n\n  if (!isNaN((rrTokens[1] as unknown) as number)) result.ttl = parseInt(rrTokens[1], 10);\n  return result;\n}\n\nfunction parseSPF(rr: string) {\n  const rrTokens = rr.trim().split(/\\s+/g);\n  const result: SPFType = {\n    name: rrTokens[0],\n    data: '',\n  };\n\n  let l = rrTokens.length;\n  while (l-- > 4) {\n    result.data = rrTokens[l] + ' ' + result.data.trim();\n  }\n\n  if (!isNaN((rrTokens[1] as unknown) as number)) result.ttl = parseInt(rrTokens[1], 10);\n  return result;\n}\n\nfunction parseURI(rr: string) {\n  const rrTokens = rr.trim().split(/\\s+/g);\n  const l = rrTokens.length;\n  const result: URIType = {\n    name: rrTokens[0],\n    target: rrTokens[l - 1].replace(/\"/g, ''),\n    priority: parseInt(rrTokens[l - 3], 10),\n    weight: parseInt(rrTokens[l - 2], 10),\n  };\n\n  if (!isNaN((rrTokens[1] as unknown) as number)) result.ttl = parseInt(rrTokens[1], 10);\n  return result;\n}\n","import { makeZoneFile } from './makeZoneFile';\nimport { parseZoneFile } from './parseZoneFile';\n\nexport type SoaType = {\n  name?: string;\n  ttl?: number | string;\n  minimum?: number;\n  expire?: number;\n  retry?: number;\n  refresh?: number;\n  serial?: number;\n  rname?: string;\n  mname?: string;\n};\nexport type NSType = { name: string; ttl?: number; host: string; fullname?: string };\nexport type AType = { name: string; ttl?: number; ip: string };\nexport type CNAMEType = { name: string; ttl?: number; alias: string };\nexport type MXType = { name: string; ttl?: number; host: string; preference: number };\nexport type TXTType = { name: string; ttl?: number; txt: string | string[] };\nexport type SRVType = { name: string; ttl?: number; priority: number; weight: number; port: number; target: string };\nexport type SPFType = { name: string; ttl?: number; data: string };\nexport type URIType = { name: string; ttl?: number; priority: number; weight: number; target: string };\n\nexport type ZoneFileObject = {\n  $origin?: string;\n  $ttl?: number;\n  soa?: SoaType;\n  ns?: NSType[];\n  a?: AType[];\n  aaaa?: AType[];\n  cname?: CNAMEType[];\n  mx?: MXType[];\n  ptr?: NSType[];\n  txt?: TXTType[];\n  srv?: SRVType[];\n  spf?: SPFType[];\n  uri?: URIType[];\n  $domain?: string;\n};\n\nexport class ZoneFile {\n  jsonZoneFile: ZoneFileObject;\n\n  constructor(zoneFile: ZoneFileObject | string) {\n    if (typeof zoneFile === 'object') {\n      this.jsonZoneFile = JSON.parse(JSON.stringify(zoneFile));\n    } else if (typeof zoneFile === 'string') {\n      this.jsonZoneFile = parseZoneFile(zoneFile);\n    } else {\n      this.jsonZoneFile = (undefined as unknown) as ZoneFileObject;\n    }\n  }\n\n  toJSON() {\n    return this.jsonZoneFile;\n  }\n\n  toString() {\n    return makeZoneFile(this.toJSON());\n  }\n}\n"],"names":["makeZoneFile","jsonZoneFile","template","data","ret","replace","processOrigin","processTTL","key","name","ttl","processSOA","record","host","processNS","ip","processA","processAAAA","alias","processCNAME","preference","processMX","processPTR","txtData","txt","Array","map","datum","join","processTXT","priority","weight","port","target","processSRV","processSPF","Date","toISOString","time","Math","round","now","processValues","processURI","parseZoneFile","text","split","rr","trim","uRR","toUpperCase","test","push","parseTXT","indexOf","$origin","$ttl","parseInt","soa","parseSOA","ns","parseNS","a","parseA","aaaa","parseAAAA","cname","parseCNAME","mx","parseMX","ptr","parsePTR","srv","parseSRV","spf","parseSPF","uri","parseURI","parseRRs","captured","re","match","exec","replacement","arrText","cur","splice","index","length","flatten","_m","g1","removeComments","rrTokens","l","minimum","expire","retry","refresh","serial","rname","mname","isNaN","result","recordsSoFar","urrTokens","lastIndexOf","Error","tokenTxt","indexTXT","stripText","slice","currentOrigin","unshift","fullname","zoneFile","JSON","parse","stringify","undefined","toJSON","this","toString"],"mappings":"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"}